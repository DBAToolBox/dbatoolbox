USE [SYSAdmin]
GO
/****** Object:  UserDefinedFunction [dbo].[blackout]    Script Date: 2/17/2023 4:17:28 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [dbo].[blackout] (@incoming_time datetime)
-------SQL 2012 EDITION  v06_2012--------------------------------
-------------------------------------------------------------------------
--Description:  This SQL Function returns a 1 after checking the 
--date passed from @current_time is greater than the start_time and
--less than the end_time from SYSAdmin.dbo.blackout_schedule.
-------------------------------------------------------------------------
-------------------------------------------------------------------------
/*
The following values are valid for blackout_DayofWeek:
Value	Day of week.
1		Sunday
2		Monday
3		Tuesday
4		Wednesday
5		Thursday
6		Friday
7		Saturday
*/

RETURNS tinyint

AS
BEGIN
	DECLARE
		@current_day as tinyint,
		@current_time as varchar(15),
		@start_time as varchar(15),
		@end_time as varchar(15),
		@blackout_day as tinyint,
		@i as tinyint

	SET @i = 0

	SET @current_day = DATEPART(dw, @incoming_time)
	SET @current_time = CONVERT(varchar(15) , @incoming_time ,114 )

	IF object_id('SYSAdmin.dbo.blackout_schedule', 'U') is not null 
	BEGIN
		IF (
			SELECT COUNT(id) 
			FROM SYSAdmin.dbo.blackout_schedule 
			WHERE 
				blackout_DayofWeek = @current_day AND
				@current_time >= start_time AND
				@current_time <= end_time
			) > 0
			BEGIN
				SET @i = 1
			END
	END

RETURN @i

END
GO
/****** Object:  UserDefinedFunction [dbo].[fn_hex_to_char]    Script Date: 2/17/2023 4:17:28 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [dbo].[fn_hex_to_char] (
	@x VARBINARY(100), -- binary hex value
	@l INT -- number of bytes
) RETURNS VARCHAR(200) AS
-------SQL 2012 EDITION  v06_2012----------------------------
----------------------------------------------------------------
--	Description: This function will take any binary value and return
--	the hex value as a character representation.
--	In order to use this function you need to pass the
--	binary hex value and the number of bytes you want to convert.
--
--	Written by: Gregory A. Larsen
--	Date: May 25, 2004
----------------------------------------------------------------
BEGIN
DECLARE 
	@i varbinary(10), 
	@digits CHAR(16),
	@s varchar(100),
	@h varchar(100),
	@j int;

SET @digits = '0123456789ABCDEF'
SET @j = 0
SET @h = ''

-- process all  bytes
WHILE @j < @l
BEGIN
	SET @j= @j + 1
	-- get first character of byte
	SET @i = substring(cast(@x as VARBINARY(100)),@j,1)
	-- get the first character
	SET @s = cast(substring(@digits,@i%16+1,1) AS CHAR(1))
	-- shift over one character
	SET @i = @i/16
	-- get the second character
	SET @s = cast(substring(@digits,@i%16+1,1) AS CHAR(1)) + @s
	-- build string of hex characters
	SET @h = @h + @s
END
RETURN(@h)
END
GO
/****** Object:  Table [dbo].[blackout_schedule]    Script Date: 2/17/2023 4:17:28 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[blackout_schedule](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[start_time] [varchar](15) NULL,
	[end_time] [varchar](15) NULL,
	[blackout_DayofWeek] [tinyint] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[DBGrowthRate]    Script Date: 2/17/2023 4:17:28 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[DBGrowthRate](
	[DBGrowthID] [int] IDENTITY(1,1) NOT NULL,
	[DBName] [varchar](100) NULL,
	[DBID] [int] NULL,
	[NumPages] [int] NULL,
	[OrigSize] [decimal](15, 2) NULL,
	[CurSize] [decimal](15, 2) NULL,
	[Unused] [decimal](15, 2) NULL,
	[GrowthAmt] [varchar](100) NULL,
	[MetricDate] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[EventInfoMain_His]    Script Date: 2/17/2023 4:17:28 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[EventInfoMain_His](
	[Resource_db_id] [int] NULL,
	[Spid] [int] NULL,
	[SpidEventInfo] [nvarchar](4000) NULL,
	[BlkBySpid] [int] NULL,
	[BlkByEventInfo] [nvarchar](4000) NULL,
	[blkby_status] [nvarchar](30) NULL,
	[blkby_loginame] [nvarchar](128) NULL,
	[blkby_nt_username] [nvarchar](128) NULL,
	[blkby_hostname] [nvarchar](128) NULL,
	[blkby_net_address] [varchar](48) NULL,
	[DBName] [nvarchar](128) NULL,
	[spid_command] [nvarchar](16) NULL,
	[blkby_program_name] [nvarchar](128) NULL,
	[spid_wait_type] [nvarchar](60) NULL,
	[dtStampFound] [datetime] NULL,
	[dtStampReleased] [datetime] NULL,
	[ID] [uniqueidentifier] NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[EventInfoMain_Tmp]    Script Date: 2/17/2023 4:17:28 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[EventInfoMain_Tmp](
	[Resource_db_id] [int] NULL,
	[Spid] [int] NULL,
	[SpidEventInfo] [nvarchar](4000) NULL,
	[BlkBySpid] [int] NULL,
	[BlkByEventInfo] [nvarchar](4000) NULL,
	[blkby_status] [nvarchar](30) NULL,
	[blkby_loginame] [nvarchar](128) NULL,
	[blkby_nt_username] [nvarchar](128) NULL,
	[blkby_hostname] [nvarchar](128) NULL,
	[blkby_net_address] [varchar](48) NULL,
	[DBName] [nvarchar](128) NULL,
	[spid_command] [nvarchar](16) NULL,
	[blkby_program_name] [nvarchar](128) NULL,
	[spid_wait_type] [nvarchar](60) NULL,
	[FirstimeFound] [bit] NULL,
	[EmailSent] [bit] NULL,
	[dtStamp] [datetime] NULL,
	[ID] [uniqueidentifier] NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG]    Script Date: 2/17/2023 4:17:28 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG](
	[proc_name] [varchar](100) NOT NULL,
	[mail_profile_name] [varchar](100) NULL,
	[mail_recipients] [varchar](8000) NULL,
	[mail_copy_recipients] [varchar](8000) NULL,
	[mail_blind_copy_recipients] [varchar](8000) NULL,
	[variable1] [varchar](100) NULL,
	[variable2] [varchar](100) NULL,
	[variable3] [varchar](100) NULL,
	[variable4] [varchar](100) NULL,
	[variable5] [varchar](100) NULL,
	[variable6] [varchar](100) NULL,
	[dba_primary] [varchar](100) NULL,
	[dba_secondary] [varchar](100) NULL,
	[dba_group] [varchar](100) NULL,
	[pager] [varchar](100) NULL,
UNIQUE NONCLUSTERED 
(
	[proc_name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_BackupReports]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_BackupReports](
	[database_name] [nvarchar](500) NOT NULL,
	[hours_between_backups] [int] NOT NULL,
	[user] [varchar](128) NULL,
	[date] [datetime] NULL,
	[id] [int] IDENTITY(1,1) NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Database_Backups]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Database_Backups](
	[instance_name] [varchar](100) NULL,
	[database_name] [varchar](100) NULL,
	[backup_start_date] [datetime] NULL,
	[backup_finish_date] [datetime] NULL,
	[comments] [varchar](50) NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Database_File_Information]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Database_File_Information](
	[instance_name] [varchar](100) NULL,
	[database_name] [varchar](100) NULL,
	[logical_name] [varchar](100) NULL,
	[initial_size_mb] [int] NULL,
	[auto_growth_mb] [int] NULL,
	[auto_growth_percentage] [int] NULL,
	[file_path] [varchar](200) NULL,
	[file_name] [varchar](100) NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Database_Object_Permissions]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Database_Object_Permissions](
	[instancename] [varchar](100) NULL,
	[databasename] [varchar](100) NULL,
	[owner] [varchar](8000) NULL,
	[objectname] [varchar](8000) NULL,
	[grantee] [varchar](8000) NULL,
	[grantor] [varchar](8000) NULL,
	[protect_type] [varchar](8000) NULL,
	[action] [varchar](8000) NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Database_Stats]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Database_Stats](
	[instance_name] [varchar](100) NULL,
	[database_name] [varchar](100) NULL,
	[allocated_mb] [varchar](50) NULL,
	[used_mb] [varchar](50) NULL,
	[pages] [int] NULL,
	[growth] [varchar](50) NULL,
	[owner] [varchar](50) NULL,
	[compatibility_level] [varchar](50) NULL,
	[recovery_model] [varchar](50) NULL,
	[db_created_date] [datetime] NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Database_UserAccounts]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Database_UserAccounts](
	[instance_name] [varchar](300) NULL,
	[database_name] [varchar](300) NULL,
	[user_name] [varchar](250) NULL,
	[login_name] [varchar](250) NULL,
	[user_active_status] [bit] NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Database_Users_Roles]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Database_Users_Roles](
	[instancename] [varchar](100) NULL,
	[databasename] [varchar](100) NULL,
	[username] [varchar](100) NULL,
	[rolename] [varchar](100) NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_DriveSpace]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_DriveSpace](
	[drive] [varchar](100) NOT NULL,
	[monitor] [bit] NOT NULL,
	[warningMBThreshold] [int] NULL,
	[warningPercThreshold] [tinyint] NULL,
	[criticalMBThreshold] [int] NULL,
	[criticalPercThreshold] [tinyint] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_DriveSpace_Temp]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_DriveSpace_Temp](
	[drive] [varchar](100) NOT NULL,
	[warning] [bit] NULL,
	[warningDate] [datetime] NULL,
	[sendWarnEmail] [bit] NULL,
	[critical] [bit] NULL,
	[criticalDate] [datetime] NULL,
	[sendCritEmail] [bit] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Instance]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Instance](
	[instance_name] [varchar](50) NOT NULL,
	[host_name] [varchar](50) NOT NULL,
	[instance_version] [varchar](50) NOT NULL,
	[life_cycle] [varchar](50) NULL,
	[is_clustered] [bit] NULL,
	[updated_date] [datetime] NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_InstanceConfigurationSettings]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_InstanceConfigurationSettings](
	[instance_name] [varchar](50) NOT NULL,
	[parameter_name] [varchar](50) NULL,
	[parameter_value] [varchar](50) NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Job_Information]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Job_Information](
	[instance_name] [varchar](100) NULL,
	[job_name] [varchar](250) NULL,
	[job_owner] [varchar](100) NULL,
	[job_description] [varchar](1000) NULL,
	[enabled] [tinyint] NULL,
	[job_created_date] [datetime] NULL,
	[job_last_modified_date] [datetime] NULL,
	[job_schedule] [varchar](400) NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Job_Status]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Job_Status](
	[instance_name] [varchar](100) NULL,
	[job_name] [varchar](1000) NULL,
	[job_run_date] [datetime] NULL,
	[job_duration] [varchar](50) NULL,
	[job_status] [varchar](500) NULL,
	[job_message] [varchar](4000) NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Log_Exception]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Log_Exception](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[Exception_Filter1] [nvarchar](1024) NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Log_Filter]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Log_Filter](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[Log_Filter1] [nvarchar](1024) NOT NULL,
	[Log_Filter2] [nvarchar](1024) NULL,
	[Log_Filter3] [nvarchar](1024) NULL,
	[Error_Description] [nvarchar](256) NOT NULL,
	[severity] [nvarchar](50) NOT NULL,
	[event_error] [int] NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Log_LastEntry]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Log_LastEntry](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[Log_Error_Date] [datetime] NULL,
	[SQL_Log_Error] [nvarchar](2048) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_LogonAccounts]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_LogonAccounts](
	[instance_name] [varchar](100) NOT NULL,
	[logon_account_name] [varchar](100) NULL,
	[logon_active_status] [bit] NULL,
	[logon_user_type] [varchar](50) NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_LogonAccountsServerPermissions]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_LogonAccountsServerPermissions](
	[instance_name] [varchar](50) NOT NULL,
	[logon_account_name] [varchar](100) NOT NULL,
	[permission] [varchar](50) NOT NULL,
	[permission_type] [varchar](50) NOT NULL,
	[login_type] [varchar](50) NOT NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_LogonAccountsServerRoles]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_LogonAccountsServerRoles](
	[instance_name] [varchar](100) NOT NULL,
	[server_role] [varchar](100) NOT NULL,
	[logon_account_name] [varchar](100) NOT NULL,
	[updated_date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_CFG_Support_Lifecycle]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_CFG_Support_Lifecycle](
	[Version] [varchar](10) NOT NULL,
	[Description] [varchar](20) NOT NULL,
	[Support_Status] [varchar](20) NOT NULL,
	[End_Mainstream_Support] [datetime] NULL,
	[End_Extended_Support] [datetime] NULL,
	[EOSL_Date] [datetime] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_JobHistory]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_JobHistory](
	[history_id] [int] IDENTITY(1,1) NOT NULL,
	[Insert_DT] [datetime] NULL,
	[instance_id] [int] NULL,
	[job_id] [uniqueidentifier] NULL,
	[job_nm] [sysname] NOT NULL,
	[last_run_date] [datetime] NULL,
	[duration] [int] NULL,
	[long_running_flag] [char](1) NULL,
	[email_sent_flag] [char](1) NULL,
PRIMARY KEY CLUSTERED 
(
	[history_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[MON_SQL_Jobs_Config]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MON_SQL_Jobs_Config](
	[job_nm] [varchar](128) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[Upload_Stats]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Upload_Stats](
	[a_instance_name] [varchar](100) NULL,
	[a_time_zone] [varchar](50) NULL,
	[a_listener_port] [varchar](50) NULL,
	[a_db_type] [varchar](50) NULL,
	[a_log_mode] [varchar](50) NULL,
	[a_host_name] [varchar](100) NULL,
	[a_domain_name] [varchar](50) NULL,
	[a_startup_time] [varchar](50) NULL,
	[a_uptime_days] [varchar](10) NULL,
	[a_os_type] [varchar](50) NULL,
	[a_os_version] [varchar](50) NULL,
	[a_vendor] [varchar](50) NULL,
	[a_db_version] [varchar](50) NULL,
	[a_files_mb] [varchar](50) NULL,
	[a_segments_mb] [varchar](50) NULL,
	[a_num_schemas] [varchar](10) NULL,
	[a_num_tables] [varchar](10) NULL,
	[a_num_objects] [varchar](10) NULL
) ON [PRIMARY]
GO
ALTER TABLE [dbo].[EventInfoMain_Tmp] ADD  DEFAULT ((1)) FOR [FirstimeFound]
GO
ALTER TABLE [dbo].[EventInfoMain_Tmp] ADD  DEFAULT ((0)) FOR [EmailSent]
GO
ALTER TABLE [dbo].[EventInfoMain_Tmp] ADD  DEFAULT (getdate()) FOR [dtStamp]
GO
ALTER TABLE [dbo].[EventInfoMain_Tmp] ADD  DEFAULT (newid()) FOR [ID]
GO
ALTER TABLE [dbo].[MON_SQL_CFG_DriveSpace] ADD  DEFAULT ((1)) FOR [monitor]
GO
ALTER TABLE [dbo].[MON_SQL_JobHistory] ADD  DEFAULT (getdate()) FOR [Insert_DT]
GO
ALTER TABLE [dbo].[blackout_schedule]  WITH CHECK ADD CHECK  (([blackout_DayofWeek]>=(1) AND [blackout_DayofWeek]<=(7)))
GO
ALTER TABLE [dbo].[MON_SQL_CFG_DriveSpace]  WITH CHECK ADD  CONSTRAINT [CK_criticalPercThreshold] CHECK  (([criticalPercThreshold]>=(0) AND [criticalPercThreshold]<=(100)))
GO
ALTER TABLE [dbo].[MON_SQL_CFG_DriveSpace] CHECK CONSTRAINT [CK_criticalPercThreshold]
GO
ALTER TABLE [dbo].[MON_SQL_CFG_DriveSpace]  WITH CHECK ADD  CONSTRAINT [CK_warningPercThreshold] CHECK  (([warningPercThreshold]>=(0) AND [warningPercThreshold]<=(100)))
GO
ALTER TABLE [dbo].[MON_SQL_CFG_DriveSpace] CHECK CONSTRAINT [CK_warningPercThreshold]
GO
/****** Object:  StoredProcedure [dbo].[usp_BackupReports]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_BackupReports] AS
-------SQL 2012 EDITION  v06_2012----------------------------
----------------------------------------------------------------
-- This proc checks for databases that are not being backed-up,
-- databases that haven't been backed-up for more than 48 hours,
-- and databases that have exceeded the hours_between_backups 
-- listed within MON_SQL_CFG_BackupReports.
-- If an email alert is sent for any of the above three reasons, 
-- a message is logged to the Application Eventlog of:
-- @SERVER_NAME; BACKUP WARNING; 
-- 
-- Execute the following command to view all settings for this script:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_BackupReports'
--
-- 	mail_profile_name = SQL DBMail profile name to be used by this script.
--	mail_recipients = Email Address to send messages TO
----------------------------------------------------------------

SET NOCOUNT ON
DECLARE @client varchar(100)
SELECT @client = isnull([variable2],'client_name_missing') FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc'

DECLARE
	@SERVER_NAME varchar(100),
    @subject2 varchar (150),
    @email_body nvarchar(4000),
	@event_message varchar(255),
    @current_date char(20),
    @x int,
    @z int,
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000);

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_BackupReports') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG (proc_name) VALUES ('usp_BackupReports')
	END

	SELECT  
		@mail_profile_name = mail_profile_name,
		@mail_recipients = mail_recipients,
		@mail_copy_recipients = mail_copy_recipients,
		@mail_blind_copy_recipients = mail_blind_copy_recipients
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_BackupReports';
	
--If the table MON_SQL_CFG_BackupReports does not exist, it is created now.
IF object_id('SYSAdmin.dbo.MON_SQL_CFG_BackupReports', 'U') IS NULL 
	BEGIN
		CREATE TABLE [dbo].[MON_SQL_CFG_BackupReports]
		(
			[database_name] [nvarchar](500) NOT NULL,
			[hours_between_backups] [int] NOT NULL,
			[user] [varchar](128) NULL,
			[date] [datetime] NULL,
			[id] INT NOT NULL IDENTITY (1, 1)
		);
	END

SET @current_date = (SELECT CONVERT( varchar(20), GETDATE(), 120)  )

-- Get the host name
SET @SERVER_NAME = @@servername
SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))
select @subject2 = 'MON_SQL : ' + @client + ' : ' + @SERVER_NAME + ' Backup Report'

--Creating the first section of Job Email
Set @email_body = 'Job ' + CHAR(39) + '*Backup Problem Report' + CHAR(39) + ' : v06_2012'
Set @email_body = @email_body + CHAR(13)+ CHAR(10)+ '  ' + CHAR(13)+CHAR(10)
Set @email_body = @email_body + 'Backup Report : Began Executing ' + @current_date 
Set @email_body = @email_body + CHAR(13)+CHAR(10)


--Used to hold DB info that have been backed up.
IF object_id('tempdb..#tblBackupHistory', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #tblBackupHistory
END
ELSE
BEGIN
	CREATE TABLE #tblBackupHistory (
		database_name		NVARCHAR(256) NULL,
		backup_start_date	DATETIME,
		backup_finish_date	DATETIME,
		backup_duration		INT,
		backup_size			NUMERIC(20,0)
	)			
END

--Used to hold DB names that do NOT have a backup.
IF object_id('tempdb..#tblNoBackups', 'U') IS NOT NULL 
BEGIN
	TRUNCATE TABLE #tblNoBackups
END
ELSE
BEGIN
	CREATE TABLE #tblNoBackups (
		id INT NOT NULL IDENTITY (1, 1),	
		name VARCHAR(256)
		)
END

--Used to store database names for backups older that 48-hours
IF object_id('tempdb..#tblNoBkups48H', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #tblNoBkups48H
END
ELSE
BEGIN
	CREATE TABLE #tblNoBkups48H (
		id INT NOT NULL IDENTITY (1, 1),
		email_text NVARCHAR(256)
	)
END

--Used to store database names for backups older than
--what is specified within MON_SQL_CFG_BackupReports
IF object_id('tempdb..#tblNoBkupsCustom', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #tblNoBkupsCustom
END
ELSE
BEGIN
	CREATE TABLE #tblNoBkupsCustom (
		id INT NOT NULL IDENTITY (1, 1),
		email_text NVARCHAR(256)
	)
END

--All DBs with a backup_finish_date reference.
INSERT INTO #tblBackupHistory 
	SELECT 
		a.database_name, 
		a.backup_start_date, 
		a.backup_finish_date,
		DATEDIFF(ss, a.backup_start_date, a.backup_finish_date) AS backup_duration, 
		a.backup_size
	FROM msdb.dbo.backupset a
	RIGHT JOIN master.dbo.sysdatabases c ON
		a.database_name = c.name,
		(
		SELECT 
			database_name, 
			MAX(backup_finish_date) AS backup_finish_date
		FROM msdb.dbo.backupset
		WHERE 
			( type = 'D' or type = 'I' ) AND
			database_name NOT IN('tempdb')
		GROUP BY database_name
		) b
	WHERE 
		a.database_name = b.database_name
		AND 
		a.backup_finish_date= b.backup_finish_date;


--Check for any databases that have never had a backup.		
INSERT INTO #tblNoBackups
SELECT DISTINCT
    a.name
  FROM
    master.dbo.sysdatabases a LEFT JOIN 
    msdb.dbo.backupset b ON
    a.name = b.database_name
  WHERE b.database_name IS NULL AND
    a.name NOT IN('tempdb') AND
	a.name COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN 
		(SELECT database_name COLLATE SQL_Latin1_General_CP1_CI_AS 
		FROM SYSAdmin.dbo.MON_SQL_CFG_BackupReports
		WHERE hours_between_backups = 0)
  ORDER BY a.name

IF (SELECT COUNT(name) FROM #tblNoBackups) > 0
BEGIN
    Set @email_body = @email_body + '  -------------------------------------------------------------------------------'
    Set @email_body = @email_body + CHAR(13)+CHAR(10)
    Set @email_body = @email_body + '  The following Databases are not being backed up on server: ' + @SERVER_NAME
    Set @email_body = @email_body + CHAR(13)+CHAR(10)
    Set @email_body = @email_body + '  -------------------------------------------------------------------------------'
    Set @email_body = @email_body + CHAR(13)+CHAR(10)

	--Begin Loop to retrieve database names from #tblNoBackups and insert into the variable @email_body
	SET @x = (select count(name) from #tblNoBackups)
	set @z = 1
	WHILE @z <= @x
	BEGIN
		SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT SUBSTRING(name,1,50) FROM #tblNoBackups where id = @z)))
		SET @email_body = @email_body + CHAR(13)+CHAR(10)
		SET @z = @z + 1
	END
	--End Loop
END

--Check for any databases that have backups older than 48-hours.
IF (
	SELECT 
		COUNT(database_name)
	FROM #tblBackupHistory
	WHERE
		database_name COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN 
			(
				SELECT 
					database_name COLLATE SQL_Latin1_General_CP1_CI_AS 
				FROM SYSAdmin.dbo.MON_SQL_CFG_BackupReports)
		AND
		backup_finish_date < DATEADD(hh, -48, GETDATE())
	) > 0

BEGIN
    Set @email_body = @email_body + '  -------------------------------------------------------------------------------'
    Set @email_body = @email_body + CHAR(13)+CHAR(10)
    Set @email_body = @email_body + '  The following databases have not been backed up for 48 hrs on server: ' + @SERVER_NAME
    Set @email_body = @email_body + CHAR(13)+CHAR(10)
    Set @email_body = @email_body + '  -------------------------------------------------------------------------------'
    Set @email_body = @email_body + CHAR(13)+CHAR(10)

	INSERT INTO #tblNoBkups48H (email_text)
	SELECT 
		SUBSTRING(database_name,1,30) +
		SUBSTRING('                              ',LEN(database_name),30) +
		CAST(backup_start_date AS CHAR(19)) + '     ' + 
		CAST(backup_finish_date AS CHAR(19))
	FROM #tblBackupHistory
	WHERE
		database_name COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN 
			(
				SELECT 
					database_name COLLATE SQL_Latin1_General_CP1_CI_AS 
				FROM SYSAdmin.dbo.MON_SQL_CFG_BackupReports)
		AND		
		backup_finish_date < DATEADD(hh, -48, GETDATE())
	ORDER BY database_name
			
	--Begin Loop to retrieve database names from #tblNoBkups48H and insert into the variable @email_body
	set @x = (select COUNT (email_text) from #tblNoBkups48H)
	set @z = 1
	WHILE @z <= @x
	BEGIN
	   SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT email_text FROM #tblNoBkups48H where id = @z)))
	   SET @email_body = @email_body + CHAR(13)+CHAR(10)
	   SET @z = @z + 1
	END
	--End Loop
END

--Check for any databases that have backups older than the time specified within SYSAdmin.dbo.MON_SQL_CFG_BackupReports
IF (
	SELECT 
		COUNT(a.database_name)
	FROM #tblBackupHistory a
	INNER JOIN SYSAdmin.dbo.MON_SQL_CFG_BackupReports b
	ON	
		a.database_name COLLATE SQL_Latin1_General_CP1_CI_AS = 
		b.database_name	COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE
		b.hours_between_backups != 0 AND
		a.backup_finish_date < DATEADD(hh, 
			(CASE WHEN b.hours_between_backups > 0 
			THEN b.hours_between_backups * -1 
			ELSE b.hours_between_backups 
			END)
			,GETDATE())
) > 0
BEGIN
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  The following databases have exceeded the time limit between backups'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
	SET @email_body = @email_body + '  on the server: ' + @SERVER_NAME
	SET @email_body = @email_body + CHAR(13)+CHAR(10)
	SET @email_body = @email_body + '  Database Name                        LastBackup  HoursBetweenBackups'
	SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  ------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)

	INSERT INTO #tblNoBkupsCustom (email_text)
	SELECT 
		SUBSTRING(a.database_name,1,30) +
		SUBSTRING('                              ',LEN(a.database_name),30) +
		CAST(a.backup_finish_date AS CHAR(19)) + '     ' + 
		CAST(b.hours_between_backups AS VARCHAR(3))
	FROM #tblBackupHistory a
	INNER JOIN SYSAdmin.dbo.MON_SQL_CFG_BackupReports b
	ON	
		a.database_name COLLATE SQL_Latin1_General_CP1_CI_AS = 
		b.database_name	COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE
		b.hours_between_backups != 0 AND	
		a.backup_finish_date < DATEADD(hh, 
			(CASE WHEN b.hours_between_backups > 0 
			THEN b.hours_between_backups * -1 
			ELSE b.hours_between_backups 
			END)
			,GETDATE())
	ORDER BY a.database_name			

	--Begin Loop to retrieve database names from #tblNoBkupsCustom and insert into the variable @email_body
	set @x = (select COUNT (email_text) from #tblNoBkupsCustom)
	set @z = 1
	WHILE @z <= @x
	BEGIN
	   SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT email_text FROM #tblNoBkupsCustom where id = @z)))
	   SET @email_body = @email_body + CHAR(13)+CHAR(10)
	   SET @z = @z + 1
	END
	--End Loop
END


IF	(
	(SELECT COUNT(name) FROM #tblNoBackups) > 0 OR 
	(SELECT COUNT(email_text) FROM #tblNoBkups48H) > 0 OR
	(SELECT COUNT(email_text) FROM #tblNoBkupsCustom) > 0 
	)
BEGIN

	EXEC msdb.dbo.sp_send_dbmail
		@profile_name = @mail_profile_name,
		@recipients = @mail_recipients,
		@copy_recipients = @mail_copy_recipients,
		@blind_copy_recipients = @mail_blind_copy_recipients,
		@subject = @subject2,
		@body = @email_body	

--------------------------------------------------------------------------------
--Log DB Problem to Windows Application Event Log
--------------------------------------------------------------------------------

		--Truncating the servername down to varchar(45) because of space issues within the Eventlog.
		SET @SERVER_NAME = CAST(@SERVER_NAME AS VARCHAR(45))
		SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))

		SET @event_message = '; ' + @SERVER_NAME + '; BACKUP WARNING; ' + (CONVERT(VARCHAR(20),getdate(),120))  + '; (Database Backup Warning)'

		--Generates Windows App Event log message & SQL Log Error
		EXEC master.dbo.xp_logevent 77021, @event_message, WARNING
		
		/* --Generates Windows App Event log message & SQL Log Error & Returns the error to the client.
		RAISERROR (
			@event_message, -- Message text.
			0, -- Severity 0 to 18,
			1   -- State
		) 
		WITH LOG
		*/

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

END

DROP TABLE #tblBackupHistory
DROP TABLE #tblNoBackups
DROP TABLE #tblNoBkups48H
DROP TABLE #tblNoBkupsCustom
GO
/****** Object:  StoredProcedure [dbo].[usp_Database_Backups]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_Database_Backups] AS
-- This proc checks for databases that are not being backed-up,
-- databases that haven't been backed-up for more than 24 hours
-- 
-- The procedure don't receive any parameter
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC SYSAdmin..[usp_Database_Backups]
----------------------------------------------------------------
--06/15/2012 v2012 - SMurua - Initial creation
----------------------------------------------------------------

SET NOCOUNT ON
DECLARE
	@instance_name varchar(100),
    @current_date char(20)

SET @current_date = (SELECT CONVERT( varchar(20), GETDATE(), 120)  )

-- Get the host name
SELECT @instance_name = @@SERVERNAME

--Used to hold DB info that have been backed up.
IF object_id('tempdb..#tblBackupHistory', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #tblBackupHistory
END
ELSE
BEGIN
	CREATE TABLE #tblBackupHistory (
		database_name		NVARCHAR(256) NULL,
		backup_start_date	DATETIME,
		backup_finish_date	DATETIME,
		backup_duration		INT,
		backup_size			NUMERIC(20,0)
	)			
END

--Used to hold DB names that do NOT have a backup.
IF object_id('tempdb..#tblNoBackups', 'U') IS NOT NULL 
BEGIN
	TRUNCATE TABLE #tblNoBackups
END
ELSE
BEGIN
	CREATE TABLE #tblNoBackups (
		id INT NOT NULL IDENTITY (1, 1),	
		name VARCHAR(256)
		)
END

--Used to store database names for backups older that 24-hours
IF object_id('tempdb..#tblNoBkups24H', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #tblNoBkups24H
END
ELSE
BEGIN
	CREATE TABLE #tblNoBkups24H (
		id INT NOT NULL IDENTITY (1, 1),
		email_text NVARCHAR(256)
	)
END


--All DBs with a backup_finish_date reference.
INSERT INTO #tblBackupHistory 
	SELECT 
		a.database_name, 
		a.backup_start_date, 
		a.backup_finish_date,
		DATEDIFF(ss, a.backup_start_date, a.backup_finish_date) AS backup_duration, 
		a.backup_size
	FROM msdb.dbo.backupset a
	RIGHT JOIN master.dbo.sysdatabases c ON
		a.database_name = c.name,
		(
		SELECT 
			database_name, 
			MAX(backup_finish_date) AS backup_finish_date
		FROM msdb.dbo.backupset
		WHERE 
			( type = 'D' or type = 'I' ) AND
			database_name NOT IN('tempdb')
		GROUP BY database_name
		) b
	WHERE 
		a.database_name = b.database_name
		AND 
		a.backup_finish_date= b.backup_finish_date
		AND a.database_name NOT IN (SELECT DB_NAME(database_id)
					FROM sys.database_mirroring
					WHERE mirroring_role_desc='MIRROR');


DELETE FROM #tblBackupHistory
WHERE EXISTS(select min(tbh2.backup_size), tbh2.database_name
			from #tblBackupHistory tbh2
			group by tbh2.database_name
			having tbh2.database_name in (select tbh.database_name 
									from #tblBackupHistory tbh
									group by tbh.database_name
									having count(*) > 1)
			and #tblBackupHistory.backup_size = min(tbh2.backup_size)
			and #tblBackupHistory.database_name = tbh2.database_name)
			
			
--Check for any databases that have never had a backup.		
INSERT INTO #tblNoBackups
SELECT DISTINCT
    a.name
  FROM
    master.dbo.sysdatabases a LEFT JOIN 
    msdb.dbo.backupset b ON
    a.name = b.database_name
  WHERE b.database_name IS NULL AND
    a.name NOT IN('tempdb') 
    AND a.name COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN 
		(SELECT database_name COLLATE SQL_Latin1_General_CP1_CI_AS 
		FROM SYSAdmin.dbo.MON_SQL_CFG_BackupReports
		WHERE hours_between_backups = 0)
	AND a.name NOT IN (SELECT DB_NAME(database_id)
					FROM sys.database_mirroring
					WHERE mirroring_role_desc='MIRROR')
  ORDER BY a.name


INSERT INTO MON_SQL_CFG_Database_Backups
SELECT @instance_name as instance_name,
	'[' + database_name + ']',
	backup_start_date,
	backup_finish_date,
	'OK' as comments,
	GETDATE() as updated_date
FROM #tblBackupHistory
WHERE database_name not in (SELECT SUBSTRING(name,1,50) FROM #tblNoBackups)
and database_name not in (SELECT TBH.database_name FROM #tblBackupHistory TBH WHERE TBH.backup_finish_date < DATEADD(hh, -24, GETDATE()))

UNION

SELECT @instance_name as instance_name,
	'[' + name + ']',
	NULL as backup_start_date,
	NULL as backup_finish_date,
	'NEVER BACKED UP' as comments,
	GETDATE() as updated_date
FROM #tblNoBackups

UNION

SELECT @instance_name as instance_name,
	'[' + database_name + ']',
	backup_start_date,
	backup_finish_date,
	'NO BACKUP LAST 24 HOURS' as comments,
	GETDATE() as updated_date
FROM #tblBackupHistory
WHERE backup_finish_date < DATEADD(hh, -24, GETDATE())
AND database_name COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN 
		(SELECT database_name COLLATE SQL_Latin1_General_CP1_CI_AS 
		FROM SYSAdmin.dbo.MON_SQL_CFG_BackupReports
		WHERE hours_between_backups = 0)

  


DROP TABLE #tblBackupHistory
DROP TABLE #tblNoBackups
DROP TABLE #tblNoBkups24H

GO
/****** Object:  StoredProcedure [dbo].[usp_dbgrowthrate]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE procedure [dbo].[usp_dbgrowthrate] as
-------SQL 2012 EDITION  v06_2012---------------------
----------------------------------------------------------------
-- Description:  This SQL Code captures current db sizes and uses 
-- the last record in DBGrowthRate table to calculate growth rate.
-- No email is sent nor event log created from this SP
--
-- Execute the following command to view all settings for this script:
-- SELECT variable1 FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_dbgrowthrate'
--
-- variable1 = Minimum number of hours between exections of this script (DEFAULT = 24)
----------------------------------------------------------------
DECLARE 
	@bytesperpage DEC(15,0),
	@pagesperMB  DEC(15,0),
	@dbname VARCHAR(100),
	@strsql NVARCHAR(4000),
	@restrictExecution INT,
	@SQLCMD NVARCHAR(2000),
	@restrictExecution_temp VARCHAR(100);

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_dbgrowthrate') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG 
			(proc_name, variable1)
			VALUES ('usp_dbgrowthrate', 24)
	END

	SELECT  
		@restrictExecution = CONVERT(INT, variable1)
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_dbgrowthrate';

IF (ISNUMERIC(@restrictExecution) = 0) SET @restrictExecution = 24

IF object_id('tempdb..#TempDBSize2', 'U') is not null 
	BEGIN
		DROP TABLE #TempDBSize2
	END

CREATE TABLE #TempDBSize2 (
		DBName varchar(100), 
		FileName varchar(100),
		dbid int,
		fileid int, 
		size bigint, 
		reserved bigint)


select @bytesperpage = low  
	from master.dbo.spt_values  
where number = 1  and type = 'E'  

select @pagesperMB = 1048576 / @bytesperpage  

INSERT INTO #TempDBSize2 (DBName, FileName, dbid, fileid, size, reserved)
Select '[' + sd.name + ']'  as DBName, mf.name as FileName, mf.dbid, fileid, size, 0 as reserved
from master.dbo.sysdatabases sd
join master.dbo.sysaltfiles mf 
	on sd.dbid = mf.dbid
WHERE 
	DATABASEPROPERTYEX(sd.name, 'STATUS') = 'ONLINE'
Order by mf.dbid, sd.name


DECLARE dbcur CURSOR LOCAL FAST_FORWARD FOR
	SELECT DBName from #TempDBSize2
ORDER by DBName
OPEN dbcur
FETCH NEXT FROM dbcur INTO @dbname
WHILE @@FETCH_STATUS=0
BEGIN
SET @strsql = 'UPDATE #TempDBSize2
			   SET reserved = (Select sum(convert(dec(15),reserved))
								from ' + @dbname + '.dbo.sysindexes
								where indid in (0, 1, 255))
			   WHERE DBName = ''' + @dbname + ''' and fileid=1'
EXEC sp_executesql @strsql
FETCH NEXT FROM dbcur INTO @dbname
END
CLOSE dbcur
DEALLOCATE dbcur

	--Updating existing DB info with new data.
	--Restrict the amount of time between executions.  Default is no more than once every 24-hours
	IF (
	SELECT DISTINCT MAX(MetricDate) AS MetricDate 
	FROM DBGrowthRate
	WHERE 
		GETDATE() > DATEADD(hh,@restrictExecution,(SELECT DISTINCT MAX(MetricDate) AS MetricDate FROM DBGrowthRate))
	) IS NOT NULL
	BEGIN
		INSERT INTO DBGrowthRate (DBName, DBID, NumPages, OrigSize, CurSize, Unused, GrowthAmt, MetricDate)
			(Select tds.DBName, tds.dbid, SUM(tds.size) AS NumPages, 
			dgr.CurSize AS OrigSize,
			CONVERT(DECIMAL(15,2),SUM(tds.size) / (@pagesperMB )) AS CurSize,
			CONVERT(DECIMAL(15,2),(Select SUM(tds1.size)-SUM(tds1.reserved) 
				FROM #TempDBSize2 tds1 
				WHERE tds1.dbid=tds.dbid and tds1.fileid=1) / @pagesperMB) AS Unused,
			CONVERT(VARCHAR(100),(CONVERT(DECIMAL(15,2),SUM(tds.size) / @pagesperMB)
						- dgr.CurSize)) + ' MB' AS GrowthAmt,GETDATE() AS MetricDate
			FROM #TempDBSize2 tds
			join DBGrowthRate dgr
			ON tds.dbid = dgr.DBID
			WHERE DBGrowthID = (SELECT DISTINCT MAX(DBGrowthID) FROM DBGrowthRate WHERE DBID = dgr.DBID)
			GROUP BY tds.dbid, tds.DBName, dgr.CurSize)
	END

	--Adding new DBs to the DBGrowthRate DB
	INSERT INTO dbo.DBGrowthRate (DBName, DBID, NumPages, OrigSize, CurSize, Unused, GrowthAmt, MetricDate)
		(SELECT tds.DBName, tds.dbid, SUM(tds.size) AS NumPages, 
		CONVERT(DECIMAL(15,2),SUM(CONVERT(DECIMAL(15,2),tds.size)) / @pagesperMB) AS OrigSize,
		CONVERT(DECIMAL(15,2),SUM(CONVERT(DECIMAL(15,2),tds.size)) / @pagesperMB) AS CurSize,
		CONVERT(DECIMAL(15,2),(Select Sum(tds1.size)-SUM(tds1.reserved) 
			FROM #TempDBSize2 tds1 
			WHERE 
				tds1.dbid=tds.dbid AND tds1.fileid=1) / @pagesperMB) AS Unused,
				'0.00 MB' AS GrowthAmt, GETDATE() AS MetricDate
		FROM #TempDBSize2 tds
		WHERE tds.dbid NOT IN 
			(SELECT DISTINCT DBID FROM DBGrowthRate WHERE DBID = tds.dbid)
		GROUP BY tds.dbid, tds.DBName)

DROP TABLE #TempDBSize2
GO
/****** Object:  StoredProcedure [dbo].[usp_dbm_kill_users]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROC [dbo].[usp_dbm_kill_users] @dbname sysname, @delay DATETIME = '00:00' AS
-------SQL 2012 EDITION  v06_2012---------------------
----------------------------------------------------------------
-- This procedure executes KILL for all connections 
-- in the specified database.
-- The procedure takes the following parameters:
--  @dbname SYSNAME (required): Database name
--  @delay DATETIME (optional) [0] : Optional delay (s) before resume
--
-- Tested on version 6.5, 7.0, 8.0, and 9.0.      
-- Sample Execution:
-- EXEC SYSAdmin..usp_dbm_kill_users pubs
-- EXEC SYSAdmin..usp_dbm_kill_users @dbname = pubs, @delay = '00:00:05'
----------------------------------------------------------------


SET NOCOUNT ON

DECLARE loop_name INSENSITIVE CURSOR FOR
  SELECT spid
   FROM master..sysprocesses
   WHERE dbid = DB_ID(@dbname)

OPEN loop_name
DECLARE @conn_id SMALLINT
DECLARE @exec_str VARCHAR(255)
FETCH NEXT FROM loop_name INTO @conn_id
WHILE (@@fetch_status = 0)
  BEGIN
    SELECT @exec_str = 'KILL ' + CONVERT(VARCHAR(7), @conn_id)
    EXEC( @exec_str )
    FETCH NEXT FROM loop_name INTO @conn_id
  END
DEALLOCATE loop_name

WAITFOR DELAY @delay
GO
/****** Object:  StoredProcedure [dbo].[usp_delete_backuphistory]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_delete_backuphistory]  AS
-------SQL 2012 EDITION  v06_2012----------------------------
----------------------------------------------------------------
----- Description:  This SQL Code runs MSDB clean up tasks of
----- sp_delete_backuphistory, sp_purge_jobhistory, and 
----- sp_maintplan_delete_log.
----- 
----- The Script also archives and/or purges all emails sent by 
----- the DBMail system and jobhistory/blocking history stored
----- within SYSAdmin.
----- No email is sent nor event log created from this SP.
----- 
-----
----- Execute the following command to view all settings for this script:
----- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_delete_backuphistory'
-----
----- variable1 = 1 to archive & delete old emails OR 0 to delete without archiving (DEFAULT 1)
----- variable2 = Days of email logs to keep before archiving (DEFAULT -40)
----- variable3 = Purge jobhistory, backuphistory, and maintplan log 
-----	older than number of days (DEFAULT -40)
----- variable4 = Number of records, per job, to maintain within 
-----	SYSAdmin.dbo.MON_SQL_JobHistory (DEFAULT 50)
----- variable5 = Number of months to retain of blocking history within 
-----	SYSAdmin.dbo.EventInfoMain_His (default (-6)
----------------------------------------------------------------

DECLARE
	@old_date  as DATETIME,
	@ArchiveOldEmails as BIT,	
	@EmailsToKeepOnSystem as INT,
	@BackupHistoryToKeep INT,
	@JobHistoryToKeep VARCHAR(100),
	@BlockingHistoryToKeep INT,
			
	@prtmessage as DATETIME,
	@TableName as NVARCHAR(16),
	@CopyDate as NVARCHAR(20),
	@CountRecords as INT,
	@ErrorOccured as BIT,
	
	@SQLCMD NVARCHAR(2000);

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_delete_backuphistory') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG 
			(proc_name, variable1, variable2, variable3, variable4, variable5)
			VALUES ('usp_delete_backuphistory', 1, -40, -40, 50, -6)	
	END
	
	SELECT  
		@ArchiveOldEmails		= CONVERT(BIT, variable1), 
		@EmailsToKeepOnSystem	= CONVERT(INT, variable2), 
		@BackupHistoryToKeep	= CONVERT(INT, variable3),
		@JobHistoryToKeep		= variable4,
		@BlockingHistoryToKeep	= CONVERT(INT, variable5)
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_delete_backuphistory';

SET @ErrorOccured = 0

IF (ISNUMERIC(@ArchiveOldEmails) = 0) SET @ArchiveOldEmails = 1
IF (ISNUMERIC(@EmailsToKeepOnSystem) = 0) SET @EmailsToKeepOnSystem = -40
IF (ISNUMERIC(@BackupHistoryToKeep) = 0) SET @BackupHistoryToKeep = -40
IF (ISNUMERIC(@JobHistoryToKeep) = 0) SET @JobHistoryToKeep = 50
IF (ISNUMERIC(@BlockingHistoryToKeep) = 0) SET @BlockingHistoryToKeep = -6

--Execute all SP to replace the History CleanUp Maintenance Task.
SET @old_date = DATEADD (DAY,@BackupHistoryToKeep,GETDATE())
EXEC msdb.dbo.sp_delete_backuphistory @old_date
EXEC msdb.dbo.sp_purge_jobhistory  @oldest_date=@old_date
EXEC msdb.dbo.sp_maintplan_delete_log null,null,@old_date

--Purge Long Running Job History
IF object_id('SYSAdmin.dbo.MON_SQL_JobHistory', 'U') IS NOT NULL
BEGIN
	SET @SQLCMD =	
		N'DELETE FROM SYSAdmin.dbo.MON_SQL_JobHistory
		WHERE history_id NOT IN
		(
		SELECT a.history_id
		FROM SYSAdmin.dbo.MON_SQL_JobHistory a
		WHERE instance_id IN 
			( 
				SELECT TOP ' + @JobHistoryToKeep + ' b.instance_id 
				FROM SYSAdmin.dbo.MON_SQL_JobHistory b 
				WHERE b.job_id = a.job_id 
				ORDER BY b.instance_id DESC
			)
		);'

	EXEC sp_executesql @SQLCMD
END

--Purge System Lock Alert Blocking history
IF object_id('SYSAdmin.dbo.EventInfoMain_His', 'U') IS NOT NULL
BEGIN
	SELECT @old_date = DATEADD (MONTH,@BlockingHistoryToKeep,GETDATE())

	DELETE FROM SYSAdmin.dbo.EventInfoMain_His
	WHERE dtStampFound < @old_date
END

--Set the tablename for use through-out the script
SET @TableName = (SELECT LTRIM(RTRIM(CONVERT(VARCHAR(30), GETDATE(), 12))) + '_' +
					LTRIM(RTRIM(CAST(DATEPART(HH,GETDATE()) AS CHAR(2)))) +
					LTRIM(RTRIM(CAST(DATEPART(MI,GETDATE()) AS CHAR(2)))) +
					LTRIM(RTRIM(CAST(DATEPART(SS,GETDATE()) AS CHAR(2)))) +
					LTRIM(RTRIM(CAST(DATEPART(MS,GETDATE()) AS CHAR(3))))
				)
SET @CopyDate = DATEADD (DAY,@EmailsToKeepOnSystem,GETDATE())

BEGIN TRY
--Checking to see if there are any records in sysmail_allitems to archive.
SET @SQLCMD =	N'SELECT @iCount= COUNT(*) ' + 
				'FROM msdb.dbo.sysmail_allitems ' +
				'WHERE msdb.dbo.sysmail_allitems.send_request_date < @iCpyDate ;'
EXEC sp_executesql @SQLCMD, N'@iCount INT OUT, @iCpyDate DATETIME', @CountRecords out, @CopyDate

IF (@CountRecords > 0) AND (@ArchiveOldEmails = 1)
  BEGIN
	--Archiving msdb.dbo.sysmail_allitems
	SET @SQLCMD = N'SELECT * INTO SYSAdmin.dbo.[DBMailArchive_' + @TableName + '] ' +
					'FROM msdb.dbo.sysmail_allitems ' +
					'WHERE msdb.dbo.sysmail_allitems.send_request_date < ''' + @CopyDate +'''';
	EXEC sp_executesql @SQLCMD ;
	--SELECT @CountRecords as 'sysmail_allitems'
	
		--Check if a DBMailArchive Table was created
		IF NOT object_id('SYSAdmin.dbo.[DBMailArchive_' + @TableName +']', 'U') IS NULL
			BEGIN
			  --Query if any of the archived emails had Attachments associated
			  SET @SQLCMD = N'SELECT @iCount= COUNT(*) ' +
							'FROM msdb.dbo.sysmail_attachments ' +
							'WHERE mailitem_id IN ' +
								'(SELECT DISTINCT mailitem_id ' +
								'FROM SYSAdmin.dbo.[DBMailArchive_' + @TableName + ']);'
			  EXEC sp_executesql @SQLCMD, N'@iCount INT OUT', @CountRecords out
			  --SELECT @CountRecords as 'sysmail_attachments'

			  --If Attachments are associated to any archived emails, they are archived now
				IF @CountRecords > 0
				  BEGIN
					--Archiving msdb.dbo.sysmail_attachments
					SET @SQLCMD = N'SELECT * INTO SYSAdmin.dbo.[DBMailArchive_Attachments_' + @TableName + '] ' +
					'FROM msdb.dbo.sysmail_attachments ' +
					'WHERE mailitem_id IN ' +
					'(SELECT DISTINCT mailitem_id FROM SYSAdmin.dbo.[DBMailArchive_' + @TableName + '] )';
					EXEC sp_executesql @SQLCMD ;

				  END
			  --Query if any of the archived emails have Logs associated to them.
			  SET @SQLCMD = 'SELECT @iCount= COUNT(*) ' +
							'FROM msdb.dbo.sysmail_log ' +
							'WHERE mailitem_id IN ' +
								'(SELECT DISTINCT mailitem_id ' +
								'FROM SYSAdmin.dbo.[DBMailArchive_' + @TableName + ']);'
			  EXEC sp_executesql @SQLCMD, N'@iCount INT OUT', @CountRecords out
			  --select @CountRecords as 'sysmail_log'

			  --If Logs are associated to any archived emails, they are archived now
				IF @CountRecords > 0
				  BEGIN
					--Archiving msdb.dbo.sysmail_log
					SET @SQLCMD = N'SELECT * INTO SYSAdmin.dbo.[DBMailArchive_Log_' + @TableName + '] ' +
					'FROM msdb.dbo.sysmail_log ' +
					'WHERE mailitem_id IN ' +
					'(SELECT DISTINCT mailitem_id FROM SYSAdmin.dbo.[DBMailArchive_' + @TableName + '] )';
					EXEC sp_executesql @SQLCMD ;
				  END
			END
  END
END TRY
BEGIN CATCH
	DECLARE @ErrorMessage NVARCHAR(4000);
    DECLARE @ErrorSeverity INT;
    DECLARE @ErrorState INT;

    SELECT 
        @ErrorMessage = ERROR_MESSAGE(),
        @ErrorSeverity = ERROR_SEVERITY(),
        @ErrorState = ERROR_STATE();

    -- If @ArchiveOldEmails = 1 and an error occurs, return the error.
	IF (@ArchiveOldEmails = 1)
	BEGIN
		RAISERROR (@ErrorMessage,
				   @ErrorSeverity,
				   @ErrorState
				   );
	END

	--If any error occurs during the archiving process, I set the variable
	--to keep the purge commands from executing.
	SET @ErrorOccured = 1
	
END CATCH

--Will only delete under 1 of 2 conditions.  Either @ArchiveOldEmails is set to 0
--Or, @ArchiveOldEmails is set to 1 and no error has occured.
IF (@ArchiveOldEmails = 0) OR ((@ArchiveOldEmails = 1) AND (@ErrorOccured = 0))
BEGIN
	--Purges sysmail_allitems & sysmail_attachments
	EXECUTE msdb.dbo.sysmail_delete_mailitems_sp @sent_before = @CopyDate ;
	--Purges sysmail_log
	EXECUTE msdb.dbo.sysmail_delete_log_sp @logged_before = @CopyDate ;
END

GO
/****** Object:  StoredProcedure [dbo].[usp_drivespace_report]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_drivespace_report] AS
-------SQL 2005-2008-2012 EDITION  v2012----------------------------
-- This proc monitors disk space for all local drives.
-- The report built can be emailed and/or logged to the eventlog.
-- 
-- Execute the following command to view all settings for this script:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_drivespace_report'
--
-- 	mail_profile_name = SQL DBMail profile name to be used by this script.
--	mail_recipients = Email Address to send messages TO
--
--	variable1 = MB Limit for Warning Alert (DEFAULT = 0)
--	variable2 = Percent Limit for Warning Alert (DEFAULT = 10)
--	variable3 = MB Limit for Critical Alert (DEFAULT = 0)
--	variable4 = Percent Limit for Critical Alert (DEFAULT = 5)
--	variable5 = Minutes between duplicate email alerts (DEFAULT = 59)

--	Use table dbo.MON_SQL_CFG_DriveSpace to set individual drive thresholds.
----------------------------------------------------------------

SET NOCOUNT ON

DECLARE @client varchar(100)
SELECT @client = isnull([variable2],'client_name_missing') FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc'

--Blackout Check
DECLARE @blackout as tinyint
SET @blackout = 0
IF EXISTS (	SELECT * FROM dbo.sysobjects 
			WHERE
			id = object_id(N'[dbo].[blackout]') AND 
			OBJECTPROPERTY(id, N'IsScalarFunction') = 1	)
BEGIN
	SET DATEFIRST 7
	SET @blackout = SYSAdmin.dbo.blackout(getdate())
END 

IF (@blackout = 0)
BEGIN

DECLARE 	
	@SERVER_NAME varchar(100),
	@subject2 VARCHAR (200),
	@email_body varchar(8000),
	@event_message varchar(255),
	@event_drive char(1),
	@event_percent smallint,
	@current_date char(20),
	@x int,
	@z int,
	@emailpercthreshold TINYINT,
	@pagepercthreshold TINYINT,
	@emailspacethreshold INT,
	@pagespacethreshold INT,
	@timebetweenemails INT,		
	@hr INT,
	@fso INT,
	@drive CHAR(1),
	@odrive INT,
	@TotalSize VARCHAR(20),
	@MB BIGINT,
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(MAX),
	@mail_copy_recipients VARCHAR(MAX),
	@mail_blind_copy_recipients VARCHAR(MAX);
	
	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_drivespace_report') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG 
			(proc_name, mail_profile_name,variable1,variable2,variable3,variable4,variable5)	
			VALUES ('usp_drivespace_report', 'SQL_DBMail',0,10,0,5,59)			
	END
		
	SELECT  
		@mail_profile_name = mail_profile_name,
		@mail_recipients = mail_recipients,
		@mail_copy_recipients = mail_copy_recipients,
		@mail_blind_copy_recipients = mail_blind_copy_recipients,
		@emailspacethreshold = CONVERT(TINYINT, variable1),
		@emailpercthreshold = CONVERT(INT, variable2),
		@pagespacethreshold = CONVERT(TINYINT, variable3),
		@pagepercthreshold = CONVERT(INT, variable4),
		@timebetweenemails = CONVERT(INT, variable5)
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_drivespace_report';
	
IF (ISNUMERIC(@emailspacethreshold) = 0) SET @emailspacethreshold = 0
IF (ISNUMERIC(@emailpercthreshold) = 0) SET @emailpercthreshold = 10
IF (ISNUMERIC(@pagespacethreshold) = 0) SET @pagespacethreshold = 0
IF (ISNUMERIC(@pagepercthreshold) = 0) SET @pagepercthreshold = 5
IF (ISNUMERIC(@timebetweenemails) = 0) SET @timebetweenemails = 59

--Create drivespace configuration table
IF object_id('SYSAdmin.dbo.MON_SQL_CFG_DriveSpace', 'U') is null 
BEGIN
	CREATE TABLE [dbo].[MON_SQL_CFG_DriveSpace]
		(
			[drive] [varchar](100) NOT NULL,
			[monitor] [bit] NOT NULL DEFAULT 1,
			[warningMBThreshold] [int] NULL,
			[warningPercThreshold] [TINYINT] NULL
				CONSTRAINT CK_warningPercThreshold
				CHECK ( ([warningPercThreshold] >= 0 ) AND ([warningPercThreshold] <= 100)),
			[criticalMBThreshold] [int] NULL,
			[criticalPercThreshold] [TINYINT] NULL
				CONSTRAINT CK_criticalPercThreshold 
				CHECK ( ([criticalPercThreshold] >= 0 ) AND ([criticalPercThreshold] <= 100))
		)
END

--Create drivespace configuration table
IF object_id('SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp', 'U') is null 
BEGIN
	CREATE TABLE [dbo].[MON_SQL_CFG_DriveSpace_Temp]
		(
			[drive] [varchar](100) NOT NULL,
			[warning] [bit] NULL,
			[warningDate] [datetime] NULL,
			[sendWarnEmail] [bit] NULL,
			[critical] [bit] NULL,
			[criticalDate] [datetime] NULL,
			[sendCritEmail] [bit] NULL
		)
END
	
SET @MB = 1048576

--Create DateTime for header
SET @current_date = (SELECT CONVERT( varchar(20), GETDATE(), 120)  )

-- Get the host name
SET @SERVER_NAME = @@servername
SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))
SET @subject2 = 'MON_SQL : ' + @client + ' : ' + @SERVER_NAME + ' Critical Drive Space Report'

--DROP Temp Tables if they existed before the Stored Procedure was run.
IF object_id('tempdb..#drives', 'U') is not null 
	DROP TABLE #drives

CREATE TABLE #drives (
	id int NOT NULL IDENTITY (1, 1),
	drive char(1) PRIMARY KEY,
	FreeSpace int NULL,
	TotalSize int NULL,
	PercentFree smallint NULL,
	FreespaceTimestamp DATETIME NULL,
	WarningFlag bit NULL,
	CriticalFlag bit NULL
)

--Used to store drive info for Warning Thresholds.
IF object_id('tempdb..#tblWarning', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #tblWarning
END
ELSE
BEGIN
	CREATE TABLE #tblWarning (
		id INT NOT NULL IDENTITY (1, 1),
		email_text NVARCHAR(256)
	)
END

--Used to store drive info for Warning Thresholds.
IF object_id('tempdb..#tblCritical', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #tblCritical
END
ELSE
BEGIN
	CREATE TABLE #tblCritical (
		id INT NOT NULL IDENTITY (1, 1),
		email_text NVARCHAR(256)
	)
END

--Used to output all messages to the Windows Event Log
IF object_id('tempdb..#temp_EventLog', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #temp_EventLog
END
ELSE
BEGIN
	CREATE TABLE #temp_EventLog (
		DriveLetter char(1),
		PercentFree smallint
	)
END

-- Generate report heading and column headers
	Set @email_body = 'Job ' + CHAR(39) + 'Critical Drive Space Report' + CHAR(39) + ' : v2009.12.31'
	Set @email_body = @email_body + CHAR(13) + CHAR(10)+ '  ' + CHAR(13) + CHAR(10)
	Set @email_body = @email_body + 'Critical Drive Space Report  -  Began Executing ' + @current_date + CHAR(13)+CHAR(10)
	Set @email_body = @email_body + '--------------------------------------------------------------------------'
	Set @email_body = @email_body + CHAR(13)+CHAR(10)

	Set @email_body = @email_body + 'Drive(s) warning/critical on host ' + @SERVER_NAME
	Set @email_body = @email_body + CHAR(13)+CHAR(10)
	Set @email_body = @email_body + ' '

INSERT #drives(drive,FreeSpace)
	EXEC master.dbo.xp_fixeddrives

--BLOCK this script from monitoring a specific drive.
DELETE FROM #drives where drive COLLATE SQL_Latin1_General_CP1_CI_AS
IN (
	SELECT drive COLLATE SQL_Latin1_General_CP1_CI_AS 
	FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace
	WHERE monitor = 0
	)
	
-- This is a VB method
EXEC @hr=sp_OACreate 'Scripting.FileSystemObject',@fso OUT
	IF @hr <> 0 EXEC sp_OAGetErrorInfo @fso

DECLARE dcur CURSOR LOCAL FAST_FORWARD FOR
	SELECT drive from #drives
	ORDER by drive
OPEN dcur
FETCH NEXT FROM dcur INTO @drive
WHILE @@FETCH_STATUS=0
BEGIN
	EXEC @hr = sp_OAMethod @fso,'GetDrive', @odrive OUT, @drive
		IF @hr <> 0 EXEC sp_OAGetErrorInfo @fso

	EXEC @hr = sp_OAGetProperty @odrive,'TotalSize', @TotalSize OUT
		IF @hr <> 0 EXEC sp_OAGetErrorInfo @odrive

	UPDATE #drives
	SET 
		TotalSize=@TotalSize/@MB, 
		FreespaceTimestamp = (GETDATE()),
		PercentFree = CAST((FreeSpace/(@TotalSize/@MB*1.0))*100.0 as int)
	WHERE 
		drive=@drive

FETCH NEXT FROM dcur INTO @drive
END
CLOSE dcur
DEALLOCATE dcur

EXEC @hr=sp_OADestroy @fso
	IF @hr <> 0 EXEC sp_OAGetErrorInfo @fso

--Update warning flag of #drives based on custom threshold settings
UPDATE #drives
SET #drives.WarningFlag = 1
FROM #drives
	INNER JOIN SYSAdmin.dbo.MON_SQL_CFG_DriveSpace B
	ON B.drive = #drives.drive COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE 
		#drives.FreeSpace < B.warningMBThreshold 
		OR
		#drives.PercentFree < B.warningPercThreshold

--Update critical flag of #drives based on custom threshold settings
UPDATE #drives
SET #drives.CriticalFlag = 1
FROM #drives
	INNER JOIN SYSAdmin.dbo.MON_SQL_CFG_DriveSpace B
	ON B.drive = #drives.drive COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE 
		#drives.FreeSpace < B.criticalMBThreshold 
		OR
		#drives.PercentFree < B.criticalPercThreshold

--Update warning flag of #drives based on DEFAULT threshold settings
UPDATE #drives
SET #drives.WarningFlag = 1
WHERE drive COLLATE SQL_Latin1_General_CP1_CI_AS
NOT IN (
	SELECT drive COLLATE SQL_Latin1_General_CP1_CI_AS 
	FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace
	)
AND
(#drives.PercentFree < @emailpercthreshold OR #drives.FreeSpace < @emailspacethreshold)

--Update critical flag of #drives based on DEFAULT threshold settings
UPDATE #drives
SET #drives.CriticalFlag = 1
WHERE drive COLLATE SQL_Latin1_General_CP1_CI_AS
NOT IN (
	SELECT drive COLLATE SQL_Latin1_General_CP1_CI_AS 
	FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace
	)
AND
(#drives.PercentFree < @pagepercthreshold OR #drives.FreeSpace < @pagespacethreshold)

--Insert new warning records into MON_SQL_CFG_DriveSpace_Temp to track last reported 
--time stamp and only alert hourly.
INSERT INTO SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp (drive, warning) 
	SELECT drive, 1 AS warning FROM #drives
	WHERE WarningFlag = 1 
	AND drive NOT IN 
	(	SELECT drive COLLATE SQL_Latin1_General_CP1_CI_AS
		FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp
	)

--Insert new Critical records into MON_SQL_CFG_DriveSpace_Temp to track last reported 
--time stamp and only alert hourly.
INSERT INTO SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp (drive, critical) 
	SELECT drive, 1 AS critical FROM #drives
	WHERE CriticalFlag = 1 
	AND drive NOT IN 
	(	SELECT drive COLLATE SQL_Latin1_General_CP1_CI_AS
		FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp
	)

--Update Critical Flags of drives that are currently being alerted on.
--And determine if an email needs to be sent based on the datetime of
--the last email sent
UPDATE SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp
SET 
	critical = B.CriticalFlag,
	sendCritEmail =
      CASE 
         WHEN B.CriticalFlag = 1 AND criticalDate IS NULL THEN 1
         WHEN B.CriticalFlag = 1 AND GETDATE() > DATEADD(mi,@timebetweenemails,criticalDate) THEN 1
         ELSE 0
      END
FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp A 
INNER JOIN #drives B
	ON B.drive = A.drive COLLATE SQL_Latin1_General_CP1_CI_AS
	
--Update Warning Flags of drives that are currently being alerted on.
--And determine if an email needs to be sent based on the datetime of
--the last email sent
UPDATE SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp
SET 
	warning = B.WarningFlag,
	sendWarnEmail =
      CASE 
         WHEN B.CriticalFlag = 1 THEN 0
         WHEN B.WarningFlag = 1 AND warningDate IS NULL THEN 1
         WHEN B.WarningFlag = 1 AND GETDATE() > DATEADD(mi,@timebetweenemails,warningDate) THEN 1
         ELSE 0
      END
FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp A
INNER JOIN #drives B
	ON B.drive = A.drive COLLATE SQL_Latin1_General_CP1_CI_AS

--Delete all records from MON_SQL_CFG_DriveSpace_Temp that are 
--no longer flaging as warning or critical in #drives	
DELETE FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp
WHERE drive NOT IN 
(
	SELECT drive COLLATE SQL_Latin1_General_CP1_CI_AS 
	FROM #drives 
	WHERE WarningFlag IS NOT NULL OR CriticalFlag IS NOT NULL
)

-- Email if disk space sendWarnEmail or sendCritEmail have flagged.
IF (SELECT COUNT(drive) FROM 
	SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp
	WHERE (sendWarnEmail = 1) OR (sendCritEmail = 1)) > 0
BEGIN
	IF (SELECT COUNT(drive) 
		FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp
		WHERE 
			sendWarnEmail = 1 
			AND (critical = 0 OR critical IS NULL) ) > 0
	BEGIN
		SET @email_body = @email_body + CHAR(13)+CHAR(10)	
		SET @email_body = @email_body + 'WARNING Thresholds:'
		SET @email_body = @email_body + CHAR(13)+CHAR(10)
		SET @email_body = @email_body + '  Drive    Free Space    Percent Free    '
		SET @email_body = @email_body + CHAR(13)+CHAR(10)
		SET @email_body = @email_body + '  -------- ------------- --------------'
		SET @email_body = @email_body + CHAR(13)+CHAR(10)		

		INSERT INTO #tblWarning (email_text)
		SELECT A.drive + '        ' + CONVERT(VARCHAR,A.FreeSpace)	+ ' MB' + 
			SPACE(11-Len(CONVERT(VARCHAR,A.FreeSpace))) + CONVERT(VARCHAR,A.PercentFree)
		FROM #drives A
		INNER JOIN MON_SQL_CFG_DriveSpace_Temp B
			ON B.drive = A.drive COLLATE SQL_Latin1_General_CP1_CI_AS
		WHERE B.sendWarnEmail = 1 AND (B.critical = 0 OR B.critical IS NULL)

		UPDATE SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp
		SET warningDate = GETDATE()
		WHERE sendWarnEmail = 1 AND (critical = 0 OR critical IS NULL)
				
		--Begin Loop to retrieve drive info from #tblWarning and insert into the variable @email_body
		SET @x = (SELECT COUNT (email_text) FROM #tblWarning)
		SET @z = 1
		WHILE @z <= @x
		BEGIN
		   SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT email_text FROM #tblWarning WHERE id = @z)))
		   SET @email_body = @email_body + CHAR(13)+CHAR(10)
		   SET @z = @z + 1
		END
		--End Loop	
	END
	
	IF (SELECT COUNT(drive) 
		FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp
		WHERE sendCritEmail = 1) > 0
	BEGIN

		SET @email_body = @email_body + CHAR(13)+CHAR(10)
		SET @email_body = @email_body + 'CRITICAL Thresholds:'
		SET @email_body = @email_body + CHAR(13)+CHAR(10)
		SET @email_body = @email_body + '  Drive    Free Space    Percent Free    '
		SET @email_body = @email_body + CHAR(13)+CHAR(10)
		SET @email_body = @email_body + '  -------- ------------- --------------'
		SET @email_body = @email_body + CHAR(13)+CHAR(10)		

		INSERT INTO #tblCritical (email_text)
		SELECT A.drive + '        ' + CONVERT(VARCHAR,A.FreeSpace)	+ ' MB' + 
			SPACE(11-Len(CONVERT(VARCHAR,A.FreeSpace))) + CONVERT(VARCHAR,A.PercentFree)
		FROM #drives A
		INNER JOIN MON_SQL_CFG_DriveSpace_Temp B
			ON B.drive = A.drive COLLATE SQL_Latin1_General_CP1_CI_AS
		WHERE B.sendCritEmail = 1
		
		UPDATE SYSAdmin.dbo.MON_SQL_CFG_DriveSpace_Temp
		SET criticalDate = GETDATE()
		WHERE sendCritEmail = 1
				
		--Begin Loop to retrieve drive info from #tblCritical and insert into the variable @email_body
		SET @x = (SELECT COUNT (email_text) FROM #tblCritical)
		SET @z = 1
		WHILE @z <= @x
		BEGIN
		   SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT email_text FROM #tblCritical WHERE id = @z)))
		   SET @email_body = @email_body + CHAR(13)+CHAR(10)
		   SET @z = @z + 1
		END
		--End Loop		
	END	

	EXEC msdb.dbo.sp_send_dbmail
		@profile_name = @mail_profile_name,
		@recipients = @mail_recipients,
		@copy_recipients = @mail_copy_recipients,
		@blind_copy_recipients = @mail_blind_copy_recipients,
		@subject = @subject2,
		@body = @email_body
							
END

--------------------------------------------------------------------------------
--Log DB Problem to Windows Application Event Log
--------------------------------------------------------------------------------
	--Truncating the servername down to varchar(45) because of space issues within the Eventlog.
	SET @SERVER_NAME = CAST(@SERVER_NAME AS VARCHAR(45))
	SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))

	INSERT INTO #temp_EventLog (DriveLetter, PercentFree) 
	SELECT A.drive, A.PercentFree 
	FROM #drives A
	INNER JOIN MON_SQL_CFG_DriveSpace_Temp B
		ON B.drive = A.drive COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE B.sendCritEmail = 1

	IF (SELECT COUNT(DriveLetter) FROM #temp_EventLog) > 0
	BEGIN
		DECLARE cur1 CURSOR FAST_FORWARD FOR
			SELECT DriveLetter, PercentFree FROM #temp_EventLog(NOLOCK)
		OPEN cur1
		FETCH NEXT FROM cur1 INTO @event_drive, @event_percent
		WHILE (@@Fetch_status = 0)
		BEGIN

			SET @event_message = '; ' + @SERVER_NAME + '; DISK SPACE CRITICAL; ' + 
				(CONVERT(VARCHAR(20),getdate(),120))  + 
				'; (Drive ' + @event_drive + ' ' + CAST(@event_percent as varchar) + '% FREE)'
			
			--Generates Windows App Event log message & SQL Log Error
			EXEC master.dbo.xp_logevent 77022, @event_message, ERROR
			
			/* --Generates Windows App Event log message & SQL Log Error & Returns the error to the client.
			RAISERROR (
				@event_message, -- Message text.
				0, -- Severity 0 to 18,
				1   -- State
			) 
			WITH LOG
			*/
		FETCH NEXT FROM cur1 INTO @event_drive, @event_percent
		END
		CLOSE cur1
		DEALLOCATE cur1

	END
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

DROP TABLE #temp_EventLog
DROP TABLE #drives

END --Blackout Check
GO
/****** Object:  StoredProcedure [dbo].[usp_EmailDashboard_Daily]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_EmailDashboard_Daily] AS
-------SQL 2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes captures the following information and sends an email to SW_DB9009@hp.com

--TR-HC-1.1
--==========
--HC Metric Data 2  Client Name, Server Name, Instance Name, Database Backup Success Percentage, dashboard status and dashboard indicator.
--Finds the backup percentage is the percentage of ALL database entities that were successfully backed up daily.
--Return all the information above and the Green, Yellow, Red flag and reason for the color if Yellow or Red.  

--GREEN, if Backup Success Percentage is 100.
--=====
--dashboard status = 'G' 
--dashboard indicator = 'Backup Success Percentage is 100.'

--YELLOW, if Backup Success Percentage less than 100 but more than 97.
--======
--dashboard status = 'Y' 
--dashboard indicator = 'Backup Success Percentage is @percentage'

--RED, if Backup Success Percentage less than 98.
--===
--dashboard status = 'R' 
--dashboard indicator = 'Backup Success Percentage is @percentage'



--TR-HC-6.1
--=========
--HC Metric Data 11  Client Name, Server Name, Instance Name, job_success_percent, dashboard status and dashboard indicator.
--If success rate is 98% or above, dashboard status = Green
--IF job success rate is less than 98%,  dashboard status = Yellow
--If job success rate is less than 96%,  dashboard status = RED
--Return all the information above and the Green, Yellow, Red flag and reason for the color if Yellow or Red.  


-- The procedure don't receive any parameter
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC SYSAdmin..[usp_EmailDashboard_Daily]
----------------------------------------------------------------
--08/26/2013 v2012 - SMurua - Initial creation
----------------------------------------------------------------
SET NOCOUNT ON
declare @client_name varchar(50), @tot int, @succ int, @succ2 int, @percentage int, @server_name varchar(100), @instance_name varchar(50)
declare @job_success_percent int, @count_ok int, @count_db int, @updated_date datetime
declare @dashboard_status char(1), @dashboard_indicator varchar(100)
declare @date_str varchar(10)

DECLARE
	@date as varchar(50),
	@time as varchar(15),	
	@email_header as varchar(150),
	@email_footer as varchar(150),
	@email_body as varchar(8000),
	@record as varchar(8000),		
	@x as Integer,
	@z as Integer,
	@random_number INT,
	@random_upper INT,
	@random_lower INT,	
	@error as BIT,	
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000),
	@mon_sql_version as varchar(50);

	--check if server life cycle is Production
	IF (SELECT [variable3] FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc') = 'Prod'
		BEGIN

			--A random number will be generated later in the script to be used as part of the 
			--email subject line.
			SET @random_lower = 10000
			SET @random_upper = 99999
			SET @error = 0

			SELECT  
				@mail_profile_name = mail_profile_name,
				@mail_recipients = variable4,
				@mail_copy_recipients = mail_copy_recipients,
				@mail_blind_copy_recipients = mail_blind_copy_recipients
			FROM SYSAdmin.dbo.MON_SQL_CFG
			WHERE proc_name = 'usp_UploadStatsProc'
			
				
			--Formating time/date to be used for Header/Footer details.
			SELECT @date = CONVERT(VARCHAR(50),GETDATE(),112)
			SELECT @time = REPLACE(CONVERT(VARCHAR(15),GETDATE(),108),':','')
			
			-------------------------------------------------------------------------------------------------------------
			select @client_name = variable2 from dbo.MON_SQL_CFG where proc_name= 'usp_UploadStatsProc'
			
			SELECT TOP 1 @instance_name = [instance_name]
			FROM [dbo].[MON_SQL_CFG_Instance]
			ORDER BY [updated_date] DESC
			
			EXEC master..xp_regread 'HKEY_LOCAL_MACHINE',
			'SYSTEM\ControlSet001\Control\ComputerName\ActiveComputerName',
			'ComputerName',
	                @server_name OUTPUT
						
			select @updated_date = max(updated_date) from [MON_SQL_CFG_Database_Backups]
			set @date_str = CONVERT(varchar(10), @updated_date,101)						
			
			SET @succ = 0
			SET @succ2 = 0
			
			SELECT @succ = COUNT(*) FROM [dbo].[MON_SQL_CFG_Database_Backups] WHERE [comments] = 'OK' AND [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			
			SELECT @succ2 = COUNT(*) FROM [dbo].[MON_SQL_CFG_Database_Backups] 
			WHERE [comments] <> 'OK' 
			AND [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			AND database_name IN 
																	(SELECT '[' + database_name + ']' 
																	FROM SYSAdmin.dbo.MON_SQL_CFG_BackupReports)
			
			SELECT @tot = COUNT(*) FROM [dbo].[MON_SQL_CFG_Database_Backups] WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)

			SET @succ = @succ + @succ2
			SET @percentage = ((@succ * 100) / @tot)

			if @percentage = 100
				begin
					set @dashboard_status = 'G'
					set @dashboard_indicator = ''
				end
			if @percentage < 100 AND @percentage >= 98
				begin
					set @dashboard_status = 'Y'
					set @dashboard_indicator = 'Backup Success Percentage is ' + CONVERT(varchar(3), @percentage) + '.'
				end
			if @percentage < 98
				begin
					set @dashboard_status = 'R'
					set @dashboard_indicator = 'Backup Success Percentage is ' + CONVERT(varchar(3), @percentage) + '.'
				end		
			  
			
	
			-------------------------------------------------------------------------------------------------------------
			
			SET @record = ''
			--Creating record
			SET @record = 
				'exec dbateam.stats.upload_hc_1_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>''' + ISNULL(RTRIM(@server_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)				
				+ '   a_database_backup_success_percentage=>''' + ISNULL(RTRIM(convert(varchar(3),@percentage)),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + ''', -' + CHAR(13)+CHAR(10)				
				+ '   a_dashboard_status=>''' + ISNULL(RTRIM(@dashboard_status),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_dashboard_indicator=>''' + ISNULL(@dashboard_indicator,'') + '''-' + CHAR(13)+CHAR(10)
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)
				
			set @dashboard_status = ''
			set @dashboard_indicator = ''
			
			select @updated_date = max(updated_date) from [MON_SQL_CFG_Database_Backups]
			set @date_str = CONVERT(varchar(10), @updated_date,101)						
						
			SELECT @count_ok = COUNT(*)
			FROM [dbo].[MON_SQL_CFG_Database_Backups]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			AND [comments] = 'OK'

			SELECT @count_db = COUNT(*)
			FROM [dbo].[MON_SQL_CFG_Database_Backups]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)

			SET @job_success_percent = (@count_ok * 100) / @count_db

			if @job_success_percent >= 98
				begin
					set @dashboard_status = 'G'
					set @dashboard_indicator = ''
				end

			if @job_success_percent >= 96 and @job_success_percent < 98
				begin
					set @dashboard_status = 'Y'
					set @dashboard_indicator = 'Job Success Percent is ' + convert(varchar(3),@job_success_percent)
				end

			if @job_success_percent < 96
				begin
					set @dashboard_status = 'R'
					set @dashboard_indicator = 'Job Success Percent is ' + convert(varchar(3),@job_success_percent)
				end
			
			--Creating record
			SET @record = @record +
				'exec dbateam.stats.upload_hc_6_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@server_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_job_success_percent=>''' + ISNULL(RTRIM(convert(varchar(3),@job_success_percent)),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + ''', -' + CHAR(13)+CHAR(10)								
				+ '   a_dashboard_status=>''' + ISNULL(RTRIM(@dashboard_status),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_dashboard_indicator=>''' + ISNULL(@dashboard_indicator,'') + '''-' + CHAR(13)+CHAR(10)
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)



				
			      
			--Generate a random number for use with the email subject and header.
			SELECT @random_number = ROUND(((@random_upper - @random_lower -1) * RAND() + @random_lower), 0)

			--Header
			SELECT @email_header = ('upload_dashboard_stats.' + @server_name + '.' + @instance_name + '.' + RTRIM(CONVERT(VARCHAR(10),@random_number)) + '.' + @date + '.' + @time + '.sql')

			--Footer
			SELECT @email_footer = 'REM end ' + RTRIM(@email_header) + CHAR(13)+ 'ENDOFDATA'

			--Inserting the Header into @email_body
			SELECT @email_body = 'REM begin '+ RTRIM(@email_header)
			+ '  ' + CHAR(13)+CHAR(10)
			+ '  ' + CHAR(13)+CHAR(10)

			SELECT @email_body = @email_body + @record
			SELECT @email_body = @email_body + @email_footer

			IF (@email_body IS NULL) OR 
				(@email_header IS NULL) OR 
				(@mail_recipients IS NULL) 
			BEGIN
			RAISERROR ('NULL value passed to xp_smtp_sendmail, SYSAdmin.dbo.usp_EmailDashboard_Daily aborting.', 18, 1) WITH NOWAIT
			END ELSE
			BEGIN
				IF @error = 0
				BEGIN
				
					EXEC msdb.dbo.sp_send_dbmail
						@profile_name = @mail_profile_name,
						@recipients = @mail_recipients,
						@copy_recipients = @mail_copy_recipients,
						@blind_copy_recipients = @mail_blind_copy_recipients,
						@subject = @email_header,
						@body = @email_body;	
				END
			END
			
	END			




GO
/****** Object:  StoredProcedure [dbo].[usp_EmailDashboard_Monthly]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_EmailDashboard_Monthly] AS
-----SQL 2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes captures the following information and sends an email to SW_DB9009@hp.com

--TR-EOL-1.1
--==========
--EOL Metric Data 1  Client Name, Server Name, Instance Name, Operating System Name, Operating System Version, Database Version, Database Edition, Service Pack Level, Hot-fix Level, and Server Life Cycle , dashboard status and dashboard indicator.
--Finds the SQL version and hot fix level. Compare this to the SQL DBA Table "[MON_SQL_CFG_Support_Lifecycle]" for supported systems.
--Return all the information above and the Green, Yellow, Red flag and reason for the color if Yellow or Red.  
--GREEN
--=====
--dashboard status = 'G' 
--dashboard indicator = 'SUPPORTED'
--YELLOW
--======
--dashboard status = 'Y' 
--dashboard indicator = 'SP UNSUPPORTED'
--RED
--===
--dashboard status = 'R' 
--dashboard indicator = 'Unsupported SQL Version'



--TR-HC-2.1
--=========
--HC Metric Data 6  Client Name, Server Name, Instance Name, DatabaseCount_with_nonstandard_persmision, dashboard status and dashboard indicator.
--Finds the object permissions standard, which are connect, references, execute, insert, update, delete, and select.
--Return all the information above and the Green, Yellow, Red flag and reason for the color if Yellow or Red.  
--GREEN, if non standard permissions is 0.
--=====
--dashboard status = 'G' 
--dashboard indicator = 'All objects permissions are standard.'
--YELLOW, if non standard permissions is greater than 0.
--======
--dashboard status = 'Y' 
--dashboard indicator = 'Some objects permissions are not standard.'
--RED, there is no red color for this metric.
--===




--TR-HC-3.1
--=========
--HC Metric Data 7  Client Name, Server Name, Instance Name, NBR_DB_Backlevel_Compatibility, dashboard status and dashboard indicator.
--Checks if database compatibility level is different from the SQL Version it is running on. If there is a compatibility difference, checks the compatibility level against the EOL supported version table. Reports a dashboard status of RED if the compatibility level of the database object is at a version in the version table that is unsupported.
--Return all the information above and the Green, Yellow, Red flag and reason for the color if Yellow or Red.  
--GREEN
--=====
--dashboard status = 'G', is there are db back level compatibility supported or there are no db back level compatibility.
--dashboard indicator = <number of db back level compatibility>
--YELLOW, there is no yellow.
--======
--RED, is there are db back level compatibility not supported.
--===
--dashboard status = 'R' 
--dashboard indicator = <number of db back level compatibility>




--TR-HC-4.1
--=========
--HC Metric Data 9  Client Name, Server Name, Instance Name, TOT_LOGON_ACCTS, TOT_NT_ACCTS, TOT_SQL_ACCTS, dashboard status and dashboard indicator.
--Dashboard status is YELLOW if there are any SQL Authentification Login accounts. Returns the total number of accounts in each instance for NT, SQL and total. GREEN status if there are no SQL accounts.
--Return all the information above and the Green, Yellow, Red flag and reason for the color if Yellow or Red.  
--GREEN, if there are no SQL accounts.
--=====
--dashboard status = 'G'
--dashboard indicator = ''
--YELLOW, if there are SQL accounts.
--======
--dashboard status = 'Y' 
--dashboard indicator = <number of SQL accounts>
--RED, there is no red color.
--===



--TR-HC-5.1
--=========
--HC Metric Data 10  Client Name, Server Name, Instance Name, dashboard status and dashboard indicator.
--Look for any form of redundancy that you can find and code a sql statement. Look for Cluster, Log shipping, Mirror, Replication. If any form of redundancy, the instance is GREEN. Instance is Yellow if the no form of redundancy is found.
--Return all the information above and the Green, Yellow, Red flag and reason for the color if Yellow or Red.  
--GREEN
--=====
--dashboard status = 'G' 
--dashboard indicator = ''
--YELLOW
--======
--dashboard status = 'Y' 
--dashboard indicator = 'This is a stand alone server with no redundancy.'
--RED, no red color.
--===



--TR-HC-7.1
--=========
--HC Metric Data 12  Client Name, Server Name, Instance Name, TOT_GROUP_ACCTS, TOT_INDIVIDUAL_ACCTS.



--TR-HC-8.1
--=========
--HC Metric Data 13  Client Name, Server Name, Instance Name, Violation Count, dashboard status and dashboard indicator.
--SA Role, Security Admin, DDL Admin, DB Creator, Server Admin, Disk Admin, Process Admin :  If any of these are granted then count the total number of all grants.   
--If the Violations Count is 5 or less, then dashboard status is GREEN
--If the Violations Count is greater than 5, turn dashboard status for the instance to YELLOW
--There is no RED status at this time.
--Return all the information above and the Green, Yellow, Red flag and reason for the color if Yellow or Red.  




--TR-DRFT-1.1
--===========
--DRFT Metric Data 3  Metric Data 3  Client Name, Server Name, Instance Name, Total Data GB Allocated, Total Log GB Allocated.



--TR-DRFT-2.1
--===========
--DRFT Metric Data 4a  Client Name, Server Name, Instance Name, Total DB Size, Total Growth



--TR-DRFT-2.2
--===========
--DRFT Metric Data 4b  Client Name, Server Name, Instance Name, Database Name, Growth Rate



--TR-DRFT-3.1
--===========
--DRFT Metric Data 8  Client Name, Server Name, Instance Name, TOT_DB_GB_Allocated, TOT_DB_GB_USED, dashboard status
--Calculate the percentage used on the instance level.  
--Dashboard status = GREEN if the percentage allocated is 75% or less.
--Dashboard status = Yellow if the percentage allocated is > 75%.
--Dashboard status =  RED if the percentage allocated is > 90%.




-- The procedure don't receive any parameter
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC SYSAdmin..[usp_EmailDashboard_Monthly]
----------------------------------------------------------------
--08/30/2013 v2012 - SMurua - Initial creation
----------------------------------------------------------------
SET NOCOUNT ON

declare @client_name varchar(50), @host_name varchar(50), @operating_system_name varchar(50), @operating_system_version varchar(50)
declare @instance_name varchar(100), @database_edition varchar(50), @service_pack_level varchar(50)
declare @server_life_cycle varchar(50), @hot_fix_level varchar(50), @database_version varchar(20)
declare @dashboard_status char(1), @dashboard_indicator varchar(100)
declare @tot int, @updated_date datetime
declare @version varchar(5), @current_compatibility_level varchar(50)
declare @TOT_SQL_ACCTS int, @TOT_NT_ACCTS int, @TOT_LOGON_ACCTS int, @redundancy bit
declare @group_acct int, @individual_acct int, @violation_count int
declare @succ int, @total_data_gb_allocated varchar(10), @total_log_gb_allocated varchar(10), @total_db_size_gb varchar(10), @total_growth_gb varchar(10)
declare @database_name varchar(100), @growth varchar(50), @strSQL varchar(1000)
declare @tot_allocated_gb decimal(18,2), @tot_used_gb decimal(18,2), @percentage_used decimal(18,2)
declare @auto_growth_mb int, @auto_growth_percentage int, @date_str varchar(10),@client_domain varchar(50)
declare @dba_group varchar(100), @team_email varchar(100), @eon_escalation_list varchar(100), @AuthenticationMode INT  
DECLARE @SQLVersion varchar(20), @fetch_status2 int, @database varchar(100)


DECLARE
	@date as varchar(50),
	@time as varchar(15),	
	@email_header as varchar(150),
	@email_footer as varchar(150),
	@email_body as varchar(8000),
	@record as varchar(8000),		
	@x as Integer,
	@z as Integer,
	@random_number INT,
	@random_upper INT,
	@random_lower INT,	
	@error as BIT,	
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000),
	@mon_sql_version as varchar(50);

	

			--A random number will be generated later in the script to be used as part of the 
			--email subject line.
			SET @random_lower = 10000
			SET @random_upper = 99999
			SET @error = 0

			SELECT  
				@mail_profile_name = mail_profile_name,
				@mail_recipients = variable4,
				@mail_copy_recipients = mail_copy_recipients,
				@mail_blind_copy_recipients = mail_blind_copy_recipients,
				@client_domain = variable1,
				@client_name = variable2,
				@dba_group = dba_group,
				@team_email = variable5,
				@eon_escalation_list = variable6
			FROM SYSAdmin.dbo.MON_SQL_CFG
			WHERE proc_name = 'usp_UploadStatsProc'
			
				
			--Formating time/date to be used for Header/Footer details.
			SELECT @date = CONVERT(VARCHAR(50),GETDATE(),112)
			SELECT @time = REPLACE(CONVERT(VARCHAR(15),GETDATE(),108),':','')
			
			SELECT TOP 1 
							@host_name = [host_name],
							@instance_name = [instance_name]
			FROM [SYSAdmin].[dbo].[MON_SQL_CFG_Instance]
			ORDER BY [updated_date] DESC
			
			SET @record = ''


	
					
			----------------------------TR-EOL-1.1--------------------------
			CREATE TABLE #VTable (IndexID int, ProductName varchar(200), INTValue varchar(200), CharValue varchar(200))
			INSERT INTO #VTable exec master.dbo.xp_msver
			SELECT @operating_system_version = CharValue from #VTable where ProductName = 'WindowsVersion'
			SELECT @hot_fix_level = CharValue from #VTable where ProductName = 'FileVersion'
			drop table #VTable

			SELECT @operating_system_name = RIGHT(@@version, LEN(@@version)- 3 -charindex (' ON ', @@VERSION)) 
			SELECT @server_life_cycle = [variable3] FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc'
			SELECT @database_version = convert(varchar(20), SERVERPROPERTY('productversion'))
			SELECT @database_edition = convert(varchar(50), SERVERPROPERTY('edition'))
			SELECT @service_pack_level = convert(varchar(50), SERVERPROPERTY('productlevel'))
			select @updated_date = max(updated_date) from [MON_SQL_CFG_Instance]
			set @date_str = CONVERT(varchar(10), @updated_date,101)						
			
			--version is supported and has the lastes SP
			if exists(SELECT *
						FROM [dbo].[MON_SQL_CFG_Support_Lifecycle]
						WHERE @database_version like substring([Version],1,(len([Version])-1)) + '%'
						AND Support_Status = 'N-1')
						begin
							set @dashboard_status = 'G'
							set @dashboard_indicator = ''
						end

			--version is supported and it has old SP
			if exists(SELECT *
						FROM [dbo].[MON_SQL_CFG_Support_Lifecycle]
						WHERE @database_version like substring([Version],1,(len([Version])-1)) + '%'
						AND Support_Status <> 'N-1')
						begin
							if exists(SELECT *
										FROM [dbo].[MON_SQL_CFG_Support_Lifecycle]
										WHERE @database_version like substring([Version],1,(len([Version])-2)) + '%'
										AND Support_Status = 'N-1')
								begin
									set @dashboard_status = 'Y'
									set @dashboard_indicator = 'SP UNSUPPORTED'
								end
						end


			--version is not supported
			if exists(SELECT *
						FROM [dbo].[MON_SQL_CFG_Support_Lifecycle]
						WHERE @database_version like substring([Version],1,(len([Version])-1)) + '%'
						AND Support_Status <> 'N-1')
						begin
							if not exists(SELECT *
										FROM [dbo].[MON_SQL_CFG_Support_Lifecycle]
										WHERE @database_version like substring([Version],1,(len([Version])-2)) + '%'
										AND Support_Status <> 'N-1'
										AND Version <> (SELECT Version
															FROM [dbo].[MON_SQL_CFG_Support_Lifecycle]
															WHERE @database_version like substring([Version],1,(len([Version])-1)) + '%'
															AND Support_Status <> 'N-1'))
															
								
								begin
									set @dashboard_status = 'R'
									set @dashboard_indicator = 'Unsupported SQL Version'
								end
						end

		



			--Creating record
			SET @record = @record +
				'exec dbateam.stats.upload_eol_1_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_operating_system_name=>''' + ISNULL(RTRIM(@operating_system_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_operating_system_version=>''' + ISNULL(RTRIM(@operating_system_version),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_database_version=>''' + ISNULL(RTRIM(@database_version),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_database_edition=>''' + ISNULL(RTRIM(@database_edition),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_service_pack_level=>''' + ISNULL(RTRIM(@service_pack_level),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_hot_fix_level=>''' + ISNULL(RTRIM(@hot_fix_level),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_life_cycle=>''' + ISNULL(RTRIM(@server_life_cycle),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_primary_team=>''' + ISNULL(RTRIM(@dba_group),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_team_email_address=>''' + ISNULL(RTRIM(@team_email),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_eon_list=>''' + ISNULL(RTRIM(@eon_escalation_list),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + ''', -' + CHAR(13)+CHAR(10)								
				+ '   a_dashboard_status=>''' + ISNULL(RTRIM(@dashboard_status),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_dashboard_indicator=>''' + ISNULL(@dashboard_indicator,'') + '''-' + CHAR(13)+CHAR(10)
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)

			set @dashboard_status = ''
			set @dashboard_indicator = ''
				
			-------------------------------------------------------------------------------------------
			
	--check if server life cycle is Production
	IF (SELECT [variable3] FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc') = 'Prod'
		BEGIN			
			-------------------------TR-HC-2.1------------------------------------------------------------
			select @updated_date = max(updated_date) from [MON_SQL_CFG_Database_Object_Permissions]
			set @date_str = CONVERT(varchar(10), @updated_date,101)						

			set @tot = 0
			SELECT @tot= COUNT(*)
			FROM [SYSAdmin].[dbo].[MON_SQL_CFG_Database_Object_Permissions]
			WHERE [action] not in ('execute','insert','update','delete','select', 'CONNECT', 'References')
			AND [action] NOT LIKE 'VIEW%'
			AND [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			group by databasename
			
			  
			if @tot = 0
				begin
					set @dashboard_status = 'G'
					set @dashboard_indicator = ''
				end
			if @tot > 0
				begin
					set @dashboard_status = 'Y'
					set @dashboard_indicator = 'Objects permissions are excessive on ' + CONVERT(varchar(3), @tot) + ' databases.'
				end
				
			

			--Creating record
			SET @record = @record +
				'exec dbateam.stats.upload_hc_2_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_database_count_with_nonstandard_permission=>''' + ISNULL(RTRIM(convert(varchar(10),@tot)),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + ''', -' + CHAR(13)+CHAR(10)												
				+ '   a_dashboard_status=>''' + ISNULL(RTRIM(@dashboard_status),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_dashboard_indicator=>''' + ISNULL(@dashboard_indicator,'') + '''-' + CHAR(13)+CHAR(10)
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)				

			set @dashboard_status = ''
			set @dashboard_indicator = ''
				
			-------------------------------------------------------------------------------------------



			------------------TR-HC-3.1---------------------------------------------------------
			select @updated_date = max(updated_date) from [MON_SQL_CFG_Database_Stats]
			set @date_str = CONVERT(varchar(10), @updated_date,101)						
			
			SELECT TOP 1 @current_compatibility_level = 
				CASE
					when substring(instance_version,1,2)='7.' then '70'
					when substring(instance_version,1,2)='8.' then '80'
					when substring(instance_version,1,2)='9.' then '90'
					when substring(instance_version,1,2)='10' then '100'
					when substring(instance_version,1,2)='11' then '110'
				END 
			FROM [dbo].[MON_SQL_CFG_Instance]
			ORDER BY [updated_date] DESC

			SELECT @tot = COUNT(*)
			FROM [dbo].[MON_SQL_CFG_Database_Stats]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			AND convert(int, @current_compatibility_level) > convert(int, [compatibility_level])
			 
			IF @tot < 0
				BEGIN
					SET @tot = 0
				END
				
			SELECT @version = 
				CASE
					when MIN(compatibility_level) = '70' then '7.'
					when MIN(compatibility_level) = '80' then '8.'
					when MIN(compatibility_level) = '90' then '9.'
					when MIN(compatibility_level) = '100' then '10'
					when MIN(compatibility_level) = '110' then '11'
				END
			FROM [dbo].[MON_SQL_CFG_Database_Stats]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			AND convert(int, @current_compatibility_level) > convert(int, [compatibility_level])

			if exists(SELECT *
						FROM [dbo].[MON_SQL_CFG_Support_Lifecycle]
						WHERE substring([Version],1,2) = @version
						AND Support_Status = 'N-1') OR @version IS NULL
						begin
							set @dashboard_status = 'G'
							set @dashboard_indicator = ''
						end
			else
						begin
							set @dashboard_status = 'R'
							set @dashboard_indicator = 'Number of databases with unsupported compatibility level is: ' + CONVERT(varchar(3),@tot)
						end
						
			

			--Creating record
			SET @record = @record +
				'exec dbateam.stats.upload_hc_3_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_nbr_db_backlevel_compatibility=>''' + ISNULL(RTRIM(convert(varchar(3),@tot)),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + ''', -' + CHAR(13)+CHAR(10)												
				+ '   a_dashboard_status=>''' + ISNULL(RTRIM(@dashboard_status),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_dashboard_indicator=>''' + ISNULL(@dashboard_indicator,'') + '''-' + CHAR(13)+CHAR(10)
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)

			set @dashboard_status = ''
			set @dashboard_indicator = ''
				
			--------------------------------------------------------------------------------------


			---------------------TR-HC-4.1-----------------------------------------------------------------

			select @updated_date = max(updated_date) from [MON_SQL_CFG_LogonAccounts]
			set @date_str = CONVERT(varchar(10), @updated_date,101)						
			
			SELECT @TOT_SQL_ACCTS = COUNT(*)
			FROM [dbo].[MON_SQL_CFG_LogonAccounts]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			AND [logon_active_status] = 1
			AND [logon_user_type] = 'SQL_LOGIN'
			and logon_account_name NOT LIKE '##%'
			AND logon_account_name NOT IN ('NT AUTHORITY\SYSTEM', 'sa')

			SELECT @TOT_NT_ACCTS = COUNT(*)
			FROM [dbo].[MON_SQL_CFG_LogonAccounts]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			AND [logon_active_status] = 1
			AND [logon_user_type] <> 'SQL_LOGIN'
			AND logon_account_name NOT IN ('NT AUTHORITY\SYSTEM', 'sa')

			SELECT @TOT_LOGON_ACCTS = COUNT(*)
			FROM [dbo].[MON_SQL_CFG_LogonAccounts]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			AND [logon_active_status] = 1
			and logon_account_name NOT LIKE '##%'
			AND logon_account_name NOT IN ('NT AUTHORITY\SYSTEM', 'sa')
			
			IF @TOT_SQL_ACCTS < 0
				BEGIN
					SET @TOT_SQL_ACCTS = 0
				END
				
			IF @TOT_NT_ACCTS < 0
				BEGIN
					SET @TOT_NT_ACCTS = 0
				END
				
			IF @TOT_LOGON_ACCTS < 0
				BEGIN
					SET @TOT_LOGON_ACCTS = 0
				END
				
			--check authentication mode
			EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', 
			N'Software\Microsoft\MSSQLServer\MSSQLServer',   
			N'LoginMode', @AuthenticationMode OUTPUT  

			-- 1 = 'Windows Authentication'   
			-- 2 = 'Windows and SQL Server Authentication'   

			if @AuthenticationMode = 1
				begin
					set @dashboard_status = 'G'
					set @dashboard_indicator = ''
				end
			else
				begin
				if @TOT_SQL_ACCTS = 0
							begin
								set @dashboard_status = 'G'
								set @dashboard_indicator = ''
							end
				else
							begin
								set @dashboard_status = 'Y'
								set @dashboard_indicator = 'Number of SQL authentication login accounts is: ' + CONVERT(varchar(3),@TOT_SQL_ACCTS)
							end
			end
			--Creating record
			SET @record = @record +
				'exec dbateam.stats.upload_hc_4_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_tot_logon_accts=>''' + ISNULL(RTRIM(convert(varchar(3),@TOT_LOGON_ACCTS)),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_tot_nt_accts=>''' + ISNULL(RTRIM(convert(varchar(3),@TOT_NT_ACCTS)),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_tot_sql_accts=>''' + ISNULL(RTRIM(convert(varchar(3),@TOT_SQL_ACCTS)),'') + ''', -' + CHAR(13)+CHAR(10)								
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + ''', -' + CHAR(13)+CHAR(10)												
				+ '   a_dashboard_status=>''' + ISNULL(RTRIM(@dashboard_status),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_dashboard_indicator=>''' + ISNULL(@dashboard_indicator,'') + '''-' + CHAR(13)+CHAR(10)
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)

			set @dashboard_status = ''
			set @dashboard_indicator = ''

			--------------------------------------------------------------------------------------
			
			
			-----------------------TR-HC-5.1---------------------------------------------------------------

			select @updated_date = max(updated_date) from [MON_SQL_CFG_Instance]
			set @date_str = CONVERT(varchar(10), @updated_date,101)						

			--cluster
			SELECT TOP 1 
							@redundancy = [is_clustered]
			FROM [dbo].[MON_SQL_CFG_Instance]
			ORDER BY [updated_date] DESC

			--alwayson
			IF  EXISTS (SELECT * FROM master..sysobjects WHERE name like '%dm_hadr_database_replica_cluster_states%')
				BEGIN
					if @redundancy = 0
						begin
							if (select count(*) from sys.dm_hadr_database_replica_cluster_states) <> 0
									begin
										set @redundancy = 1
									end
						end
				END
				

			--mirror
			if @redundancy = 0
				begin
				
					if (select COUNT(*) from sys.database_mirroring where mirroring_state_desc is not null) <> 0
							begin
								set @redundancy = 1
							end
				end

			--logshipping
			if @redundancy = 0
				begin
				
					if (select COUNT(*) from [msdb].[dbo].[log_shipping_primary_databases]) <> 0
						or (select COUNT(*) from [msdb].[dbo].[log_shipping_secondary_databases]) <> 0
							begin
								set @redundancy = 1
							end
				end
				
			--replication
			if @redundancy = 0
				begin
			
						DECLARE C_2 CURSOR FOR  
						select '[' + name + ']' 
						from master.dbo.sysdatabases 
						where databaseproperty(name, 'IsPublished') = 1
						and name not in (select s.name 
                                          from master.dbo.sysdatabases s 
                                          where databaseproperty(s.name, 'IsInRecovery') = 1
                                          or databaseproperty(s.name, 'IsInLoad') = 1 
                                          or databaseproperty(s.name, 'IsOffline') = 1 
                                          or databaseproperty(s.name, 'IsSingleUser') = 1 
                                          or databaseproperty(s.name, 'IsSuspect') = 1)
						and name not in ('model', 'tempdb', 'SYSAdmin', 'master', 'msdb', 'SYSWarehouse')
						order by name

						OPEN C_2

						FETCH NEXT FROM C_2 INTO @database
						set @fetch_status2 = @@fetch_status
						WHILE (@fetch_status2 <> -1)
							BEGIN
								CREATE TABLE #tmp_replcationInfo ( 
									status int
									) 
					
									
									set @strSQL = 'use ' + @database + '; 
									
									select count(*) as status
									from dbo.syspublications sp  
									join dbo.sysarticles sa on sp.pubid = sa.pubid 
									join dbo.syssubscriptions s on sa.artid = s.artid 
									join master.dbo.sysservers srv on s.srvid = srv.srvid 
									' 

									insert into #tmp_replcationInfo
									exec (@strSQL)
									
									if exists(select * from #tmp_replcationInfo)
										begin
												set @redundancy = 1
										end
										
									drop table #tmp_replcationInfo
										
									FETCH NEXT FROM C_2 INTO @database
									set @fetch_status2 = @@fetch_status

							END
						DEALLOCATE C_2

				end
								
			if @redundancy = 1
			begin
				set @dashboard_status = 'G'
				set @dashboard_indicator = ''
			end
			else
			begin
				set @dashboard_status = 'Y'
				set @dashboard_indicator = 'This is a stand alone server with no redundancy.'
			end
				
			--Creating record
			SET @record =  @record +
				'exec dbateam.stats.upload_hc_5_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + ''', -' + CHAR(13)+CHAR(10)												
				+ '   a_dashboard_status=>''' + ISNULL(RTRIM(@dashboard_status),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_dashboard_indicator=>''' + ISNULL(@dashboard_indicator,'') + '''-' + CHAR(13)+CHAR(10)
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)
		
			set @dashboard_status = ''
			set @dashboard_indicator = ''
		
			--------------------------------------------------------------------------------------
			
			
			-----------------------TR-HC-7.1---------------------------------------------------------------
			select @updated_date = max(updated_date) from [MON_SQL_CFG_LogonAccounts]
			set @date_str = CONVERT(varchar(10), @updated_date,101)						
			
			SELECT @group_acct = COUNT(*)
			FROM [dbo].[MON_SQL_CFG_LogonAccounts]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			AND [logon_active_status] = 1
			AND [logon_user_type] = 'WINDOWS_GROUP'

			SELECT @individual_acct = COUNT(*)
			FROM [dbo].[MON_SQL_CFG_LogonAccounts]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			AND [logon_active_status] = 1
			AND [logon_user_type] <> 'WINDOWS_GROUP'

			IF @group_acct < 0
				BEGIN
					SET @group_acct = 0
				END
				
			IF @individual_acct < 0
				BEGIN
					SET @individual_acct = 0
				END				
				
			--Creating record
			SET @record = @record +
				'exec dbateam.stats.upload_hc_7_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_individual_acct=>''' + ISNULL(RTRIM(convert(varchar(3),@individual_acct)),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_group_acct=>''' + ISNULL(RTRIM(convert(varchar(3),@group_acct)),'') + ''', -' + CHAR(13)+CHAR(10)				
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + '''-' + CHAR(13)+CHAR(10)								
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)

			set @dashboard_status = ''
			set @dashboard_indicator = ''

			--------------------------------------------------------------------------------------
			
			
			-----------------------TR-HC-8.1---------------------------------------------------------------
			select @updated_date = max(updated_date) from [MON_SQL_CFG_LogonAccountsServerRoles]
			set @date_str = CONVERT(varchar(10), @updated_date,101)															
			
			SELECT @violation_count = count(*)
			FROM [dbo].[MON_SQL_CFG_LogonAccountsServerRoles]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			AND server_role in ('sysadmin', 'securityadmin', 'serveradmin', 'setupadmin', 'processadmin', 'diskadmin', 'dbcreator', 'bulkadmin')
			AND logon_account_name not in ('NT AUTHORITY\SYSTEM', 'sa')

			IF @violation_count < 0
				BEGIN
					SET @violation_count = 0
				END	
				
			if @violation_count <= 5
				begin
					set @dashboard_status = 'G'
					set @dashboard_indicator = ''
				end

			if @violation_count > 5
				begin
					set @violation_count = @violation_count - 5
					set @dashboard_status = 'Y'
					set @dashboard_indicator = 'Number of server roles accounts : ' + CONVERT(varchar(3), @violation_count)
				end	
										
			--Creating record
			SET @record = @record +
				'exec dbateam.stats.upload_hc_8_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_violation_count=>''' + ISNULL(RTRIM(convert(varchar(3),@violation_count)),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + ''', -' + CHAR(13)+CHAR(10)												
				+ '   a_dashboard_status=>''' + ISNULL(RTRIM(@dashboard_status),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_dashboard_indicator=>''' + ISNULL(@dashboard_indicator,'') + '''-' + CHAR(13)+CHAR(10)
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)

			set @dashboard_status = ''
			set @dashboard_indicator = ''
			      
			--------------------------------------------------------------------------------------
	END
			--for Prod-Dev-UAT		
			-----------------------TR-DRFT-1.1---------------------------------------------------------------
			select @updated_date = max(updated_date) from MON_SQL_CFG_Database_File_Information
			set @date_str = CONVERT(varchar(10), @updated_date,101)						
			
			SELECT TOP 1 
				@total_data_gb_allocated = (SELECT convert(decimal(18,2),(SUM(convert(decimal(18,2),[initial_size_mb]))) / 1024) 
											FROM [dbo].[MON_SQL_CFG_Database_File_Information]
											WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
											AND right([file_name],4) <> '.ldf'),
											
				@total_log_gb_allocated = (SELECT convert(decimal(18,2),(SUM(convert(decimal(18,2),[initial_size_mb]))) / 1024) 
											FROM [dbo].[MON_SQL_CFG_Database_File_Information]
											WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
											AND right([file_name],4) <> '.ndf')
											
			FROM [dbo].[MON_SQL_CFG_Instance]
			ORDER BY [updated_date] DESC

			IF convert(decimal(18,2),@total_data_gb_allocated) < 0
				BEGIN
					SET @total_data_gb_allocated = 0.00
				END	
				
			IF convert(decimal(18,2),@total_log_gb_allocated) < 0
				BEGIN
					SET @total_log_gb_allocated = 0.00
				END	
					
			--Creating record
			SET @record = @record +
				'exec dbateam.stats.upload_drft_1_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_total_data_gb_allocated=>''' + ISNULL(RTRIM(@total_data_gb_allocated),'') + ''', -' + CHAR(13)+CHAR(10)				
				+ '   a_total_log_gb_allocated=>''' + ISNULL(RTRIM(@total_log_gb_allocated),'') + ''', -' + CHAR(13)+CHAR(10)				
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + '''-' + CHAR(13)+CHAR(10)												
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)

			set @dashboard_status = ''
			set @dashboard_indicator = ''

			--------------------------------------------------------------------------------------

			
			
			-----------------------TR-DRFT-2.1---------------------------------------------------------------
			select @updated_date = max(updated_date) from [MON_SQL_CFG_Database_Stats]
			set @date_str = CONVERT(varchar(10), @updated_date,101)												
			
			SELECT @total_db_size_gb = convert(decimal(18,2),(sum(convert(decimal(18,2),[used_mb]))/1024))
				  ,@total_growth_gb = convert(decimal(18,2),(sum(convert(decimal(18,2),replace([growth],' MB', '')))/1024))
			FROM [dbo].[MON_SQL_CFG_Database_Stats]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			GROUP BY [instance_name], [updated_date]

			IF convert(decimal(18,2),@total_db_size_gb) < 0
				BEGIN
					SET @total_db_size_gb = 0.00
				END	
			
			IF convert(decimal(18,2),@total_growth_gb) < 0
				BEGIN
					SET @total_growth_gb = 0.00
				END
							
			--Creating record
			SET @record = @record + 
				'exec dbateam.stats.upload_drft_2_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_total_db_size_gb=>''' + ISNULL(RTRIM(@total_db_size_gb),'') + ''', -' + CHAR(13)+CHAR(10)				
				+ '   a_total_growth_gb=>''' + ISNULL(RTRIM(@total_growth_gb),'') + ''', -' + CHAR(13)+CHAR(10)				
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + '''-' + CHAR(13)+CHAR(10)												
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)

			set @dashboard_status = ''
			set @dashboard_indicator = ''

			--------------------------------------------------------------------------------------
			
			
	--check if server life cycle is Production
	IF (SELECT [variable3] FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc') = 'Prod'
		BEGIN				
			-----------------------TR-DRFT-2.2---------------------------------------------------------------
			select @updated_date = max(updated_date) from [MON_SQL_CFG_Database_Stats]
			set @date_str = CONVERT(varchar(10), @updated_date,101)						
			
			declare C_1 CURSOR FOR
				SELECT DISTINCT TOP 10 [database_name]
					,convert(decimal(18,2),((convert(decimal(18,2),(sum(convert(decimal(18,2),replace([growth],' MB', '')))/1024)) * 100) 
					/ convert(decimal(18,2),(min(convert(decimal(18,2),[used_mb]))/1024)))) as growth_rate,
					(SELECT TOP 1 [auto_growth_mb] FROM [dbo].[MON_SQL_CFG_Database_File_Information] WHERE '[' + [database_name] + ']' = [MON_SQL_CFG_Database_Stats].database_name AND RIGHT(file_name,4) = '.mdf' ORDER BY [updated_date] DESC) as auto_growth_mb,
					(SELECT TOP 1 [auto_growth_percentage] FROM [dbo].[MON_SQL_CFG_Database_File_Information] WHERE '[' + [database_name] + ']' = [MON_SQL_CFG_Database_Stats].database_name AND RIGHT(file_name,4) = '.mdf' ORDER BY [updated_date] DESC) as auto_growth_percentage
				FROM [dbo].[MON_SQL_CFG_Database_Stats]
				WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
				GROUP BY [instance_name], [database_name],[updated_date]
				HAVING convert(decimal(18,2),(min(convert(decimal(18,2),[used_mb]))/1024)) > 0
				ORDER BY convert(decimal(18,2),((convert(decimal(18,2),(sum(convert(decimal(18,2),replace([growth],' MB', '')))/1024)) * 100) 
				/ convert(decimal(18,2),(min(convert(decimal(18,2),[used_mb]))/1024)))) DESC

					open C_1
					 fetch next from C_1 into @database_name, @growth, @auto_growth_mb, @auto_growth_percentage

					 While @@FETCH_STATUS = 0
					 Begin

							
							--Creating record
							SET @record = @record +
								'exec dbateam.stats.upload_drft_2_2_stats ( -' + CHAR(13)+CHAR(10)
								+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
								+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
								+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
								+ '   a_database_name=>''' + ISNULL(RTRIM(@database_name),'') + ''', -' + CHAR(13)+CHAR(10)				
								+ '   a_growth=>''' + ISNULL(RTRIM(@growth),'') + '''-' + CHAR(13)+CHAR(10)				
								+ '   a_auto_growth_mb=>''' + ISNULL(RTRIM(convert(varchar(10),@auto_growth_mb)),'') + '''-' + CHAR(13)+CHAR(10)				
								+ '   a_auto_growth_percentage=>''' + ISNULL(RTRIM(convert(varchar(10),@auto_growth_percentage)),'') + ''', -' + CHAR(13)+CHAR(10)				
								+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + '''-' + CHAR(13)+CHAR(10)																
								+ ');' 
								+ CHAR(13)+CHAR(10)
								+ CHAR(13)+CHAR(10)
							      

						   fetch next from C_1 into @database_name, @growth, @auto_growth_mb, @auto_growth_percentage
					 End 


					 close C_1
					 deallocate C_1

			set @dashboard_status = ''
			set @dashboard_indicator = ''


			-----------------------------------------------------------------------------------

			
			---------------------TR-DRFT-3.1----------------------------------------------------
			select @updated_date = max(updated_date) from [MON_SQL_CFG_Database_Stats]
			set @date_str = CONVERT(varchar(10), @updated_date,101)												
			
			SELECT 
				@tot_allocated_gb = convert(decimal(18,2),(sum(convert(decimal(18,2),[allocated_mb]))/1024)),
				@tot_used_gb = convert(decimal(18,2),(sum(convert(decimal(18,2),[used_mb]))/1024))
			FROM [dbo].[MON_SQL_CFG_Database_Stats]
			WHERE [updated_date] BETWEEN (@updated_date - 0.000694444) AND (@updated_date + 0.000694444)
			GROUP BY [instance_name], [updated_date]

			if @tot_used_gb > @tot_allocated_gb
			begin
				set @tot_allocated_gb = @tot_used_gb
			end
			set @percentage_used = (@tot_used_gb * 100) / @tot_allocated_gb
			
			if @percentage_used <= 75
				begin
					set @dashboard_status = 'G'
					set @dashboard_indicator = ''
				end
				
			if @percentage_used > 75 AND @percentage_used < 90
				begin
					set @dashboard_status = 'Y'
					set @dashboard_indicator = 'Percentage used of the allocated space : ' + CONVERT(varchar(10), @percentage_used)
				end

			if @percentage_used >= 90
				begin
					set @dashboard_status = 'R'
					set @dashboard_indicator = 'Percentage used of the allocated space : ' + CONVERT(varchar(10), @percentage_used)
				end				
			
			--Creating record
			SET @record = @record +
				'exec dbateam.stats.upload_drft_3_1_stats ( -' + CHAR(13)+CHAR(10)
				+ '  a_client_name=>''' + ISNULL((@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_server_name=>'''  + ISNULL(RTRIM(@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_tot_allocated_gb=>''' + ISNULL(RTRIM(convert(varchar(10),@tot_allocated_gb)),'') + ''', -' + CHAR(13)+CHAR(10)				
				+ '   a_tot_used_gb=>''' + ISNULL(RTRIM(convert(varchar(10),@tot_used_gb)),'') + ''', -' + CHAR(13)+CHAR(10)								
				+ '   a_updated_date=>''' + ISNULL(RTRIM(@date_str),'') + ''', -' + CHAR(13)+CHAR(10)												
				+ '   a_dashboard_status=>''' + ISNULL(RTRIM(@dashboard_status),'') + ''', -' + CHAR(13)+CHAR(10)
				+ '   a_dashboard_indicator=>''' + ISNULL(@dashboard_indicator,'') + '''-' + CHAR(13)+CHAR(10)
				+ ');' 
				+ CHAR(13)+CHAR(10)
				+ CHAR(13)+CHAR(10)

			set @dashboard_status = ''
			set @dashboard_indicator = ''

			-----------------------------------------------------------------------------------

	END
					      
			--Generate a random number for use with the email subject and header.
			SELECT @random_number = ROUND(((@random_upper - @random_lower -1) * RAND() + @random_lower), 0)

			--Header
			SELECT @email_header = ('upload_dashboard_stats.' + @host_name + '.' + @instance_name + '.' + RTRIM(CONVERT(VARCHAR(10),@random_number)) + '.' + @date + '.' + @time + '.sql')

			--Footer
			SELECT @email_footer = 'REM end ' + RTRIM(@email_header) + CHAR(13)+ 'ENDOFDATA'

			--Inserting the Header into @email_body
			SELECT @email_body = 'REM begin '+ RTRIM(@email_header)
			+ '  ' + CHAR(13)+CHAR(10)
			+ '  ' + CHAR(13)+CHAR(10)

			SELECT @email_body = @email_body + @record
			SELECT @email_body = @email_body + @email_footer

			IF (@email_body IS NULL) OR 
				(@email_header IS NULL) OR 
				(@mail_recipients IS NULL) 
			BEGIN
			RAISERROR ('NULL value passed to xp_smtp_sendmail, SYSAdmin.dbo.usp_EmailDashboard_Monthly aborting.', 18, 1) WITH NOWAIT
			END ELSE
			BEGIN
				IF @error = 0
				BEGIN
					EXEC msdb.dbo.sp_send_dbmail
						@profile_name = @mail_profile_name,
						@recipients = @mail_recipients,
						@copy_recipients = @mail_copy_recipients,
						@blind_copy_recipients = @mail_blind_copy_recipients,
						@subject = @email_header,
						@body = @email_body;	
				END
			END
			
	
GO
/****** Object:  StoredProcedure [dbo].[usp_EmailDBDepot]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[usp_EmailDBDepot] AS
-------SQL 2012 EDITION v06_2012-----------------------------
----------------------------------------------------------------
-- This proc takes previously entered DB/Server information from 
-- SYSAdmin.dbo.Upload_Stats and emails it to seasqldba@eds.com
--
-- Execute the following command to view all settings for this script:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_UploadStatsProc'
--
-- 	mail_profile_name = SQL DBMail profile name to be used by this script.
--	mail_recipients = Email Address to send messages TO
--	variable1 = Domain name as listed in DBDepot.
--		It is case sensitive, and must match DBDepot exactly! (DEFAULT = CLIENT.DOMAIN)
--	variable2 = Client name as listed in DBDepot. 
--		It is case sensitive, and must match DBDepot exactly! (DEFAULT = CLIENT.NAME)
----------------------------------------------------------------

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[Upload_Stats]') AND OBJECTPROPERTY(id, N'IsUserTable') = 1)
	CREATE TABLE [dbo].[Upload_Stats] (
		[a_instance_name] [varchar] (100) ,
		[a_time_zone] [varchar] (50) ,
		[a_listener_port] [varchar] (50),
		[a_db_type] [varchar] (50) ,
		[a_log_mode] [varchar] (50) ,
		[a_host_name] [varchar] (100) ,
		[a_domain_name] [varchar] (50) ,
		[a_startup_time] [varchar] (50) ,
		[a_uptime_days] [varchar] (10) ,
		[a_os_type] [varchar] (50) ,
		[a_os_version] [varchar] (50) ,
		[a_vendor] [varchar] (50) ,
		[a_db_version] [varchar] (50) ,
		[a_files_mb] [varchar] (50) ,
		[a_segments_mb] [varchar] (50) ,
		[a_num_schemas] [varchar] (10) ,
		[a_num_tables] [varchar] (10) ,
		[a_num_objects] [varchar] (10)  
	) ON [PRIMARY]

SET NOCOUNT ON

DECLARE 
	@2 as varchar(100),
	@3 as varchar(100),
	@4 as varchar(100),
	@5 as varchar(100),
	@6 as varchar(100),
	@7 as varchar(100),
	@8 as varchar(100),
	@9 as varchar(100)

DECLARE
	@date as varchar(50),
	@time as varchar(15),

	@client_name varchar(50),
	@client_domain varchar(50),
	@host_name as varchar(100),
	@instance_a_instance_name as varchar(100),
	
	@email_header as varchar(150),
	@email_footer as varchar(150),
	@email_body as VARCHAR(8000),
	
	@record_host as nvarchar(4000),
	@record_instance as nvarchar(4000),
	@record_database_temp as nvarchar(4000),
	@record_database as nvarchar(4000),
		
	@totalNodes as Integer,
	@x as Integer,
	@z as Integer,
	@random_number INT,
	@random_upper INT,
	@random_lower INT,	
	@error as BIT,
	
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000),
	@mon_sql_version as varchar(50);

	--A random number will be generated later in the script to be used as part of the 
	--email subject line.
	SET @random_lower = 10000
	SET @random_upper = 99999
	SET @error = 0

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_UploadStatsProc') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG 
			(proc_name, mail_profile_name, mail_recipients, variable1, variable2)
		VALUES 
			('usp_UploadStatsProc','SQL_DBMail','stats@dbdepot.iweb.eds.com','CLIENT.DOMAIN','CLIENT.NAME')
	END

	SELECT  
		@mail_profile_name = mail_profile_name,
		@mail_recipients = mail_recipients,
		@mail_copy_recipients = mail_copy_recipients,
		@mail_blind_copy_recipients = mail_blind_copy_recipients,
		@client_domain = variable1,
		@client_name = variable2
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_UploadStatsProc';
	
	SELECT  
		@mon_sql_version = variable1
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'MON_SQL_VERSION';

--Confirm a MON_SQL version exists.
SET @mon_sql_version = ISNULL(@mon_sql_version,'MON_SQL')
IF (@mon_sql_version = '') SET @mon_sql_version = 'MON_SQL'	

--Check for default or NULL values listed for DBDepot Client Name or Client Domain
--variable1 & variable2
--If Default or NULL values are found, no email is sent.
IF (@client_domain IS NULL) OR (@client_domain = 'CLIENT.DOMAIN') OR (@client_domain = '') OR
	(@client_name IS NULL) OR (@client_name = 'CLIENT.NAME') OR (@client_name = '')
BEGIN
	RAISERROR ('Aborting usp_UploadBackupStats execution because a default or null value is stored within dbo.MON_SQL_CFG for usp_UploadStatsProc.  NULL or default values of CLIENT.DOMAIN & CLIENT.NAME within variable1 or variable2 not allowed.', 18, 1) WITH NOWAIT
	SET @error = 1
END

IF object_id('tempdb..#temp_ClusterNodes', 'U') is not null 
	DROP TABLE #temp_ClusterNodes

--Create temp table to store Cluster Node Names if they exist. 
CREATE TABLE #temp_ClusterNodes (
	id INT NOT NULL IDENTITY (1, 1),
	a_host_name VARCHAR(50)
)

--Setting default values for @totalNodes
SET @totalNodes = 1

--Change @totalNodes to correct number if other nodes exist.
IF (SELECT COUNT(*) FROM sys.dm_os_cluster_nodes) > 0 
  BEGIN
	SET @totalNodes = (SELECT COUNT(*) FROM sys.dm_os_cluster_nodes)
	INSERT INTO #temp_ClusterNodes SELECT NodeName FROM sys.dm_os_cluster_nodes
  END

--Retriving instance data to be used for all database/backup records.
SELECT TOP 1
	@instance_a_instance_name = LTRIM(RTRIM(a_instance_name)),
	@host_name = LTRIM(RTRIM(a_host_name))
FROM SYSAdmin.dbo.Upload_Stats
WHERE a_db_type = 'DATABASE'

--This WHILE statement will re-send the same email multiple times to account for different cluster nodes.
SET @x = @totalNodes --CLUSTER WHILE LOOP START
SET @z = 1
WHILE @z <= @x
BEGIN
	--If more than 1 node exists, assume this is a cluster.
	--Changing the host_name sent to DBDepot to duplicate every email for all Nodes.
	IF @totalNodes > 1
	BEGIN
	  SET @host_name = LTRIM(RTRIM((SELECT a_host_name FROM #temp_ClusterNodes where id = @z)))
	END
			
	--Formating time/date to be used for Header/Footer details.
	SELECT @date = CONVERT(VARCHAR(50),GETDATE(),112)
	SELECT @time = REPLACE(CONVERT(VARCHAR(15),GETDATE(),108),':','')

	--Creating Host Record
	SELECT TOP 1 @record_host = 
		'exec dbateam.stats.upload_host_stats ( -' + CHAR(13)+CHAR(10)
		+ '  a_host_name=>''' + ISNULL((@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_domain_name=>'''  + ISNULL(RTRIM(a_domain_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_os_type=>''' + ISNULL(RTRIM(a_os_type),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_os_version=>''' + ISNULL(RTRIM(a_os_version),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_uptime_days=>''' + ISNULL(RTRIM(a_uptime_days),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_time_zone=>''' + ISNULL(RTRIM(a_time_zone),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_client_name=>''' + ISNULL(RTRIM(@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_method=>''email'', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_to=>''' + ISNULL(RTRIM(@mail_recipients),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_version=>''' + ISNULL(@mon_sql_version,'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_refresh_yn=>''N'' -' + CHAR(13)+CHAR(10)
		+ ');' 
		+ CHAR(13)+CHAR(10)
		+ CHAR(13)+CHAR(10)
	FROM SYSAdmin.dbo.Upload_Stats
	WHERE a_db_type = 'DATABASE'            

	--Creating Instance Record
	SELECT TOP 1 @record_instance =
		'exec dbateam.stats.upload_instance_stats ( -' + CHAR(13)+CHAR(10)
		+ '  a_host_name=>''' + ISNULL((@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_domain_name=>'''  + ISNULL(RTRIM(a_domain_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_instance_name=>''' + ISNULL(RTRIM(a_instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_files_mb=>' + ISNULL(RTRIM(a_files_mb),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_segments_mb=>' + ISNULL(RTRIM(a_segments_mb),'') + ', -' + CHAR(13)+CHAR(10)		
		+ '   a_log_mode=>''' + ISNULL(RTRIM(a_log_mode),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_db_version=>''' + ISNULL(RTRIM(a_db_version),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_listener_port=>' + ISNULL(RTRIM(a_listener_port),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_startup_time=>TO_DATE(''' + ISNULL(RTRIM(a_startup_time),'') + ''',''yyyy-mm-dd hh24:mi:ss''), -' + CHAR(13)+CHAR(10)
		+ '   a_num_schemas=>' + ISNULL(RTRIM(a_num_schemas),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_num_tables=>' + ISNULL(RTRIM(a_num_tables),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_num_objects=>' + ISNULL(RTRIM(a_num_objects),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_db_type=>''' + ISNULL(RTRIM(a_db_type),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_vendor=>''' + ISNULL(RTRIM(a_vendor),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_client_name=>''' + ISNULL(RTRIM(@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_method=>''email'', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_to=>''' + ISNULL(RTRIM(@mail_recipients),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_version=>''' + ISNULL(@mon_sql_version,'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_refresh_yn=>''N'' -'  + CHAR(13)+CHAR(10)
		+ ');'
		+ '  ' + CHAR(13)+CHAR(10)
		+ '  ' + CHAR(13)+CHAR(10)
	FROM SYSAdmin.dbo.Upload_Stats
	WHERE a_db_type = 'DATABASE'  

	SET @record_database = ''

		--Inserting all database records into @email_body
		DECLARE email_cursor CURSOR FOR  
			SELECT 
				a_domain_name, a_instance_name, a_db_type, 
				a_files_mb, a_segments_mb, a_num_schemas, 
				a_num_tables, a_num_objects
			FROM SYSAdmin.dbo.Upload_Stats 
			WHERE 
				(((a_instance_name IS NOT NULL) AND (a_host_name IS NOT NULL))
				OR 
				((a_instance_name IS NOT NULL) AND (@totalNodes > 1)))
				AND a_db_type = 'USER_DATABASE'
			ORDER BY a_instance_name DESC
		OPEN email_cursor
		FETCH NEXT FROM email_cursor INTO
			@2, @3, @4, @5, @6, @7, @8, @9

		WHILE( @@FETCH_STATUS = 0 )
		BEGIN

			SET @2 = ISNULL(@2,'')
			SET @3 = ISNULL(@3,'')
			SET @4 = ISNULL(@4,'')
			SET @5 = ISNULL(@5,'')
			SET @6 = ISNULL(@6,'')
			SET @7 = ISNULL(@7,'')
			SET @8 = ISNULL(@8,'')
			SET @9 = ISNULL(@9,'')

			--Removing brackets [] from database name
			SET @3 = REPLACE(@3,'[','')
			SET @3 = REPLACE(@3,']','')

			--Email formatting for Database Info
			SELECT @record_database_temp =
			'exec dbateam.stats.upload_instance_stats ( -' + CHAR(13)+CHAR(10)
			+ '  a_host_name=>''' + RTRIM(@host_name) + ''', -' + CHAR(13)+CHAR(10)
			+ '   a_domain_name=>'''  + RTRIM(@2) + ''', -' + CHAR(13)+CHAR(10)
			+ '   a_instance_name=>''' + RTRIM(@instance_a_instance_name) + ''', -' + CHAR(13)+CHAR(10)
			+ '   a_user_db_name=>''' + RTRIM(@3) + ''', -' + CHAR(13)+CHAR(10)
			+ '   a_db_type=>''' + RTRIM(@4) + ''', -' + CHAR(13)+CHAR(10)
			+ '   a_files_mb=>' + RTRIM(@5) + ', -' + CHAR(13)+CHAR(10)
			+ '   a_segments_mb=>' + RTRIM(@6) + ', -' + CHAR(13)+CHAR(10)
			+ '   a_num_schemas=>' + RTRIM(@7) + ', -' + CHAR(13)+CHAR(10)
			+ '   a_num_tables=>' + RTRIM(@8) + ', -' + CHAR(13)+CHAR(10)
			+ '   a_num_objects=>' + RTRIM(@9) + ' -' + CHAR(13)+CHAR(10)
			+ ');'
			+ '  ' + CHAR(13)+CHAR(10)
			+ '  ' + CHAR(13)+CHAR(10)
					
			SET @record_database = @record_database + @record_database_temp

		FETCH NEXT FROM email_cursor into
			@2, @3, @4, @5, @6, @7, @8, @9

		END
		CLOSE email_cursor
		DEALLOCATE email_cursor

	--Generate a random number for use with the email subject and header.
	SELECT @random_number = ROUND(((@random_upper - @random_lower -1) * RAND() + @random_lower), 0)

	--Header
	SELECT @email_header = ('upload_stats.' + @host_name + '.' + @instance_a_instance_name + '.' + RTRIM(CONVERT(VARCHAR(10),@random_number)) + '.' + @date + '.' + @time + '.sql')

	--Footer
	SELECT @email_footer = 'REM end ' + RTRIM(@email_header)

	--Inserting the Header into @email_body
	SELECT @email_body = 'REM begin '+ RTRIM(@email_header)
	+ '  ' + CHAR(13)+CHAR(10)
	+ '  ' + CHAR(13)+CHAR(10)

	SELECT @email_body = @email_body + @record_host
	SELECT @email_body = @email_body + @record_instance
	SELECT @email_body = @email_body + @record_database
	SELECT @email_body = @email_body + @email_footer

	IF (@email_body IS NULL) OR 
		(@email_header IS NULL) OR 
		(@mail_recipients IS NULL) 
	BEGIN
	RAISERROR ('NULL value passed to xp_smtp_sendmail, SYSAdmin.dbo.usp_EmailDBDepot aborting.', 18, 1) WITH NOWAIT
	END ELSE
	BEGIN
		IF @error = 0
		BEGIN
			EXEC msdb.dbo.sp_send_dbmail
				@profile_name = @mail_profile_name,
				@recipients = @mail_recipients,
				@copy_recipients = @mail_copy_recipients,
				@blind_copy_recipients = @mail_blind_copy_recipients,
				@subject = @email_header,
				@body = @email_body;	
		END
	END
			
	SET @z = @z + 1

END --CLUSTER WHILE LOOP END
DROP TABLE #temp_ClusterNodes
GO
/****** Object:  StoredProcedure [dbo].[usp_failed_dba_jobs_report]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [dbo].[usp_failed_dba_jobs_report] as
-------SQL 2012 EDITION v06_2012----------------------------
----------------------------------------------------------------
-- Description:  This SQL Code reports job/step failures based
-- on a data and time range.
-- The report built can be emailed and/or logged to the eventlog.
--
-- Execute the following command to view all settings for this script:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_failed_dba_jobs_report'
--
-- 	mail_profile_name = SQL DBMail profile name to be used by this script.
--	mail_recipients = Email Address to send messages TO
----------------------------------------------------------------

SET NOCOUNT ON
DECLARE @client varchar(100)
SELECT @client = isnull([variable2],'client_name_missing') FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc'

DECLARE
	@SERVER_NAME varchar(100),
	@subject2 as varchar(150),
	@RPT_BEGIN_DATE datetime,
	@NUMBER_OF_DAYS int,
	@email_body nvarchar(4000),
	@event_message AS varchar(255),
	@current_date char(20),
	@x int,
	@z int,
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000);

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_failed_dba_jobs_report') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG (proc_name) VALUES ('usp_failed_dba_jobs_report')
	END

	SELECT  
		@mail_profile_name = mail_profile_name,
		@mail_recipients = mail_recipients,
		@mail_copy_recipients = mail_copy_recipients,
		@mail_blind_copy_recipients = mail_blind_copy_recipients
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_failed_dba_jobs_report';
				
--Create DateTime for header
SET @current_date = (SELECT CONVERT( varchar(20), GETDATE(), 120)  )

-- Get the host name
SET @SERVER_NAME = @@servername
SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))
SET @subject2 = 'MON_SQL : ' + @client + ' : ' + @SERVER_NAME + ' Failed DBA Job Report'

-- Set the number of days to go back to calculate the report begin date
set @NUMBER_OF_DAYS = -1

-- Get the report begin date and time
set @RPT_BEGIN_DATE = dateadd(day,@NUMBER_OF_DAYS,getdate())

-- Create temporary table to hold report
IF object_id('tempdb..#temp_text', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #temp_text
END
ELSE
BEGIN
	CREATE TABLE #temp_text (
		id INT NOT NULL IDENTITY (1, 1),
		email_text CHAR(75)
	)
END

-- Generate report heading and column headers
	Set @email_body = 'Job ' + CHAR(39) + '*Failed DBA Jobs Report' + CHAR(39) + ' :v06_2012'
	Set @email_body = @email_body + CHAR(13) + CHAR(10)+ '  ' + CHAR(13) + CHAR(10)
	Set @email_body = @email_body + 'Failed DBA Jobs Report  -  Began Executing ' + @current_date + CHAR(13)+CHAR(10)
	Set @email_body = @email_body + '--------------------------------------------------------------------------'
	Set @email_body = @email_body + CHAR(13)+CHAR(10)

	Set @email_body = @email_body + 'DBA Jobs failed on host ' + @SERVER_NAME + ' since ' +
                               cast(@RPT_BEGIN_DATE as char(20))
	Set @email_body = @email_body + CHAR(13)+CHAR(10)
	Set @email_body = @email_body + ' ' + CHAR(13)+CHAR(10)
	Set @email_body = @email_body + '  Job                                                  Failed Datetime    '
	Set @email_body = @email_body + CHAR(13)+CHAR(10)
	Set @email_body = @email_body + '  ------------------------------                       -------------------'
	Set @email_body = @email_body + CHAR(13)+CHAR(10)	
	
-- Generate report detail for failed jobs/steps
insert into #temp_text (email_text)
	select substring(j.name,1,53)+

		substring('                                                    ',
		len(j.name),52) + 

		-- Calculate fail datetime
		-- Add Run Duration Seconds
		cast(dateadd(ss,
		cast(substring(cast(last_run_duration + 1000000 as char(7)),6,2) as int),

		-- Add Run Duration Minutes
		dateadd(mi,
		cast(substring(cast(last_run_duration + 1000000 as char(7)),4,2) as int),

		-- Add Run Duration Hours
		dateadd(hh,
		cast(substring(cast(last_run_duration + 1000000 as char(7)),2,2) as int),

		-- Add Start Time Seconds
		dateadd(ss,
		cast(substring(cast(last_run_time + 1000000 as char(7)),6,2) as int),

		-- Add Start Time Minutes
		dateadd(mi,
		cast(substring(cast(last_run_time + 1000000 as char(7)),4,2) as int),

		-- Add Start Time Hours
		dateadd(hh,
		cast(substring(cast(last_run_time + 1000000 as char(7)),2,2) as int),
		convert(datetime,cast (last_run_date as char(8))))
		))))) as char(19))

	from 
		msdb.dbo.sysjobs j, msdb.dbo.sysjobservers js, msdb.dbo.syscategories s
	where  
		j.job_id = js.job_id 
		AND j.category_id = s.category_id 
		AND js.last_run_outcome = 0 
		AND enabled = 1 
		AND (j.name like '*%' OR s.name = 'Database Maintenance')
		AND (Dateadd(dd,@NUMBER_OF_DAYS,getdate()) < 
			   -- Calculate fail datetime

               -- Add Run Duration Seconds
               dateadd(ss,
               cast(substring(cast(last_run_duration + 1000000 as char(7)),6,2) as int),

               -- Add Run Duration Minutes
               dateadd(mi,
               cast(substring(cast(last_run_duration + 1000000 as char(7)),4,2) as int),

               -- Add Run Duration Hours
               dateadd(hh,
               cast(substring(cast(last_run_duration + 1000000 as char(7)),2,2) as int),

               -- Add Start Time Seconds
               dateadd(ss,
               cast(substring(cast(last_run_time + 1000000 as char(7)),6,2) as int),

               -- Add Start Time Minutes
               dateadd(mi,
               cast(substring(cast(last_run_time + 1000000 as char(7)),4,2) as int),

               -- Add Start Time Hours
               dateadd(hh,
               cast(substring(cast(last_run_time + 1000000 as char(7)),2,2) as int),
               convert(datetime,cast (last_run_date as char(8))))

               ))))))

-- Email report to DBA distribution list
If (select count (*) from #temp_text) > 0
BEGIN

	set @x = (select count (*) from #temp_text)
	set @z = 1
	WHILE @z <= @x
	BEGIN
	   SET @email_body = @email_body + '  ' + RTRIM((SELECT email_text FROM #temp_text where id = @z))
	   SET @email_body = @email_body + CHAR(13)+CHAR(10)
	   SET @z = @z + 1
	END

	EXEC msdb.dbo.sp_send_dbmail
		@profile_name = @mail_profile_name,
		@recipients = @mail_recipients,
		@copy_recipients = @mail_copy_recipients,
		@blind_copy_recipients = @mail_blind_copy_recipients,
		@subject = @subject2,
		@body = @email_body

	
--------------------------------------------------------------------------------
--Log DB Problem to Windows Application Event Log
--------------------------------------------------------------------------------

		--Truncating the servername down to varchar(45) because of space issues within the Eventlog.
		SET @SERVER_NAME = CAST(@SERVER_NAME AS VARCHAR(45))
		SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))

		SET @event_message = '; ' + @SERVER_NAME + '; FAILED DBA JOB; ' + (CONVERT(VARCHAR(20),getdate(),120))  + '; (FAILED DBA JOB Warning)'

		--Generates Windows App Event log message & SQL Log Error
		EXEC master.dbo.xp_logevent 77021, @event_message, WARNING
		
		/* --Generates Windows App Event log message & SQL Log Error & Returns the error to the client.
		RAISERROR (
			@event_message, -- Message text.
			0, -- Severity 0 to 18,
			1   -- State
		) 
		WITH LOG
		*/

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

END

-- Drop temporary table
DROP TABLE #temp_text
GO
/****** Object:  StoredProcedure [dbo].[usp_Get_Database_Object_Permissions]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE proc [dbo].[usp_Get_Database_Object_Permissions]
	

-------SQL 2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes captures the most recent Database Object Permissions
-- for the specified instance name and stores all data on [Database_Object_Permissions] table
-- The procedure takes the following parameters:
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC [usp_Get_Database_Object_Permissions]
----------------------------------------------------------------
--12/30/2011 v2011 - SMurua - Initial creation
----------------------------------------------------------------

as

set nocount on
declare @instance_name varchar (255), @query varchar(8000), @database varchar(100)
declare @fetch_status1 int, @fetch_status2 int, @execsql nvarchar(4000)
CREATE table #protect (Owner varchar(255), Object varchar(255), Grantee varchar(255), Grantor varchar(255), ProtectType varchar(255), Action varchar(255), [Column] varchar(255))
CREATE table #tmp (id int)
CREATE table #tmp2 (id int)

SELECT @instance_name = @@SERVERNAME
			DECLARE C_2 CURSOR FOR  
			select '[' + name + ']' 
			from master.dbo.sysdatabases 
			where name not in (select s.name 
								from master.dbo.sysdatabases s 
								where databaseproperty(s.name, 'IsInStandBy') = 1 
								or databaseproperty(s.name, 'IsInRecovery') = 1
								or databaseproperty(s.name, 'IsReadOnly') = 1 
								or databaseproperty(s.name, 'IsInLoad') = 1 
								or databaseproperty(s.name, 'IsOffline') = 1 
								or databaseproperty(s.name, 'IsSingleUser') = 1 
								or databaseproperty(s.name, 'IsSuspect') = 1) 
			and name not in (SELECT A.name
								FROM sys.databases A
									INNER JOIN sys.database_mirroring B
									ON A.database_id=B.database_id
								WHERE A.database_id > 4
								AND B.mirroring_state is not null)
			and name not in ('tempdb', 'SYSAdmin', 'master', 'msdb', 'SYSWarehouse')
			order by name
	
	
	OPEN C_2

	FETCH NEXT FROM C_2 INTO @database
	set @fetch_status2 = @@fetch_status
	WHILE (@fetch_status2 <> -1)
		BEGIN
			
			truncate table #protect
			truncate table #tmp
			truncate table #tmp2
			
			begin try		
         
				set @query = 'EXEC ' + @database + '.dbo.sp_helprotect'
				insert into #protect
				exec (@query)

				insert into MON_SQL_CFG_Database_Object_Permissions
				select distinct @instance_name as [instancename],
						@database as [databasename],
						[Owner],
						Object, 
						Grantee, 
						Grantor, 
						ProtectType, 
						Action, 
						GETDATE() as [updated_date]
				from #protect

			end try
			
		begin catch
		end catch
		
		
			FETCH NEXT FROM C_2 INTO @database
			set @fetch_status2 = @@fetch_status
		END
		
	CLOSE C_2
	DEALLOCATE C_2	
	drop table #protect
	drop table #tmp
	drop table #tmp2


GO
/****** Object:  StoredProcedure [dbo].[usp_Get_Database_UserAccounts]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE proc [dbo].[usp_Get_Database_UserAccounts]

---------SQL 2000-2005-2008-2012 EDITION  v2011------------------------
------------------------------------------------------------------
---- This procedure executes captures the most recent Database Users Accounts
---- for the specified instance name and stores all data on [Database_UserAccounts] table
---- The procedure takes the following parameters:
-------------------------------------------------------------------
---- Sample Execution:
---- EXEC [usp_Get_Database_UserAccounts]
------------------------------------------------------------------
----12/30/2011 v2011 - SMurua - Initial creation
------------------------------------------------------------------

as

set nocount on
declare @instancename varchar(255), @query varchar(8000), @value varchar(8000), @database varchar(100), @database2 varchar(100), @database5 varchar(100)
declare @fetch_status1 int, @fetch_status2 int, @execsql nvarchar(4000), @SQLCollation varchar(100)
CREATE table #users1 (user_name varchar(150), login_name varchar(150), user_active_status bit)
CREATE table #users2 (user_name varchar(150), login_name varchar(150), user_active_status bit)

select @instancename = @@SERVERNAME

DECLARE @SQLVersion varchar(20)
CREATE TABLE #VTable (IndexID int, ProductName varchar(200), INTValue varchar(200), CharValue varchar(200))
INSERT INTO #VTable exec master.dbo.xp_msver
SELECT @SQLVersion = CharValue from #VTable where ProductName = 'ProductVersion'
drop table #VTable


      ------------------for each database
IF SUBSTRING(@SQLVersion,1,1) = '8'
      BEGIN      
      DECLARE C_2 CURSOR FAST_FORWARD FOR
            select '[' + sm.name + ']'
            from master.dbo.sysdatabases sm
            where sm.name not in (select s.name 
                                          from master.dbo.sysdatabases s 
                                          where databaseproperty(s.name, 'IsInStandBy') = 1 
                                          or databaseproperty(s.name, 'IsInRecovery') = 1
                                          or databaseproperty(s.name, 'IsReadOnly') = 1 
                                          or databaseproperty(s.name, 'IsInLoad') = 1 
                                          or databaseproperty(s.name, 'IsOffline') = 1 
                                          or databaseproperty(s.name, 'IsSingleUser') = 1 
                                          or databaseproperty(s.name, 'IsSuspect') = 1)
            and sm.name not in ('master', 'model', 'msdb', 'tempdb')
            order by sm.name
      END
ELSE
      BEGIN
      DECLARE C_2 CURSOR FAST_FORWARD FOR
            select '[' + sm.name + ']'
            from master.dbo.sysdatabases sm
            where sm.name not in (select s.name 
                                          from master.dbo.sysdatabases s 
                                          where databaseproperty(s.name, 'IsInStandBy') = 1 
                                          or databaseproperty(s.name, 'IsInRecovery') = 1
                                          or databaseproperty(s.name, 'IsReadOnly') = 1 
                                          or databaseproperty(s.name, 'IsInLoad') = 1 
                                          or databaseproperty(s.name, 'IsOffline') = 1 
                                          or databaseproperty(s.name, 'IsSingleUser') = 1 
                                          or databaseproperty(s.name, 'IsSuspect') = 1)
            and sm.name not in (SELECT A.name
                                                FROM sys.databases A
                                                      INNER JOIN sys.database_mirroring B
                                                      ON A.database_id=B.database_id
                                                WHERE A.database_id > 4
                                                AND B.mirroring_state is not null)
            and sm.name not in ('master', 'model', 'msdb', 'tempdb')
            order by sm.name
      END

      OPEN C_2

      FETCH NEXT FROM C_2 INTO @database5
      set @fetch_status2 = @@fetch_status
      WHILE (@fetch_status2 <> -1)
            BEGIN
                  set @database2 = REPLACE(@database5, '[', '')
                          set @database2 = REPLACE(@database2, ']', '')

                  SELECT @SQLCollation = convert(varchar(100), DATABASEPROPERTYEX('' + @database2 + '', 'Collation'))
                  
                  truncate table #users1
                  truncate table #users2
                        
                          IF SUBSTRING(@SQLVersion,1,1) = '8'
                              BEGIN
                                          set @execsql = N'use ' + @database5 + '
                                          select u.name as [user_name],
                                                sp.name as [login_name],
                                                u.hasdbaccess as [user_active_status]
                                          from sysusers u inner join master..sysxlogins sp
                                          on sp.sid = u.sid
                                          where u.issqlrole = 0
                                          and u.isapprole = 0'
                                          
                                          insert into #users1
                                          exec sp_executesql @execsql


                                          set @execsql = N'use ' + @database5 + '
                                          select u1.name as [user_name],
                                                u1.name as [login_name],
                                                u1.hasdbaccess as [user_active_status] 
                                          from sysusers u1
                                          where u1.issqlrole = 0
                                          and u1.isapprole = 0
                                          and u1.name not in (select u.name COLLATE ' + @SQLCollation + '
                                                                        from sysusers u inner join master..sysxlogins sp
                                                                        on sp.sid = u.sid
                                                                        where u.issqlrole = 0
                                                                        and u.isapprole = 0)'
                                    
                                          
                                          
                                          insert into #users2
                                          exec sp_executesql @execsql
               
                              END
                              
                              

                          IF SUBSTRING(@SQLVersion,1,1) = '1' or SUBSTRING(@SQLVersion,1,1) > '8'
                              BEGIN
                                          set @execsql = N'use ' + @database5 + '
                                          SELECT DISTINCT
                                          u.name AS [Name],
                                          ISNULL(suser_sname(u.sid),N'''') AS [Login],
                                          CAST(CASE dp.state WHEN N''G'' THEN 1 WHEN ''W'' THEN 1 ELSE 0 END AS bit) AS [user_active_status] 
                                          FROM sys.database_principals AS u
                                          LEFT OUTER JOIN sys.database_permissions AS dp ON dp.grantee_principal_id = u.principal_id
                                          LEFT OUTER JOIN sys.certificates AS cert ON cert.sid = u.sid
                                          LEFT OUTER JOIN sys.asymmetric_keys AS ak ON ak.sid = u.sid
                                          WHERE
                                          (u.type in (''U'', ''S'', ''G'', ''C'', ''K''))'
                                          
                                          insert into #users1
                                          exec sp_executesql @execsql


               
                              END


							  INSERT INTO [MON_SQL_CFG_Database_UserAccounts]
                              select @instancename as [instance_name]
                                ,@database5 as [database_name]
                                ,[user_name]
                                ,[login_name]
                                ,[user_active_status]
                                ,getdate() as [updated_date]                              
                              from #users1
                              
                              union
                              
                              select @instancename as [instance_name]
                                ,@database5 as [database_name]
                                ,[user_name]
                                ,[login_name]
                                ,[user_active_status]
                                ,getdate() as [updated_date]                              
                              from #users2



                  FETCH NEXT FROM C_2 INTO @database5
                  set @fetch_status2 = @@fetch_status
            END
            
      CLOSE C_2
      DEALLOCATE C_2    

drop table #users1
drop table #users2

GO
/****** Object:  StoredProcedure [dbo].[usp_Get_Database_Users_Roles]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

create proc [dbo].[usp_Get_Database_Users_Roles]

-----------SQL 2000-2005-2008-2012 EDITION  v2012------------------------
--------------------------------------------------------------------
------ This procedure executes captures the most recent Database Users Roles
------ for the specified instance name and stores all data on [Database_Users_Roles] table
------ The procedure takes the following parameters:
---------------------------------------------------------------------
------ Sample Execution:
------ EXEC [usp_Get_Database_Users_Roles]
--------------------------------------------------------------------
------12/30/2011 v2011 - SMurua - Initial creation
--------------------------------------------------------------------

as

SET NOCOUNT ON
declare @instancename varchar(255), @query varchar(8000), @value varchar(8000), @database varchar(100)
declare @fetch_status1 int, @fetch_status2 int, @execsql nvarchar(4000)
CREATE table #rolemembers ( role varchar(256), memberuid int)
CREATE table #members ( member varchar(256), groupuid int)

select @instancename = @@SERVERNAME

DECLARE @SQLVersion varchar(20)
CREATE TABLE #VTable (IndexID int, ProductName varchar(200), INTValue varchar(200), CharValue varchar(200))
INSERT INTO #VTable exec master.dbo.xp_msver
SELECT @SQLVersion = CharValue from #VTable where ProductName = 'ProductVersion'
drop table #VTable


      ------------------for each database
IF SUBSTRING(@SQLVersion,1,1) = '8'
      BEGIN      
      DECLARE C_2 CURSOR FAST_FORWARD FOR  
            select '[' + sm.name + ']'
            from master.dbo.sysdatabases sm
            where sm.name not in (select s.name 
                                          from master.dbo.sysdatabases s 
                                          where databaseproperty(s.name, 'IsInStandBy') = 1 
                                          or databaseproperty(s.name, 'IsInRecovery') = 1
                                          or databaseproperty(s.name, 'IsReadOnly') = 1 
                                          or databaseproperty(s.name, 'IsInLoad') = 1 
                                          or databaseproperty(s.name, 'IsOffline') = 1 
                                          or databaseproperty(s.name, 'IsSingleUser') = 1 
                                          or databaseproperty(s.name, 'IsSuspect') = 1)
            and sm.name not in ('model', 'tempdb')
            order by sm.name
      END
ELSE
      BEGIN
      DECLARE C_2 CURSOR FAST_FORWARD FOR  
            select '[' + sm.name + ']'
            from master.dbo.sysdatabases sm
            where sm.name not in (select s.name 
                                          from master.dbo.sysdatabases s 
                                          where databaseproperty(s.name, 'IsInStandBy') = 1 
                                          or databaseproperty(s.name, 'IsInRecovery') = 1
                                          or databaseproperty(s.name, 'IsReadOnly') = 1 
                                          or databaseproperty(s.name, 'IsInLoad') = 1 
                                          or databaseproperty(s.name, 'IsOffline') = 1 
                                          or databaseproperty(s.name, 'IsSingleUser') = 1 
                                          or databaseproperty(s.name, 'IsSuspect') = 1)
            and sm.name not in (SELECT A.name
                                                FROM sys.databases A
                                                      INNER JOIN sys.database_mirroring B
                                                      ON A.database_id=B.database_id
                                                WHERE A.database_id > 4
                                                AND B.mirroring_state is not null)
            and sm.name not in ('model', 'tempdb')
            order by sm.name
      END

      OPEN C_2

      FETCH NEXT FROM C_2 INTO @database
      set @fetch_status2 = @@fetch_status
      WHILE (@fetch_status2 <> -1)
            BEGIN
                  
                  truncate table #rolemembers
                  truncate table #members
                  
                  set @query = 'SELECT DISTINCT [name] as role, uid as memberuid FROM ' + @database + '..sysusers WHERE issqlrole = 1'
                  insert into #rolemembers
                  exec (@query)

                 if SUBSTRING(@SQLVersion,1,1) = '1' or SUBSTRING(@SQLVersion,1,1) > '8'
                              begin
                                    set @execsql = N'CREATE TABLE #tmp_role_member_ids (id int not null, role_id int null, sub_role_id int null, generation int null)
                                          declare @generation int
                                          set @generation = 0
                                          INSERT INTO #tmp_role_member_ids (id) 
                                          SELECT rl.principal_id AS [ID]
                                          FROM ' + @database + '.sys.database_principals AS rl
                                          WHERE (rl.type = ''R'')
                                          UPDATE #tmp_role_member_ids SET role_id = id, sub_role_id = id, generation=@generation

                                          WHILE ( 1=1 )
                                          BEGIN

                                                INSERT INTO #tmp_role_member_ids (id, role_id, sub_role_id, generation)
                                                      SELECT a.member_principal_id, b.role_id, a.role_principal_id, @generation + 1
                                                            FROM ' + @database + '.sys.database_role_members AS a INNER JOIN #tmp_role_member_ids AS b
                                                            ON a.role_principal_id = b.id
                                                            WHERE b.generation = @generation
                                                if @@ROWCOUNT <= 0
                                                      break
                                                set @generation = @generation + 1
                                          END

                                          DELETE #tmp_role_member_ids WHERE id in (SELECT rl.principal_id AS [ID]
                                          FROM ' + @database + '.sys.database_principals AS rl
                                          WHERE (rl.type = ''R''))
                                          UPDATE #tmp_role_member_ids SET generation = 0;

                                          INSERT INTO #tmp_role_member_ids (id, role_id, generation) 
                                                SELECT distinct id, role_id, 1 FROM #tmp_role_member_ids
                                          DELETE #tmp_role_member_ids WHERE generation = 0

                                          SELECT u.name AS member, m.role_id as groupuid FROM
                                          ' + @database + '.sys.database_principals AS rl INNER JOIN #tmp_role_member_ids AS m ON m.role_id=rl.principal_id INNER JOIN ' + @database + '.sys.database_principals AS u ON u.principal_id = m.id WHERE (rl.type = ''R'')
                                          ORDER BY u.Name ASC
                                          drop table #tmp_role_member_ids'
                                    
                                          
                                          insert into #members
                                          exec sp_executesql @execsql
                                                
                                                
                                      set @execsql = N'select u1.name as member, u.uid as groupid
from ' + @database + '.sys.sysusers u 
 inner join ' + @database + '.sys.database_role_members rm 
 on u.uid = rm.role_principal_id 
 inner join ' + @database + '.sys.sysusers u1 
 on u1.uid = rm.member_principal_id'
                                                                                                
                                          insert into #members
                                          exec sp_executesql @execsql
                 
               
                              end

                  if SUBSTRING(@SQLVersion,1,1) = '8'
                              begin
                                      set @query = 'SELECT su.name as member, sm.groupuid as groupuid FROM ' + @database + '..sysusers as su , ' + @database + '..sysmembers as sm where sm.memberuid = su.uid'
                                      insert into #members
                                      exec (@query)
                              end 

                  set @query = 'SELECT [name] from ' + @database + '..sysusers WHERE uid not in (select memberuid from ' + @database + '..sysmembers) and issqlrole = 0'
                  insert into #members (member)
                  exec (@query)
      
                  insert into [dbo].[MON_SQL_CFG_Database_Users_Roles]
                  select distinct @instancename as [instancename],
                              @database as [databasename],
                              member as [username], 
                              role as [rolename],
                              GETDATE() as [updated_date]
                  from #members left outer join #rolemembers on (groupuid = memberuid)
                  order by role

                  FETCH NEXT FROM C_2 INTO @database
                  set @fetch_status2 = @@fetch_status
            END
            
      CLOSE C_2
      DEALLOCATE C_2    

      drop table #rolemembers
      drop table #members
      

GO
/****** Object:  StoredProcedure [dbo].[usp_GetDatabase_File_Information]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_GetDatabase_File_Information] AS
-------SQL 2000-2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes captures the current database file information
-- The procedure don't receive any parameter
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC SYSAdmin..[usp_GetDatabase_File_Information]
----------------------------------------------------------------
--02/28/2012 v2012 - SMurua - Initial creation
----------------------------------------------------------------

INSERT INTO [MON_SQL_CFG_Database_File_Information]
select 
		@@SERVERNAME as instance_name,
		a.name as database_name, 
		b.name as logical_name, 
		(b.size*8)/1024 as initial_size_mb,
		case
			when (b.growth*8)/1024 <> 0 then (b.growth*8)/1024
			else null
		end as auto_growth_mb,		
		case 
			when (b.growth*8)/1024 = 0 then b.growth
			else null
		end as auto_growth_percentage,
		substring(b.filename,1,len(b.filename)-charindex('\',reverse(rtrim(ltrim(b.filename))))) as file_path,
		RIGHT(ltrim(rtrim(b.filename)), charindex('\',reverse(rtrim(ltrim(b.filename)))) -1) as file_name,
		GETDATE() as updated_date
from master..sysdatabases a inner join master..sysaltfiles b on a.dbid = b.dbid
order by a.name

GO
/****** Object:  StoredProcedure [dbo].[usp_GetDatabase_Stats]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_GetDatabase_Stats] AS
-------SQL 2000-2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes captures the current Instance and Host name
-- The procedure don't receive any parameter
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC SYSAdmin..[usp_GetDatabase_Stats]
----------------------------------------------------------------
--02/25/2012 v2012 - SMurua - Initial creation
----------------------------------------------------------------

declare @instance_name varchar(50)
SELECT @instance_name = @@SERVERNAME
DECLARE @SQLVersion varchar(20)
CREATE TABLE #VTable (IndexID int, ProductName varchar(200), INTValue varchar(200), CharValue varchar(200))
INSERT INTO #VTable exec master.dbo.xp_msver
SELECT @SQLVersion = CharValue from #VTable where ProductName = 'ProductVersion'
drop table #VTable
IF SUBSTRING(@SQLVersion,1,1) = '8'
	BEGIN
	
		INSERT INTO [MON_SQL_CFG_Database_Stats]
		SELECT @instance_name as instance_name 
				,[DBName] as database_name
				,CASE 
					WHEN (SELECT US.[a_segments_mb] FROM [Upload_Stats] US WHERE US.[a_instance_name] = [DBGrowthRate].DBName) > (SELECT US.[a_files_mb] FROM [Upload_Stats] US WHERE US.[a_instance_name] = [DBGrowthRate].DBName) THEN (SELECT US.[a_segments_mb] FROM [Upload_Stats] US WHERE US.[a_instance_name] = [DBGrowthRate].DBName)
					ELSE (SELECT US.[a_files_mb] FROM [Upload_Stats] US WHERE US.[a_instance_name] = [DBGrowthRate].DBName) 
				END AS [allocated_mb]
				
				,(SELECT US.[a_segments_mb] FROM [Upload_Stats] US WHERE US.[a_instance_name] = [DBGrowthRate].DBName) as [used_mb]
				,[NumPages] as [pages]
				,[GrowthAmt] as [growth]
				,(select convert(varchar(50), SUSER_SNAME(SD.sid)) from master..sysdatabases SD where '[' + SD.name + ']' COLLATE SQL_Latin1_General_CP1_CI_AS = [DBGrowthRate].DBName COLLATE SQL_Latin1_General_CP1_CI_AS) as [owner]
				,(select convert(varchar(50), SD.cmptlevel) from master..sysdatabases SD where '[' + SD.name + ']' COLLATE SQL_Latin1_General_CP1_CI_AS = [DBGrowthRate].DBName COLLATE SQL_Latin1_General_CP1_CI_AS) as [compatibility_level]
				,(select convert(varchar(50), DATABASEPROPERTYEX(SD.name, 'RECOVERY')) from master..sysdatabases SD where '[' + SD.name + ']' COLLATE SQL_Latin1_General_CP1_CI_AS = [DBGrowthRate].DBName COLLATE SQL_Latin1_General_CP1_CI_AS) as [recovery_model]
				,(select SD.crdate from master..sysdatabases SD where '[' + SD.name + ']' COLLATE SQL_Latin1_General_CP1_CI_AS = [DBGrowthRate].DBName COLLATE SQL_Latin1_General_CP1_CI_AS) as [created_date]
				, GETDATE() as updated_date
		  FROM [DBGrowthRate]
		  WHERE [DBName] IN (select '[' + name + ']' COLLATE SQL_Latin1_General_CP1_CI_AS from master..sysdatabases)
			AND EXISTS(				
					SELECT DS.[DBName]	
					FROM [DBGrowthRate] DS	
					GROUP BY DS.[DBName]
					HAVING DS.[DBName] = [DBGrowthRate].[DBName]	
					AND [DBGrowthRate].[MetricDate] BETWEEN (MAX(DS.[MetricDate]) - 0.5) AND (MAX(DS.[MetricDate]) + 0.5)	
					)
	
	END
	
	
IF SUBSTRING(@SQLVersion,1,1) = '1' or SUBSTRING(@SQLVersion,1,1) > '8'
	BEGIN
		INSERT INTO [MON_SQL_CFG_Database_Stats]
		SELECT @instance_name as instance_name 
				,[DBName] as database_name
				,CASE 
					WHEN (SELECT US.[a_segments_mb] FROM [Upload_Stats] US WHERE US.[a_instance_name] = [DBGrowthRate].DBName) > (SELECT US.[a_files_mb] FROM [Upload_Stats] US WHERE US.[a_instance_name] = [DBGrowthRate].DBName) THEN (SELECT US.[a_segments_mb] FROM [Upload_Stats] US WHERE US.[a_instance_name] = [DBGrowthRate].DBName)
					ELSE (SELECT US.[a_files_mb] FROM [Upload_Stats] US WHERE US.[a_instance_name] = [DBGrowthRate].DBName) 
				END AS [allocated_mb]
				,(SELECT US.[a_segments_mb] FROM [Upload_Stats] US WHERE US.[a_instance_name] = [DBGrowthRate].DBName) as [used_mb]
				,[NumPages] as [pages]
				,[GrowthAmt] as [growth]
				,(select convert(varchar(50), SUSER_SNAME(SD.sid)) from sys.sysdatabases SD where '[' + SD.name + ']' COLLATE SQL_Latin1_General_CP1_CI_AS = [DBGrowthRate].DBName COLLATE SQL_Latin1_General_CP1_CI_AS) as [owner]
				,(select convert(varchar(50), SD.cmptlevel) from sys.sysdatabases SD where '[' + SD.name + ']' COLLATE SQL_Latin1_General_CP1_CI_AS = [DBGrowthRate].DBName COLLATE SQL_Latin1_General_CP1_CI_AS) as [compatibility_level]
				,(select convert(varchar(50), DATABASEPROPERTYEX(SD.name, 'RECOVERY')) from sys.sysdatabases SD where '[' + SD.name + ']' COLLATE SQL_Latin1_General_CP1_CI_AS = [DBGrowthRate].DBName COLLATE SQL_Latin1_General_CP1_CI_AS) as [recovery_model]
				,(select SD.crdate from sys.sysdatabases SD where '[' + SD.name + ']' COLLATE SQL_Latin1_General_CP1_CI_AS = [DBGrowthRate].DBName COLLATE SQL_Latin1_General_CP1_CI_AS) as [db_created_date]
				, GETDATE() as updated_date
		  FROM [DBGrowthRate]
		  WHERE [DBName] IN (select '[' + name + ']' COLLATE SQL_Latin1_General_CP1_CI_AS from master.sys.sysdatabases)
			AND EXISTS(				
					SELECT DS.[DBName]	
					FROM [DBGrowthRate] DS	
					GROUP BY DS.[DBName]
					HAVING DS.[DBName] = [DBGrowthRate].[DBName]	
					AND [DBGrowthRate].[MetricDate] BETWEEN (MAX(DS.[MetricDate]) - 0.5) AND (MAX(DS.[MetricDate]) + 0.5)	
					)
	
	END


GO
/****** Object:  StoredProcedure [dbo].[usp_GetInstanceConfiguration]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_GetInstanceConfiguration] AS
-------SQL 2000-2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes captures the current Instance and Host name
-- The procedure don't receive any parameter
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC SYSAdmin..[usp_GetInstanceConfiguration]
----------------------------------------------------------------
--02/25/2012 v2012 - SMurua - Initial creation
----------------------------------------------------------------

declare @host_name varchar(50), @instance_name varchar(50), @is_clustered bit, @out varchar(50), @config_value int

SELECT @instance_name = @@SERVERNAME
SELECT @is_clustered = convert(bit, SERVERPROPERTY('IsClustered'))
declare @db_version varchar(50)

DECLARE @SQLVersion varchar(20)
CREATE TABLE #VTable (IndexID int, ProductName varchar(200), INTValue varchar(200), CharValue varchar(200))
INSERT INTO #VTable exec master.dbo.xp_msver
SELECT @SQLVersion = CharValue from #VTable where ProductName = 'ProductVersion'
drop table #VTable


IF SUBSTRING(@SQLVersion,1,1) = '8'
	BEGIN
		CREATE TABLE #temptable1(
					[name] [varchar](200) NULL,
					[minimum] [int] NULL,
					[maximum] [int] NULL,
					[config_value] [int] NULL,
					[run_value] [int] NULL,
				)

		insert into #temptable1
		exec sp_configure

		if exists (select config_value from #temptable1 where name = 'xp_cmdshell')
			begin
				select @config_value = config_value from #temptable1 where name = 'xp_cmdshell'

				EXEC sp_configure 'show advanced options', 1
				RECONFIGURE WITH OVERRIDE;
		
				EXEC sp_configure 'xp_cmdshell', 1
				RECONFIGURE WITH OVERRIDE;
			end
	END

IF SUBSTRING(@SQLVersion,1,1) = '1' or SUBSTRING(@SQLVersion,1,1) > '8'
	BEGIN
		if exists (select value_in_use from sys.configurations where name = 'xp_cmdshell')
			begin
				select @config_value = convert(int,value_in_use) from sys.configurations where name = 'xp_cmdshell'
				EXEC sp_configure 'show advanced options', 1
				RECONFIGURE WITH OVERRIDE;
		
				EXEC sp_configure 'xp_cmdshell', 1
				RECONFIGURE WITH OVERRIDE;
			end
	END


CREATE TABLE #temptable(
			[value] [varchar](8000) NULL
		)
                
set @out = 'exec master..xp_cmdshell ''systeminfo'''

insert into #temptable
exec (@out)

select @host_name = ltrim(rtrim(substring(value,28,LEN(value))))
from #temptable 
where value like '%Host Name%'

drop table #temptable

SELECT @db_version = CONVERT(VARCHAR,SERVERPROPERTY('productversion')) + 
CASE CONVERT(VARCHAR,SERVERPROPERTY('edition'))
	WHEN 'Express Edition' THEN ' EX'
	WHEN 'Workgroup Edition' THEN ' WG'
	WHEN 'Standard Edition' THEN ' SE' 
	WHEN 'Enterprise Edition' THEN ' EE' 
	WHEN 'Standard Edition (64-bit)' THEN ' SE X64' 
	WHEN 'Enterprise Edition (64-bit)' THEN ' EE X64' 
	ELSE ' EVL'
END	

SELECT @db_version = @db_version + ' ' + CONVERT(VARCHAR,(SERVERPROPERTY('productlevel')))

if @is_clustered = 0
	begin
		INSERT INTO MON_SQL_CFG_Instance
				   ([instance_name]
				   ,[host_name],
				   instance_version,
				   is_clustered
				   ,[updated_date])
			 VALUES
				   (@instance_name
				   ,@host_name
				   ,@db_version,
				   @is_clustered
				   ,GETDATE())
	end

if @is_clustered = 1 
	begin
		if (SUBSTRING(@SQLVersion,1,1) = '1' or SUBSTRING(@SQLVersion,1,1) > '8')
			begin
				INSERT INTO MON_SQL_CFG_Instance
				SELECT @instance_name as [instance_name],
					NodeName as [host_name],
					@db_version as instance_version,
					null as life_cycle,
					@is_clustered as is_clustered,
					GETDATE() as [updated_date]
				FROM sys.dm_os_cluster_nodes
			end
		else
		begin
			INSERT INTO MON_SQL_CFG_Instance
				   ([instance_name]
				   ,[host_name],
				   instance_version,
				   is_clustered
				   ,[updated_date])
			 VALUES
				   (@instance_name
				   ,@host_name
				   ,@db_version,
				   @is_clustered
				   ,GETDATE())
		end
	
	end

IF SUBSTRING(@SQLVersion,1,1) = '8'
	BEGIN
	
	CREATE TABLE ##sp_configure (name varchar(200), minimum varchar(20), maximun varchar(200), config_value varchar(200), run_value varchar(200))
	INSERT INTO ##sp_configure exec master.dbo.sp_configure

	INSERT INTO [MON_SQL_CFG_InstanceConfigurationSettings]
	  SELECT @instance_name as [instance_name],
			convert(varchar(50), name) as [parameter_name],
			convert(varchar(50), run_value) as [parameter_value],
			GETDATE() as [updated_date]
	  FROM ##sp_configure
	  
	  drop table ##sp_configure
	  
	  UPDATE MON_SQL_CFG_InstanceConfigurationSettings
		SET parameter_value = @config_value
		WHERE parameter_name = 'xp_cmdshell'
	
	END
	
	
IF SUBSTRING(@SQLVersion,1,1) = '1' or SUBSTRING(@SQLVersion,1,1) > '8'
	BEGIN
	
		  INSERT INTO [MON_SQL_CFG_InstanceConfigurationSettings]
		  SELECT @instance_name as [instance_name],
				convert(varchar(50), name) as [parameter_name],
				convert(varchar(50), value) as [parameter_value],
				GETDATE() as [updated_date]
		   FROM master.sys.configurations
		   WHERE name IN(
		   'min server memory (MB)',
		   'max server memory (MB)',
		   'Agent XPs',
		   'SQL Mail XPs',
		   'Database Mail XPs',
		   'SMO and DMO XPs',
		   'Ole Automation Procedures',
		   'Web Assistant Procedures',
		   'xp_cmdshell',
		   'Ad Hoc Distributed Queries',
		   'Replication XPs',
		   'network packet size',
		   'show advanced options',
		   'remote login timeout',
		   'remote query timeout',
		   'awe enabled',
		   'clr enabled')
		   
			UPDATE MON_SQL_CFG_InstanceConfigurationSettings
			SET parameter_value = @config_value
			WHERE parameter_name = 'xp_cmdshell'

	END
   
 
IF @config_value = 0
BEGIN
	EXEC sp_configure 'show advanced options', 1
	RECONFIGURE WITH OVERRIDE;
		
	EXEC sp_configure 'xp_cmdshell', 0
	RECONFIGURE WITH OVERRIDE;
END
   
IF SUBSTRING(@SQLVersion,1,1) = '8'
BEGIN
	drop table #temptable1
END

GO
/****** Object:  StoredProcedure [dbo].[usp_GetInstanceLogonAccounts]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE [dbo].[usp_GetInstanceLogonAccounts] AS
-------SQL 2000-2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes captures all active logon accounts on current instance
-- The procedure don't receive any parameter
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC SYSAdmin..[[usp_GetInstanceLogonAccounts]]
----------------------------------------------------------------
--02/26/2012 v2012 - SMurua - Initial creation
----------------------------------------------------------------

declare @instance_name varchar(50)

SELECT @instance_name = @@SERVERNAME

DECLARE @SQLVersion varchar(20)
CREATE TABLE #Table (IndexID int, ProductName varchar(200), INTValue varchar(200), CharValue varchar(200))
INSERT INTO #Table exec master.dbo.xp_msver
SELECT @SQLVersion = CharValue from #Table where ProductName = 'ProductVersion'
drop table #Table

IF SUBSTRING(@SQLVersion,1,1) = '8'
	BEGIN
		insert into [MON_SQL_CFG_LogonAccounts]
		select @instance_name as [instance_name],
			name as [logon_account_name],
			case
				when status = 10 then 1
				else 0
			end as [logon_active_status],
			case
				when isntgroup = 0 and isntuser = 0 then 'SQL_LOGIN'
				when isntgroup = 1 and isntuser = 0 then 'WINDOWS_GROUP'
				when isntgroup = 0 and isntuser = 1 then 'WINDOWS_LOGIN'
				end as [logon_user_type],
			getdate() as [updated_date]
		from [master].[dbo].[syslogins]
		where name is not null
		
	END
	
	
	
IF SUBSTRING(@SQLVersion,1,1) = '1' or SUBSTRING(@SQLVersion,1,1) > '8'
	BEGIN
		insert into [MON_SQL_CFG_LogonAccounts]
		select @instance_name as [instance_name],
			name as [logon_account_name], 
			case 
				when is_disabled = 0 then 1
				else 0
				end as [logon_active_status],
			type_desc as [logon_user_type],
			getdate() as [updated_date]
		from master.sys.server_principals
		where principal_id > 100
		and type in ('S', 'G', 'U')
		order by name
		
		
		INSERT INTO [SYSAdmin].[dbo].[MON_SQL_CFG_LogonAccounts]
           ([instance_name]
           ,[logon_account_name]
           ,[logon_active_status]
           ,[logon_user_type]
           ,[updated_date])
		 VALUES
           (@instance_name
           ,'sa'
           ,1
           ,'SQL_LOGIN'
           ,getdate())

	END
 



GO
/****** Object:  StoredProcedure [dbo].[usp_GetJob_Information]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE [dbo].[usp_GetJob_Information] AS
-------SQL 2005-2008-2012 EDITION  v2012------------------------
------------------------------------------------------------------
---- This procedure executes captures the latest job information
---- The procedure don't receive any parameter
-------------------------------------------------------------------
---- Sample Execution:
---- EXEC SYSAdmin..[usp_GetJob_Information]
------------------------------------------------------------------
----02/25/2012 v2012 - SMurua - Initial creation
------------------------------------------------------------------

		INSERT INTO MON_SQL_CFG_Job_Information
		SELECT @@servername as instance_name
			, [sJOB].[name] AS job_name
			,(select ISNULL(suser_sname(owner_sid), N'''') FROM msdb.dbo.sysjobs sj WHERE sj.job_id = [sJOB].job_id) as job_owner
			, [sJOB].[description] AS job_description
			, [sJOB].[enabled] 
			, [sJOB].[date_created] AS job_created_date
			, [sJOB].[date_modified] AS job_last_modified_date
		    
		    
			,(
			select 
				[Occurrence] + '' +[Recurrence] + [Frequency]
			from
			(
				SELECT 
					[schedule_uid] AS [ScheduleID]
				    
					, CASE [freq_type]
						WHEN 1 THEN 'One Time'
						WHEN 4 THEN 'Daily'
						WHEN 8 THEN 'Weekly'
						WHEN 16 THEN 'Monthly'
						WHEN 32 THEN 'Monthly - Relative to Frequency Interval'
						WHEN 64 THEN 'Start automatically when SQL Server Agent starts'
						WHEN 128 THEN 'Start whenever the CPUs become idle'
					  END [Occurrence]
					, CASE [freq_type]
						WHEN 4 THEN ' every ' + CAST([freq_interval] AS VARCHAR(3)) + ' day(s)'
						WHEN 8 THEN ' every ' + CAST([freq_recurrence_factor] AS VARCHAR(3)) 
									+ ' week(s) on '
									+ CASE WHEN [freq_interval] & 1 = 1 THEN 'Sunday' ELSE '' END
									+ CASE WHEN [freq_interval] & 2 = 2 THEN ', Monday' ELSE '' END
									+ CASE WHEN [freq_interval] & 4 = 4 THEN ', Tuesday' ELSE '' END
									+ CASE WHEN [freq_interval] & 8 = 8 THEN ', Wednesday' ELSE '' END
									+ CASE WHEN [freq_interval] & 16 = 16 THEN ', Thursday' ELSE '' END
									+ CASE WHEN [freq_interval] & 32 = 32 THEN ', Friday' ELSE '' END
									+ CASE WHEN [freq_interval] & 64 = 64 THEN ', Saturday' ELSE '' END
						WHEN 16 THEN ' on Day ' + CAST([freq_interval] AS VARCHAR(3)) 
									 + ' of every '
									 + CAST([freq_recurrence_factor] AS VARCHAR(3)) + ' month(s)'
						WHEN 32 THEN ' on '
									 + CASE [freq_relative_interval]
										WHEN 1 THEN 'First'
										WHEN 2 THEN 'Second'
										WHEN 4 THEN 'Third'
										WHEN 8 THEN 'Fourth'
										WHEN 16 THEN 'Last'
									   END
									 + ' ' 
									 + CASE [freq_interval]
										WHEN 1 THEN 'Sunday'
										WHEN 2 THEN 'Monday'
										WHEN 3 THEN 'Tuesday'
										WHEN 4 THEN 'Wednesday'
										WHEN 5 THEN 'Thursday'
										WHEN 6 THEN 'Friday'
										WHEN 7 THEN 'Saturday'
										WHEN 8 THEN 'Day'
										WHEN 9 THEN 'Weekday'
										WHEN 10 THEN 'Weekend day'
									   END
									 + ' of every ' + CAST([freq_recurrence_factor] AS VARCHAR(3)) 
									 + ' month(s)'
					  END AS [Recurrence]
					, CASE [freq_subday_type]
						WHEN 1 THEN ' once at ' 
									+ STUFF(
								 STUFF(RIGHT('000000' + CAST([active_start_time] AS VARCHAR(6)), 6)
												, 3, 0, ':')
											, 6, 0, ':')
						WHEN 2 THEN ' every ' 
									+ CAST([freq_subday_interval] AS VARCHAR(3)) + ' Second(s) between ' 
									+ STUFF(
								   STUFF(RIGHT('000000' + CAST([active_start_time] AS VARCHAR(6)), 6)
												, 3, 0, ':')
											, 6, 0, ':')
									+ ' & ' 
									+ STUFF(
									STUFF(RIGHT('000000' + CAST([active_end_time] AS VARCHAR(6)), 6)
												, 3, 0, ':')
											, 6, 0, ':')
						WHEN 4 THEN ' every ' 
									+ CAST([freq_subday_interval] AS VARCHAR(3)) + ' Minute(s) between ' 
									+ STUFF(
								   STUFF(RIGHT('000000' + CAST([active_start_time] AS VARCHAR(6)), 6)
												, 3, 0, ':')
											, 6, 0, ':')
									+ ' & ' 
									+ STUFF(
									STUFF(RIGHT('000000' + CAST([active_end_time] AS VARCHAR(6)), 6)
												, 3, 0, ':')
											, 6, 0, ':')
						WHEN 8 THEN ' every ' 
									+ CAST([freq_subday_interval] AS VARCHAR(3)) + ' Hour(s) between ' 
									+ STUFF(
									STUFF(RIGHT('000000' + CAST([active_start_time] AS VARCHAR(6)), 6)
												, 3, 0, ':')
											, 6, 0, ':')
									+ ' & ' 
									+ STUFF(
									STUFF(RIGHT('000000' + CAST([active_end_time] AS VARCHAR(6)), 6)
												, 3, 0, ':')
											, 6, 0, ':')
					  END [Frequency]
				FROM [msdb].[dbo].[sysschedules]
			) data
			where data.[ScheduleID] = [sSCH].[schedule_uid]) as job_schedule
		   
			,getdate() as updated_date
		    
		FROM
			[msdb].[dbo].[sysjobs] AS [sJOB]
			LEFT JOIN [msdb].[sys].[servers] AS [sSVR]
				ON [sJOB].[originating_server_id] = [sSVR].[server_id]
			LEFT JOIN [msdb].[dbo].[syscategories] AS [sCAT]
				ON [sJOB].[category_id] = [sCAT].[category_id]
			LEFT JOIN [msdb].[dbo].[sysjobsteps] AS [sJSTP]
				ON [sJOB].[job_id] = [sJSTP].[job_id]
				AND [sJOB].[start_step_id] = [sJSTP].[step_id]
			LEFT JOIN [msdb].[sys].[database_principals] AS [sDBP]
				ON [sJOB].[owner_sid] = [sDBP].[sid]
			LEFT JOIN [msdb].[dbo].[sysjobschedules] AS [sJOBSCH]
				ON [sJOB].[job_id] = [sJOBSCH].[job_id]
			LEFT JOIN [msdb].[dbo].[sysschedules] AS [sSCH]
				ON [sJOBSCH].[schedule_id] = [sSCH].[schedule_id]
		ORDER BY job_name
	
	


GO
/****** Object:  StoredProcedure [dbo].[usp_GetJob_Status]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_GetJob_Status] AS
-------SQL 2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes captures the latest job status
-- The procedure don't receive any parameter
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC SYSAdmin..[usp_GetJob_Status]
----------------------------------------------------------------
--02/25/2012 v2012 - SMurua - Initial creation
----------------------------------------------------------------

INSERT INTO [MON_SQL_CFG_Job_Status]
SELECT @@servername as instance_name,
job_name,
job_run_date,
job_duration,
job_status,
job_message,
updated_date

FROM
(
SELECT [sJOB].[name] AS job_name
    , CASE 
        WHEN [sJOBH].[run_date] IS NULL OR [sJOBH].[run_time] IS NULL THEN NULL
        ELSE CAST(
                CAST([sJOBH].[run_date] AS CHAR(8))
                + ' ' 
                + STUFF(
                    STUFF(RIGHT('000000' + CAST([sJOBH].[run_time] AS VARCHAR(6)),  6)
                        , 3, 0, ':')
                    , 6, 0, ':')
                AS DATETIME)
      END AS job_run_date
      
       , STUFF(
            STUFF(RIGHT('000000' + CAST([sJOBH].[run_duration] AS VARCHAR(6)),  6)
                , 3, 0, ':')
            , 6, 0, ':') 
        AS job_duration
        
        
    , CASE [sJOBH].[run_status]
        WHEN 0 THEN 'Failed'
        WHEN 1 THEN 'Succeeded'
        WHEN 2 THEN 'Retry'
        WHEN 3 THEN 'Canceled'
        WHEN 4 THEN 'Running' -- In Progress
      END AS job_status
   
    , [sJOBH].[message] AS job_message
    , GETDATE() as updated_date
FROM 
    [msdb].[dbo].[sysjobs] AS [sJOB]
    LEFT JOIN (
                SELECT
                    [job_id]
                    , MIN([next_run_date]) AS [NextRunDate]
                    , MIN([next_run_time]) AS [NextRunTime]
                FROM [msdb].[dbo].[sysjobschedules]
                GROUP BY [job_id]
            ) AS [sJOBSCH]
        ON [sJOB].[job_id] = [sJOBSCH].[job_id]
    LEFT JOIN (
                SELECT 
                    [job_id]
                    , [run_date]
                    , [run_time]
                    , [run_status]
                    , [run_duration]
                    , [message]
                    , ROW_NUMBER() OVER (
                                            PARTITION BY [job_id] 
                                            ORDER BY [run_date] DESC, [run_time] DESC
                      ) AS RowNumber
                FROM [msdb].[dbo].[sysjobhistory]
                WHERE [step_id] = 0
            ) AS [sJOBH]
        ON [sJOB].[job_id] = [sJOBH].[job_id]
) DATA 
WHERE NOT EXISTS(SELECT [instance_name]
      ,[job_name]
      ,[job_run_date]
      ,[job_duration]
      ,[job_status]
      ,[job_message]
  FROM [SYSAdmin].[dbo].[MON_SQL_CFG_Job_Status]
  WHERE [instance_name] = @@servername
      AND [job_name] = DATA.job_name COLLATE SQL_Latin1_General_CP1_CI_AS
      AND [job_run_date] = DATA.job_run_date 
      AND [job_duration] = DATA.job_duration
      AND [job_status] = DATA.job_status COLLATE SQL_Latin1_General_CP1_CI_AS
      AND [job_message] = DATA.job_message COLLATE SQL_Latin1_General_CP1_CI_AS)
AND DATA.job_name COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT [job_name] FROM [dbo].[MON_SQL_CFG_Job_Information] WHERE job_schedule like '%every 1 Minute%')
ORDER BY job_name

DELETE FROM [dbo].[MON_SQL_CFG_Job_Status]
WHERE job_run_date is null
and job_duration is null
and job_status is null


GO
/****** Object:  StoredProcedure [dbo].[usp_GetLogonAccountsServerPermissions]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO




CREATE PROCEDURE [dbo].[usp_GetLogonAccountsServerPermissions] AS
-------SQL 2000-2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes captures all active logon accounts serer permissions on current instance
-- The procedure don't receive any parameter
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC SYSAdmin..[usp_GetLogonAccountsServerPermissions]
----------------------------------------------------------------
--03/02/2012 v2012 - SMurua - Initial creation
----------------------------------------------------------------

declare @instance_name varchar(50)

SELECT @instance_name = @@SERVERNAME

DECLARE @SQLVersion varchar(20)
CREATE TABLE #Table2 (IndexID int, ProductName varchar(200), INTValue varchar(200), CharValue varchar(200))
INSERT INTO #Table2 exec master.dbo.xp_msver
SELECT @SQLVersion = CharValue from #Table2 where ProductName = 'ProductVersion'
IF SUBSTRING(@SQLVersion,1,1) = '1' or SUBSTRING(@SQLVersion,1,1) > '8'
	BEGIN
	
			insert into [MON_SQL_CFG_LogonAccountsServerPermissions]
			SELECT @instance_name as [instance_name],
				grantee_principal.name as [logon_account_name],
				permission_name as [permission], 
				state_desc as [permission_type], 
				grantee_principal.type_desc as [login_type],
				getdate() as [updated_date]
			FROM sys.server_permissions AS prmssn
				  INNER JOIN sys.server_principals AS grantor_principal ON grantor_principal.principal_id = prmssn.grantor_principal_id
				  INNER JOIN sys.server_principals AS grantee_principal ON grantee_principal.principal_id = prmssn.grantee_principal_id
			WHERE prmssn.class = 100

	END
drop table #Table2




GO
/****** Object:  StoredProcedure [dbo].[usp_GetLogonAccountsServerRoles]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO





CREATE PROCEDURE [dbo].[usp_GetLogonAccountsServerRoles] AS
-------SQL 2000-2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes captures all active logon accounts server roles on current instance
-- The procedure don't receive any parameter
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC SYSAdmin..[usp_GetLogonAccountsServerRoles]
----------------------------------------------------------------
--03/02/2012 v2012 - SMurua - Initial creation
----------------------------------------------------------------

declare @instance_name varchar(50)

SELECT @instance_name = @@SERVERNAME

CREATE TABLE #temp(
		[ServerRole] [varchar](100) NULL,
		[MemberName] [varchar](100) NULL,
		[MemberSID] [varchar](500) NULL
	)
	
declare @out varchar(8000), @query varchar(8000)
set nocount on

	-------------------sysadmin-----------------
	set @query = 'EXEC sp_helpsrvrolemember ''sysadmin'''
	insert into #temp
	exec (@query)
	---------------------------------------------

	-------------------securityadmin-----------------
	set @query = 'EXEC sp_helpsrvrolemember ''securityadmin'''
	insert into #temp
	exec (@query)
	---------------------------------------------

	-------------------serveradmin-----------------
	set @query = 'EXEC sp_helpsrvrolemember ''serveradmin'''
	insert into #temp
	exec (@query)
	---------------------------------------------

	-------------------setupadmin-----------------
	set @query = 'EXEC sp_helpsrvrolemember ''setupadmin'''
	insert into #temp
	exec (@query)
	---------------------------------------------

	-------------------processadmin-----------------
	set @query = 'EXEC sp_helpsrvrolemember ''processadmin'''
	insert into #temp
	exec (@query)
	---------------------------------------------

	-------------------diskadmin-----------------
	set @query = 'EXEC sp_helpsrvrolemember ''diskadmin'''
	insert into #temp
	exec (@query)
	---------------------------------------------

	-------------------dbcreator-----------------
	set @query = 'EXEC sp_helpsrvrolemember ''dbcreator'''
	insert into #temp
	exec (@query)
	---------------------------------------------

	-------------------bulkadmin-----------------
	set @query = 'EXEC sp_helpsrvrolemember ''bulkadmin'''
	insert into #temp
	exec (@query)
	---------------------------------------------
	
	insert into [dbo].[MON_SQL_CFG_LogonAccountsServerRoles]
	select @instance_name as [instance_name],
		[ServerRole] as [server_role],
		[MemberName] as [logon_account_name],
		getdate() as [updated_date]
	from #temp

	drop table #temp
 




GO
/****** Object:  StoredProcedure [dbo].[usp_job_history_archive]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE PROCEDURE [dbo].[usp_job_history_archive] AS
BEGIN  
-------SQL 2012 EDITION  v06_2012----------------------------
----------------------------------------------------------------
--	Description:  This SQL Code creates an archived copy of all
--	job history into SYSAdmin.dbo.MON_SQL_JobHistory.  The 
--	MON_SQL_JobHistory table is used by SYSAdmin.dbo.usp_long_running_jobs
--	to calculate job averages and determine if a job has exceeded its
--	average runtime.
--	No emails or alerts are generated by this proc.
----------------------------------------------------------------
----------------------------------------------------------------
SET NOCOUNT ON  

--Create archive table to hold job history
IF object_id('SYSAdmin.dbo.MON_SQL_JobHistory', 'U') IS NULL
BEGIN
	CREATE TABLE SYSAdmin.dbo.MON_SQL_JobHistory  
	(
		history_id INT IDENTITY (1,1) PRIMARY KEY,
		Insert_DT DATETIME DEFAULT (getdate()),
		instance_id INT,				-- system job step history unique identifier
		job_id UNIQUEIDENTIFIER,		-- Unique ID of the job
		job_nm sysname,					-- Name of the job
		last_run_date DATETIME,			-- Date AND time the job last started EXECution
		duration INT,					-- time job run in seconds
		long_running_flag CHAR(1),		-- flag to identify if long running this time 
		email_sent_flag CHAR(1)
	) 
END

DECLARE @instance_id INT
	
SELECT @instance_id = MAX(instance_id) FROM SYSAdmin.dbo.MON_SQL_JobHistory  
SET @instance_id = ISNULL(@instance_id,0) 

INSERT INTO SYSAdmin.dbo.MON_SQL_JobHistory 
	(
		instance_id, 
		job_id , 
		job_nm, 
		last_run_date, 
		duration
	) 
	SELECT      
		soh.instance_id,
		sj.job_id, 
		sj.name,
		CAST 
			( 
				LEFT(CAST(run_date AS VARCHAR(8)),4) + '/' +
				SUBSTRING(CAST(run_date AS VARCHAR(8)), 5,2) + '/' + 
                RIGHT(CAST(run_date AS VARCHAR(8)), 2)    + ' ' +    
                CAST( ((run_time/10000) %100) AS VARCHAR ) + ':' +  
				CAST( ((run_time/100) %100) AS VARCHAR ) + ':' + 
                CAST(  (run_time %100) AS VARCHAR 
			) AS DATETIME), 
                ( run_duration % 100 )+					-- seconds 
                (((run_duration/100) % 100 ) * 60) +	-- minutes in seconds 
                (((run_duration/10000) % 100 ) * 3600)	-- hours in seconds 
	FROM msdb..sysjobs sj 
		INNER JOIN msdb..sysjobhistory soh 
			ON 
				soh.job_id = sj.job_id 
	WHERE 
			soh.instance_id > @instance_id
			AND soh.run_status = 1	-- Successful Jobs 
			AND soh.step_id = 0		-- Job Outcome step ONLY.
	ORDER BY sj.name

END 
GO
/****** Object:  StoredProcedure [dbo].[usp_long_running_jobs]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_long_running_jobs] AS
-------SQL 2012 EDITION  v06_2012----------------------------
----------------------------------------------------------------
--	Description:  This SQL Code reports on long running jobs that
--	have exceeded their average runtime by 200%.  
--	All Jobs with an average runtime of less than 60 minutes use
--	a default average runtime of 60 minutes.
--	
--	If no job history has been recorded and the job has been executing
--	longer than 9 hours, an alert will be raised.
--
--	The report built can be emailed and/or logged to the eventlog.
-- 
--	Execute the following command to view all settings for this script:
--	SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_long_running_jobs'
--
--	mail_server = SMTP Server used for mail alerts 
--	mail_from = Email Address messages are sent FROM
--	mail_recipients = Email Address to send messages TO
--
--	variable1 = Minimum allowed runtime before processing a job.  (In seconds DEFAULT = 3200)
--	variable2 = Multiplier used against runtime
--	variable3 = Maximum time allowed before reporting on jobs that currently have 
--		NO history recorded (In seconds DEFAULT = 32400)
----------------------------------------------------------------
SET NOCOUNT ON
DECLARE @client varchar(100)
SELECT @client = isnull([variable2],'client_name_missing') FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc'
		
DECLARE
    @email_body VARCHAR(8000),
    @email_temp VARCHAR(150),
    @subject2 VARCHAR (150),
	@SERVER_NAME VARCHAR(100), 
    @current_date CHAR(20),	
    @event_message VARCHAR(255),   
	@flag_exists INT, 
	@minid INT, 
	@maxid INT, 
	@job_id UNIQUEIDENTIFIER,                 
	@job_nm VARCHAR(128),
	@avgduration INT,
	@real_avgduration INT,
	@display_avgduration VARCHAR(10),
	@display_runtime VARCHAR(10),
	@duration_sec INT,
	@hours INT,
	@minutes INT,
	@minutes_text CHAR(2),	
	@last_run_date DATETIME,
	@x int,
	@z int,
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000),
	@check_min_runtime INT,
	@check_max_runtime_without_history INT,
	@check_runtime_multiplier DECIMAL(4,2);

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_long_running_jobs') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG (proc_name,variable1,variable2,variable3) VALUES ('usp_long_running_jobs',3600,2,32400)
	END
		
	SELECT  
		@mail_profile_name = mail_profile_name,
		@mail_recipients = mail_recipients,
		@mail_copy_recipients = mail_copy_recipients,
		@mail_blind_copy_recipients = mail_blind_copy_recipients,
		@check_min_runtime = CONVERT(INT, variable1),
		@check_runtime_multiplier = CONVERT(DECIMAL(4,2), variable2),
		@check_max_runtime_without_history = CONVERT(INT, variable3)
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_long_running_jobs';

IF (ISNUMERIC(@check_min_runtime) = 0) SET @check_min_runtime = 3600
IF (ISNUMERIC(@check_runtime_multiplier) = 0) SET @check_runtime_multiplier = 2
IF (ISNUMERIC(@check_max_runtime_without_history) = 0) SET @check_max_runtime_without_history = 32400

-- All jobs listed within this table will NOT be alerted on.
IF object_id('SYSAdmin.dbo.MON_SQL_Jobs_Config', 'U') IS NULL
BEGIN
	CREATE TABLE SYSAdmin.dbo.MON_SQL_Jobs_Config  
	(
		job_nm VARCHAR(128) -- Name of the job to ignore
	) 
END
	
-- Create temporary table to hold report
IF object_id('tempdb..#temp_text', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #temp_text
END
ELSE
BEGIN
	CREATE TABLE #temp_text (
		id INT NOT NULL IDENTITY (1, 1),
		email_text VARCHAR(75),
		job_name VARCHAR(128)
	)
END
	
IF object_id('tempdb..#allactivejobs', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #allactivejobs
END
ELSE
BEGIN
	CREATE TABLE #allactivejobs
		(
			job_id UNIQUEIDENTIFIER, 
			job_nm VARCHAR(128), 
			last_run_date DATETIME,
			duration INT, 
			tid INT IDENTITY(1,1) 
		)  			
END
  
-- Create table to hold job information
IF object_id('tempdb..#enum_job', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #enum_job
END
ELSE
BEGIN
	CREATE TABLE #enum_job 
		(
			Job_ID UNIQUEIDENTIFIER,
			Last_Run_Date INT NULL,
			Last_Run_Time INT NULL,
			Next_Run_Date INT NULL,
			Next_Run_Time INT NULL,
			Next_Run_Schedule_ID INT NULL,
			Requested_To_Run INT NULL,
			Request_Source INT NULL,
			Request_Source_ID VARCHAR(100) NULL,
			Running INT NULL,
			Current_Step INT NULL,
			Current_Retry_Attempt INT NULL,
			State INT NULL
		) 			
END

-- create a table to hold job_id and the job_id in hex character format
IF object_id('tempdb..##jobs', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE ##jobs
END
ELSE
BEGIN
	CREATE TABLE ##jobs 
		(
			job_id UNIQUEIDENTIFIER ,
			job_id_char VARCHAR(100)
		)			
END

SET @current_date = (SELECT CONVERT( varchar(20), GETDATE(), 120)  )

-- Get the host name
SET @SERVER_NAME = @@servername
SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))
select @subject2 = 'MON_SQL : ' + @client + ' : ' + @SERVER_NAME + ' Long Running Jobs'

-- Generate report heading and column headers
Set @email_body = 'Job ' + CHAR(39) + 'Long Running Jobs Report' + CHAR(39) + ' : v06_2012'
Set @email_body = @email_body + CHAR(13) + CHAR(10)+ '  ' + CHAR(13) + CHAR(10)
Set @email_body = @email_body + 'Long Running Jobs Report : Executed on ' + @current_date + CHAR(13)+CHAR(10)
Set @email_body = @email_body + '--------------------------------------------------------------------------'
Set @email_body = @email_body + CHAR(13)+CHAR(10)
Set @email_body = @email_body + 'Jobs that have exceeded their average runtime on host ' + @SERVER_NAME

Set @email_body = @email_body + CHAR(13)+CHAR(10) + '  '
Set @email_body = @email_body + CHAR(13)+CHAR(10)
Set @email_body = @email_body + '                                                       Current  /  Average'
Set @email_body = @email_body + CHAR(13)+CHAR(10)
Set @email_body = @email_body + '  Job                                                      Runtime (hh:mm)'
Set @email_body = @email_body + CHAR(13)+CHAR(10)
Set @email_body = @email_body + '  ------------------------------                       -------------------'
Set @email_body = @email_body + CHAR(13)+CHAR(10)
	
-- Get a list of jobs 	
INSERT INTO #enum_job
EXECUTE master.dbo.xp_sqlagent_enum_jobs 1, 'garbage' -- doesn't seem to matter what you put here

-- Populate the #jobs table with job_id's and their hex character representation
INSERT INTO ##jobs
SELECT Job_ID, SYSAdmin.dbo.fn_hex_to_char(Job_ID,16) FROM #enum_job

SET @flag_exists = 0 
  
INSERT INTO #allactivejobs 
	(
		job_id, 
		job_nm, 
		last_run_date, 
		duration
	) 
	SELECT
		b.job_id,  
		c.name AS job_nm,
		CONVERT(VARCHAR, a.login_time, 121) AS job_start_time,
		CONVERT(INT,(DATEDIFF(ss, a.login_time, GETDATE()))) AS duration
	FROM master.dbo.sysprocesses a
		JOIN ##jobs b
			ON SUBSTRING(a.program_name,32,32)= b.job_id_char
		JOIN msdb.dbo.sysjobs c
			ON b.job_id = c.job_id
	 WHERE 
		login_time < DATEADD(ss,-1,GETDATE())--Display all currently running jobs
		AND c.name COLLATE SQL_Latin1_General_CP1_CI_AS 
				NOT IN (SELECT job_nm COLLATE SQL_Latin1_General_CP1_CI_AS 
						FROM SYSAdmin.dbo.MON_SQL_Jobs_Config)
	 ORDER BY job_nm	 
	 
SELECT 
	@minid = MIN(tid), @maxid = MAX(tid) 
FROM #allactivejobs

	WHILE (@minid <= @maxid) 
	BEGIN  
	SELECT  
		@job_id = job_id,        
		@job_nm = job_nm,          
		@duration_sec = duration,  
		@last_run_date = last_run_date 
	FROM #allactivejobs
	WHERE tid = @minid 

-- exclude checks the first 2 times 
IF ( (
		SELECT COUNT(history_id) 
		FROM SYSAdmin.dbo.MON_SQL_JobHistory 
		WHERE 
			job_id = @job_id ) >= 2 ) 
 BEGIN 
    -- define average run time 
    SELECT 
		@avgduration = AVG(duration)     
	FROM SYSAdmin.dbo.MON_SQL_JobHistory 
    WHERE job_id = @job_id
 
    SET @avgduration = ISNULL(@avgduration,1)
    SET @real_avgduration = @avgduration
	IF @avgduration < @check_min_runtime SET @avgduration = @check_min_runtime

	--IF Average job execution time is GREATER THAN 60 minutes
	--Then alert if over 200% execution time. 
    IF (@avgduration >= @check_min_runtime) 
     BEGIN 
      IF (@duration_sec > (@avgduration * @check_runtime_multiplier)  ) 
       BEGIN
		SET @email_temp = LTRIM(RTRIM(@job_nm))
		
		SET @minutes = (@duration_sec / 60)
		SET @hours = FLOOR(@minutes /60)
		SET @minutes =  @minutes - (@hours * 60)
		SELECT @minutes_text =
			CASE LEN(CONVERT(VARCHAR,@minutes))
				WHEN 1 THEN '0' + CONVERT(VARCHAR,@minutes)
				ELSE CONVERT(VARCHAR,@minutes)
			END
		SET @display_runtime = CONVERT(VARCHAR,@hours) + ':' + @minutes_text

		SET @minutes = (@real_avgduration / 60)
		SET @hours = FLOOR(@minutes /60)
		SET @minutes =  @minutes - (@hours * 60)
		IF 	@minutes <= 0 SET @minutes = 1		
		SELECT @minutes_text =
			CASE LEN(CONVERT(VARCHAR,@minutes))
				WHEN 1 THEN '0' + CONVERT(VARCHAR,@minutes)
				ELSE CONVERT(VARCHAR,@minutes)
			END
		SET @display_avgduration = CONVERT(VARCHAR,@hours) + ':' + @minutes_text
		
		IF LEN(@email_temp) > 57
		BEGIN
			SET @email_temp = '  ' + SUBSTRING(@email_temp,0,57) + ' ' + 
				@display_runtime + ' / ' + @display_avgduration
		END
		ELSE IF LEN(@email_temp) < 57
		BEGIN
			SET @x = 57 - LEN(@email_temp)
			SET @email_temp = '  ' + @email_temp + REPLICATE(' ' ,@x ) + 
				@display_runtime + ' / ' + @display_avgduration
		END
		INSERT INTO #temp_text (email_text,job_name) VALUES (@email_temp,@job_nm)
       END 
     END 
  END
  
  --IF less than 2 entries of job history exist for this job.
  --Then alert if job is running longer than 9 hours.                  
  ELSE IF @duration_sec > @check_max_runtime_without_history 
  BEGIN
	SET @email_temp = LTRIM(RTRIM(@job_nm))

	SET @minutes = (@duration_sec / 60)
	SET @hours = FLOOR(@minutes /60)
	SET @minutes =  @minutes - (@hours * 60)
	SELECT @minutes_text =
		CASE LEN(CONVERT(VARCHAR,@minutes))
			WHEN 1 THEN '0' + CONVERT(VARCHAR,@minutes)
			ELSE CONVERT(VARCHAR,@minutes)
		END
	SET @display_runtime = CONVERT(VARCHAR,@hours) + ':' + @minutes_text
	
	IF LEN(@email_temp) > 57
	BEGIN
		SET @email_temp = '  ' + SUBSTRING(@email_temp,0,57) + ' ' + 
			@display_runtime + ' / N/A'
	END
	ELSE IF LEN(@email_temp) < 57
	BEGIN
		SET @x = 57 - LEN(@email_temp)
		SET @email_temp = '  ' + @email_temp + REPLICATE(' ' ,@x ) + 
			@display_runtime + ' / N/A'
	END
		INSERT INTO #temp_text (email_text,job_name) VALUES (@email_temp,@job_nm)
  END
  SELECT @minid = @minid + 1 

END 

--Begin Loop to retrieve database names from #temp_text and insert into the variable @email_body
set @x = (select COUNT (email_text) from #temp_text)
set @z = 1
WHILE @z <= @x
BEGIN
   SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT email_text FROM #temp_text where id = @z)))
   SET @email_body = @email_body + CHAR(13)+CHAR(10)
   SET @z = @z + 1
END
--End Loop

IF	((SELECT COUNT(email_text) FROM #temp_text) > 0)
BEGIN

	EXEC msdb.dbo.sp_send_dbmail
		@profile_name = @mail_profile_name,
		@recipients = @mail_recipients,
		@copy_recipients = @mail_copy_recipients,
		@blind_copy_recipients = @mail_blind_copy_recipients,
		@subject = @subject2,
		@body = @email_body

--------------------------------------------------------------------------------
--Log DB Problem to Windows Application Event Log
--------------------------------------------------------------------------------
	--Truncating the servername down to varchar(45) because of space issues within the Eventlog.
	SET @SERVER_NAME = CAST(@SERVER_NAME AS VARCHAR(45))
	SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))

	DECLARE cur1 CURSOR FAST_FORWARD FOR
		SELECT job_name FROM #temp_text(NOLOCK)
	OPEN cur1

	FETCH NEXT FROM cur1 INTO @job_nm
	WHILE (@@Fetch_status = 0)
	BEGIN
	
		SET @event_message = '; ' + @SERVER_NAME + '; LONG RUNNING JOBS; ' + (CONVERT(VARCHAR(20),getdate(),120)) + '; '
		SET @x = LEN(@event_message) - 255
		
		IF (LEN(@job_nm) + @x) < 255
		BEGIN
			SET @event_message = @event_message + @job_nm
		END
		ELSE
		BEGIN
			SET @job_nm = SUBSTRING(@job_nm,0,(255 - @x))
			SET @event_message = @event_message + @job_nm
		END				 

		--Generates Windows App Event log message & SQL Log Error
		EXEC master.dbo.xp_logevent 77021, @event_message, WARNING

	FETCH NEXT FROM cur1 INTO @job_nm
	END
	CLOSE cur1
	DEALLOCATE cur1
		
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

END

DROP TABLE #enum_job
DROP TABLE #allactivejobs
DROP TABLE ##jobs
DROP TABLE #temp_text

GO
/****** Object:  StoredProcedure [dbo].[usp_MonthlyCleanup]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


create proc [dbo].[usp_MonthlyCleanup]

-------SQL 2000-2005-2008-2012 EDITION  v2012------------------------
----------------------------------------------------------------
-- This procedure executes deletes rows older than 30 days on all 
-- SYSWarehouse tables
-- The procedure takes the following parameters:
-----------------------------------------------------------------
-- Sample Execution:
-- EXEC [usp_MonthlyCleanup]
----------------------------------------------------------------
--06/14/2012 v2012 - SMurua - Initial creation
----------------------------------------------------------------

as

delete from [dbo].[MON_SQL_CFG_LogonAccounts] where updated_date < GETDATE() - 30
delete from [dbo].[MON_SQL_CFG_InstanceConfigurationSettings] where updated_date < GETDATE() - 30
delete from [dbo].[MON_SQL_CFG_Instance] where updated_date < GETDATE() - 30
delete from [dbo].[MON_SQL_CFG_LogonAccountsServerPermissions] where updated_date < GETDATE() - 30
delete from [dbo].[MON_SQL_CFG_LogonAccountsServerRoles] where updated_date < GETDATE() - 30
delete from [dbo].[MON_SQL_CFG_Database_Users_Roles] where updated_date < GETDATE() - 30
delete from [dbo].[MON_SQL_CFG_Database_Object_Permissions] where updated_date < GETDATE() - 30
delete from [dbo].[MON_SQL_CFG_Database_Stats] where updated_date < GETDATE() - 30
delete from [dbo].[MON_SQL_CFG_Database_UserAccounts] where updated_date < GETDATE() - 30
delete from [dbo].[MON_SQL_CFG_Database_Backups] where updated_date < GETDATE() - 30


GO
/****** Object:  StoredProcedure [dbo].[usp_MonthlyExceptionReport]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_MonthlyExceptionReport] as
-------SQL 2012 EDITION  v06_2012----------------------------
----------------------------------------------------------------
-- This proc checks for databases that are listed as exceptions
-- in SYSAdmin.dbo.MON_SQL_CFG_BackupReports and have never been
-- backed up or have not been backed up for over 30 days.
--
-- If an email alert is sent for any of the above reasons, 
-- a message is logged to the Application Eventlog of:
-- @SERVER_NAME; MONTHLY BACKUP WARNING; 
-- 
-- Execute the following command to view all settings for this script:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_MonthlyExceptionReport'
--
-- 	mail_profile_name = SQL DBMail profile name to be used by this script.
--	mail_recipients = Email Address to send messages TO
----------------------------------------------------------------

SET NOCOUNT ON
DECLARE @client varchar(100)
SELECT @client = isnull([variable2],'client_name_missing') FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc'

DECLARE
	@SERVER_NAME varchar(100),
    @subject2 varchar (150),
    @email_body nvarchar(4000),
	@event_message varchar(255),
    @current_date char(20),
    @x int,
    @z int,
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000);

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_MonthlyExceptionReport') = 0
	BEGIN
		UPDATE SYSAdmin.dbo.MON_SQL_CFG SET proc_name = 'usp_MonthlyExceptionReport'
		WHERE proc_name = 'usp_MonthlyBackupReport'
	END

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_MonthlyExceptionReport') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG (proc_name) VALUES ('usp_MonthlyExceptionReport')
	END

	SELECT  
		@mail_profile_name = mail_profile_name,
		@mail_recipients = mail_recipients,
		@mail_copy_recipients = mail_copy_recipients,
		@mail_blind_copy_recipients = mail_blind_copy_recipients
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_MonthlyExceptionReport';
	
SET @current_date = (SELECT CONVERT( varchar(20), GETDATE(), 120)  )

-- Get the host name
SET @SERVER_NAME = @@servername
SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))
SELECT @subject2 = 'MON_SQL : ' + @client + ' : ' + @SERVER_NAME + ' Monthly Exception Report'

--Creating the first section of Job Email
SET @email_body = 'Job ' + CHAR(39) + '*Monthly Exceptions Report' + CHAR(39) + ' : v06_2012'
SET @email_body = @email_body + CHAR(13)+ CHAR(10)+ '  ' + CHAR(13)+CHAR(10)
SET @email_body = @email_body + 'Monthly Exception Report : Began Executing ' + @current_date 
SET @email_body = @email_body + CHAR(13)+CHAR(10)
SET @email_body = @email_body + '  Server Name: ' + @SERVER_NAME
SET @email_body = @email_body + CHAR(13)+CHAR(10)

--Used to hold DB info that have been backed up.
IF object_id('tempdb..#tblBackupHistory', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #tblBackupHistory
END
ELSE
BEGIN
	CREATE TABLE #tblBackupHistory (
		database_name		NVARCHAR(256) NULL,
		backup_start_date	DATETIME,
		backup_finish_date	DATETIME,
		backup_duration		INT,
		backup_size			NUMERIC(20,0)
	)			
END

--Used to hold DB names that do NOT have a backup.
IF object_id('tempdb..#tblNoBackups', 'U') IS NOT NULL 
BEGIN
	TRUNCATE TABLE #tblNoBackups
END
ELSE
BEGIN
	CREATE TABLE #tblNoBackups (
		id INT NOT NULL IDENTITY (1, 1),	
		name VARCHAR(256)
		)
END

--Used to store database names for backups older that 48-hours
IF object_id('tempdb..#tblNoBkups48H', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #tblNoBkups48H
END
ELSE
BEGIN
	CREATE TABLE #tblNoBkups48H (
		id INT NOT NULL IDENTITY (1, 1),
		email_text NVARCHAR(256)
	)
END

--Used to hold drive names that are NOT monitored
IF object_id('tempdb..#tblDriveExceptions', 'U') IS NOT NULL 
BEGIN
	TRUNCATE TABLE #tblDriveExceptions
END
ELSE
BEGIN
	CREATE TABLE #tblDriveExceptions (
		id INT NOT NULL IDENTITY (1, 1),
		email_text VARCHAR(500)
		)
END

--Used to hold drive names that are monitored with custom values.
IF object_id('tempdb..#tblDriveCustom', 'U') IS NOT NULL 
BEGIN
	TRUNCATE TABLE #tblDriveCustom
END
ELSE
BEGIN
	CREATE TABLE #tblDriveCustom (
		id INT NOT NULL IDENTITY (1, 1),
		email_text VARCHAR(500)
		)
END

--Used to hold job names that are NOT monitored by "Long Running Jobs".
IF object_id('tempdb..#tblLongRunningJobsException', 'U') IS NOT NULL 
BEGIN
	TRUNCATE TABLE #tblLongRunningJobsException
END
ELSE
BEGIN
	CREATE TABLE #tblLongRunningJobsException (
		id INT NOT NULL IDENTITY (1, 1),
		email_text VARCHAR(500)
		)
END

--IF statement to confirm the existence of the backup exception table.
IF object_id('SYSAdmin.dbo.MON_SQL_CFG_BackupReports', 'U') IS NOT NULL
BEGIN

--All DBs with a backup_finish_date reference.
INSERT INTO #tblBackupHistory 
	SELECT 
		a.database_name, 
		a.backup_start_date, 
		a.backup_finish_date,
		DATEDIFF(ss, a.backup_start_date, a.backup_finish_date) AS backup_duration, 
		a.backup_size
	FROM msdb.dbo.backupset a
	RIGHT JOIN master.dbo.sysdatabases c ON
		a.database_name = c.name,
		(
		SELECT 
			database_name, 
			MAX(backup_finish_date) AS backup_finish_date
		FROM msdb.dbo.backupset
		WHERE 
			( type = 'D' or type = 'I' ) AND
			database_name NOT IN('tempdb')
		GROUP BY database_name
		) b
	WHERE 
		a.database_name = b.database_name
		AND 
		a.backup_finish_date= b.backup_finish_date;


--Check for any databases that have never had a backup.		
INSERT INTO #tblNoBackups
SELECT DISTINCT
    a.name
  FROM
    master.dbo.sysdatabases a LEFT JOIN 
    msdb.dbo.backupset b ON
    a.name = b.database_name
  WHERE b.database_name IS NULL AND
    a.name NOT IN('tempdb') AND
	a.name COLLATE SQL_Latin1_General_CP1_CI_AS IN 
		(SELECT database_name COLLATE SQL_Latin1_General_CP1_CI_AS 
		FROM SYSAdmin.dbo.MON_SQL_CFG_BackupReports)
  ORDER BY a.name

IF (SELECT COUNT(name) FROM #tblNoBackups) > 0
BEGIN
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  The following Databases are excluded and have never been backed up.'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)

	--Begin Loop to retrieve database names from #tblNoBackups and insert into the variable @email_body
	SET @x = (select count(name) from #tblNoBackups)
	SET @z = 1
	WHILE @z <= @x
	BEGIN
		SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT SUBSTRING(name,1,50) FROM #tblNoBackups where id = @z)))
		SET @email_body = @email_body + CHAR(13)+CHAR(10)
		SET @z = @z + 1
	END
	--End Loop
END

--Check for any databases that have backups older than 720-hours.
IF (
	SELECT 
		COUNT(database_name)
	FROM #tblBackupHistory
	WHERE
		database_name COLLATE SQL_Latin1_General_CP1_CI_AS IN 
			(
				SELECT 
					database_name COLLATE SQL_Latin1_General_CP1_CI_AS 
				FROM SYSAdmin.dbo.MON_SQL_CFG_BackupReports)
		AND
		backup_finish_date < DATEADD(hh, -720, GETDATE())
	) > 0

BEGIN
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  The following databases are listed as exceptions and have not been backed up for 30 day.'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)

	INSERT INTO #tblNoBkups48H (email_text)
	SELECT 
		SUBSTRING(database_name,1,30) +
		SUBSTRING('                              ',LEN(database_name),30) +
		CAST(backup_start_date AS CHAR(19)) + '     ' + 
		CAST(backup_finish_date AS CHAR(19))
	FROM #tblBackupHistory
	WHERE
		database_name COLLATE SQL_Latin1_General_CP1_CI_AS IN 
			(
				SELECT 
					database_name COLLATE SQL_Latin1_General_CP1_CI_AS 
				FROM SYSAdmin.dbo.MON_SQL_CFG_BackupReports)
		AND		
		backup_finish_date < DATEADD(hh, -720, GETDATE())
	ORDER BY database_name
			
	--Begin Loop to retrieve database names from #tblNoBkups48H and insert into the variable @email_body
	SET @x = (select COUNT (email_text) from #tblNoBkups48H)
	SET @z = 1
	WHILE @z <= @x
	BEGIN
	   SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT email_text FROM #tblNoBkups48H where id = @z)))
	   SET @email_body = @email_body + CHAR(13)+CHAR(10)
	   SET @z = @z + 1
	END
	--End Loop
END
END -- IF check for SYSAdmin.dbo.MON_SQL_CFG_BackupReports

--IF statement to confirm the existence of the drivespace exception table.
IF object_id('SYSAdmin.dbo.MON_SQL_CFG_DriveSpace', 'U') IS NOT NULL
BEGIN

IF (SELECT COUNT(drive) FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace WHERE monitor = 0) > 0
BEGIN
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  The following disks are listed as exceptions and are NOT monitored.'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    
    
    INSERT INTO #tblDriveExceptions (email_text)
    SELECT 'Drive = ' + drive
    FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace
    WHERE monitor = 0

	--Begin Loop to retrieve drive names from #tblDriveExceptions and insert into 
	--the variable @email_body
	SET @x = (SELECT COUNT(email_text) FROM #tblDriveExceptions)
	SET @z = 1
	WHILE @z <= @x
	BEGIN
	   SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT email_text FROM #tblDriveExceptions WHERE id = @z)))
	   SET @email_body = @email_body + CHAR(13)+CHAR(10)
	   SET @z = @z + 1
	END
	--End Loop

END

IF (SELECT COUNT(drive) FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace WHERE monitor = 1) > 0
BEGIN
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  The following disks are monitored with custom drivespace thresholds.'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)

    INSERT INTO #tblDriveCustom (email_text)
    SELECT '  ' + (CASE WHEN drive IS NOT NULL THEN 'Drive=' ELSE '' END)
		+	ISNULL(CAST(drive AS VARCHAR(100)),'')
		+ '  ' + (CASE WHEN warningMBThreshold IS NOT NULL THEN 'Warn MB=' ELSE '' END)
		+	ISNULL(CAST(warningMBThreshold AS VARCHAR(10)),'') 
		+ '  ' +(CASE WHEN criticalMBThreshold IS NOT NULL THEN 'Crit MB=' ELSE '' END)
		+	ISNULL(CAST(criticalMBThreshold AS VARCHAR(10)),'')  
		+ '  ' + (CASE WHEN warningPercThreshold IS NOT NULL THEN 'Warn%=' ELSE '' END)
		+	ISNULL(CAST(warningPercThreshold AS VARCHAR(3)),'') 
		+ '  ' +(CASE WHEN criticalPercThreshold IS NOT NULL THEN 'Crit%=' ELSE '' END)			
		+	ISNULL(CAST(criticalPercThreshold AS VARCHAR(3)),'') 
    FROM SYSAdmin.dbo.MON_SQL_CFG_DriveSpace
    WHERE monitor = 1

	--Begin Loop to retrieve drive names and values from #tblDriveCustom and insert 
	--into the variable @email_body
	SET @x = (SELECT COUNT(email_text) FROM #tblDriveCustom)
	SET @z = 1
	WHILE @z <= @x
	BEGIN
	   SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT email_text FROM #tblDriveCustom WHERE id = @z)))
	   SET @email_body = @email_body + CHAR(13)+CHAR(10)
	   SET @z = @z + 1
	END
	--End Loop

END
END -- IF check for SYSAdmin.dbo.MON_SQL_CFG_DriveSpace

--IF statement to confirm the existence of the MON_SQL_Jobs_Config exception table.
IF object_id('SYSAdmin.dbo.MON_SQL_Jobs_Config', 'U') IS NOT NULL
BEGIN

IF (SELECT COUNT(job_nm) FROM SYSAdmin.dbo.MON_SQL_Jobs_Config) > 0
BEGIN
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  The following jobs are NOT monitored by the "Long Running Jobs" script'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
    SET @email_body = @email_body + '  -------------------------------------------------------------------------------'
    SET @email_body = @email_body + CHAR(13)+CHAR(10)
        
    INSERT INTO #tblLongRunningJobsException (email_text)
    SELECT 'Job Name = ' + job_nm
    FROM SYSAdmin.dbo.MON_SQL_Jobs_Config

	--Begin Loop to retrieve drive names from #tblDriveExceptions and insert into 
	--the variable @email_body
	SET @x = (SELECT COUNT(email_text) FROM #tblLongRunningJobsException)
	SET @z = 1
	WHILE @z <= @x
	BEGIN
	   SET @email_body = @email_body + '  ' + RTRIM(LTRIM((SELECT email_text FROM #tblLongRunningJobsException WHERE id = @z)))
	   SET @email_body = @email_body + CHAR(13)+CHAR(10)
	   SET @z = @z + 1
	END
	--End Loop

END
END -- IF check for SYSAdmin.dbo.MON_SQL_Jobs_Config

IF	(
	(SELECT COUNT(name) FROM #tblNoBackups) > 0 OR 
	(SELECT COUNT(email_text) FROM #tblNoBkups48H) > 0 OR
	(SELECT COUNT(email_text) FROM #tblDriveCustom) > 0 OR
	(SELECT COUNT(email_text) FROM #tblDriveExceptions) > 0 OR
	(SELECT COUNT(email_text) FROM #tblLongRunningJobsException) > 0
	)
BEGIN

	EXEC msdb.dbo.sp_send_dbmail
		@profile_name = @mail_profile_name,
		@recipients = @mail_recipients,
		@copy_recipients = @mail_copy_recipients,
		@blind_copy_recipients = @mail_blind_copy_recipients,
		@subject = @subject2,
		@body = @email_body	

--------------------------------------------------------------------------------
--Log DB Problem to Windows Application Event Log
--------------------------------------------------------------------------------

		--Truncating the servername down to varchar(45) because of space issues within the Eventlog.
		SET @SERVER_NAME = CAST(@SERVER_NAME AS VARCHAR(45))
		SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))

		SET @event_message = '; ' + @SERVER_NAME + '; MONTHLY EXCEPTIONS WARNING; ' + (CONVERT(VARCHAR(20),getdate(),120))  + '; (Monthly Exceptions Warning)'

		--Generates Windows App Event log message & SQL Log Error
		EXEC master.dbo.xp_logevent 77021, @event_message, WARNING
		
		/* --Generates Windows App Event log message & SQL Log Error & Returns the error to the client.
		RAISERROR (
			@event_message, -- Message text.
			0, -- Severity 0 to 18,
			1   -- State
		) 
		WITH LOG
		*/

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

END

DROP TABLE #tblBackupHistory
DROP TABLE #tblNoBackups
DROP TABLE #tblNoBkups48H
DROP TABLE #tblDriveCustom
DROP TABLE #tblDriveExceptions
DROP TABLE #tblLongRunningJobsException

GO
/****** Object:  StoredProcedure [dbo].[usp_purge_job_history]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE procedure [dbo].[usp_purge_job_history] @JobName as varchar(100) AS
-------SQL 2012 EDITION  v06_2012---------------------
----------------------------------------------------------------
-- Description:  Stored Procedure used to purge job histories.
----------------------------------------------------------------
----------------------------------------------------------------
  DECLARE @JobID BINARY(16)  

  SELECT @JobID = job_id     
  FROM   msdb.dbo.sysjobs    
  WHERE (name = @JobName)   
  IF (@JobID IS NOT NULL)    
  BEGIN 
    -- Purge the Job History
	EXEC msdb..sp_purge_jobhistory @job_name = @JobName

  END;

GO
/****** Object:  StoredProcedure [dbo].[usp_sql_log_report]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE procedure [dbo].[usp_sql_log_report] AS
-------SQL 2012 EDITION  v06_2012-------------------------------------
-------------------------------------------------------------------------
-- Description:  This SQL Code reports on specific SQL Server LOG 
-- errors
-- The report built can be emailed and/or logged to the eventlog.
--
-- Execute the following command to view all settings for this script:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_sql_log_report'
--
-- 	mail_profile_name = SQL DBMail profile name to be used by this script.
--	mail_recipients = Email Address to send messages TO
--
-- Execute the following command to view all log filters used by this script:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG_Log_Filter
--
-- Execute the following command to view all SQL log exceptions:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG_Log_Exception
-------------------------------------------------------------------------
-------------------------------------------------------------------------

DECLARE @client varchar(100)
SELECT @client = isnull([variable2],'client_name_missing') FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc'

DECLARE
	@SERVER_NAME varchar(100),
	@subject2 as varchar(150),
	@email_body nvarchar(4000),
	@email_date char(20),
	@x int,
	@z int,
	@SQLError nvarchar(2048),
	@SQLError_Date datetime,
	@Begining_Search_Date datetime,
	@event_message as varchar(255),
	@event_severity as varchar(20),
	@event_date datetime,
	@event_date2 as varchar(20),
	@event_error as int,
	@filter_id as int,
	@blackout_exists as tinyint,
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000);
	
	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_sql_log_report') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG (proc_name) VALUES ('usp_sql_log_report')
	END

	SELECT  
		@mail_profile_name = mail_profile_name,
		@mail_recipients = mail_recipients,
		@mail_copy_recipients = mail_copy_recipients,
		@mail_blind_copy_recipients = mail_blind_copy_recipients
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_sql_log_report';
	
--DROP Temp Tables if they existed before the Stored Procedure was run.
IF object_id('tempdb..#errors', 'U') is not null 
	DROP TABLE #errors
IF object_id('tempdb..#temp_text', 'U') is not null 
	DROP TABLE #temp_text
IF object_id('tempdb..#temp_text2', 'U') is not null 
	DROP TABLE #temp_text2
IF object_id('tempdb..#error_log_details', 'U') is not null 
	DROP TABLE #error_log_details

--If the table MON_SQL_CFG_Log_LastEntry does not exist, it is created now.
IF object_id('SYSAdmin..MON_SQL_CFG_Log_LastEntry', 'U') is null 
	BEGIN
		CREATE TABLE SYSAdmin..MON_SQL_CFG_Log_LastEntry (
			id int NOT NULL IDENTITY (1, 1),
			Log_Error_Date datetime,
			SQL_Log_Error nvarchar(2048)
		)
	END

--Set last error date to report on.  
IF (SELECT Log_Error_Date FROM SYSAdmin..MON_SQL_CFG_Log_LastEntry WHERE id = 1) IS NULL
	BEGIN
		SELECT @Begining_Search_Date = (DATEADD(hh, -24, GETDATE()))
	END
ELSE
	BEGIN
		SELECT @Begining_Search_Date = (SELECT Log_Error_Date FROM SYSAdmin..MON_SQL_CFG_Log_LastEntry WHERE id = 1)
	END

-------------------------------------------------------------
--------------------FOR TESTING------------------------------
--SELECT @Begining_Search_Date = (DATEADD(yy, -12, GETDATE()))
--------------------FOR TESTING------------------------------
-------------------------------------------------------------

--Set Blackout Schedule Settings
SET @blackout_exists = 0
IF EXISTS (	SELECT * FROM dbo.sysobjects 
			WHERE
			id = object_id(N'[dbo].[blackout]') AND 
			OBJECTPROPERTY(id, N'IsScalarFunction') = 1	)
BEGIN
	SET DATEFIRST 7
	SET @blackout_exists = 1
END

--Create DateTime for header for email
SET @email_date = (SELECT CONVERT( varchar(20), GETDATE(), 120)  )

-- Create temporary table and index to hold the SQL Error log
CREATE TABLE #errors (
	LogDate datetime, 
	ProcessInfo varchar(20), 
	SQL_Log_Error nvarchar(2048)
)
CREATE CLUSTERED INDEX idx_msg ON #errors(LogDate)

-- Read the Current Active SQL Error Log into the temporary error table
INSERT #errors EXEC master.dbo.xp_readerrorlog

-- Create Temporary Report table
CREATE TABLE #temp_text (
	id int NOT NULL IDENTITY (1, 1),
	LogDate datetime NULL,
	SQL_Log_Error nvarchar(2048),
	eventlog_text varchar(255),
	severity varchar(20),
	event_error int,
	filter_id int
)

-- Create Temporary Report table
CREATE TABLE #temp_text2 (
	id int NOT NULL IDENTITY (1, 1),
	LogDate datetime NULL,
	SQL_Log_Error nvarchar(2048),
	eventlog_text varchar(255),
	severity varchar(20),
	event_error int,
	filter_id int
)

SET NOCOUNT ON

-- Get the host name
SELECT @SERVER_NAME = @@servername
SELECT @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))

-- Generate report heading and column headers
	SELECT @subject2 = 'MON_SQL : ' + @client + ' : ' + @SERVER_NAME + ' SQL LOG Report'

	Set @email_body = 'Job ' + CHAR(39) + '*SQL LOG Report' + CHAR(39) + ' : v06_2012 '
	Set @email_body = @email_body + ': Began Executing ' + @email_date 
	Set @email_body = @email_body + CHAR(13)+ CHAR(10)+CHAR(13)+CHAR(10)
	Set @email_body = @email_body + 'SQL Error Logs searched with a Date/Time greater than: ' + Convert(varchar,@Begining_Search_Date)
	Set @email_body = @email_body +  CHAR(13)+CHAR(10)
	Set @email_body = @email_body + '  --------------------------------------------------------------------------'
	Set @email_body = @email_body + CHAR(13)+CHAR(10)
	Set @email_body = @email_body + '  SQL LOG ENTRIES on host ' + @SERVER_NAME
	Set @email_body = @email_body + CHAR(13)+CHAR(10)
	Set @email_body = @email_body + '  --------------------------------------------------------------------------'
	Set @email_body = @email_body + CHAR(13)+CHAR(10)
	

----------------------------------
--Inserting Records that match the 1st set of Log_Filters ONLY
----------------------------------
-- Generate SQL Log Report Detail
	INSERT INTO #temp_text2 (LogDate, SQL_Log_Error, eventlog_text, severity, event_error, filter_id)		
	SELECT
		source.LogDate, source.SQL_Log_Error,
		filter1.Error_Description, 
		filter1.severity, filter1.event_error, 
		filter1.id
	FROM #errors source
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Filter filter1
	ON 
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE 
		filter1.Log_Filter1 COLLATE SQL_Latin1_General_CP1_CI_AS 
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Filter filter2
	ON 
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE 
		filter2.Log_Filter2 COLLATE SQL_Latin1_General_CP1_CI_AS 
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Filter filter3
	ON 
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE 
		filter3.Log_Filter3 COLLATE SQL_Latin1_General_CP1_CI_AS 
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Exception exception1
	ON
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE
		exception1.Exception_Filter1 COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE 
		source.SQL_Log_Error IS NOT NULL	
	AND
		source.SQL_Log_Error NOT IN (
		SELECT source.SQL_Log_Error 
		FROM #errors 
		WHERE 
		exception1.Exception_Filter1 IS NOT NULL 
		)
	AND
		LogDate > @Begining_Search_Date
		AND	filter1.Log_Filter1 IS NOT NULL
		AND filter1.Log_Filter2 IS NULL
		AND filter1.Log_Filter3 IS NULL
		AND filter2.Log_Filter2 IS NULL
		AND filter3.Log_Filter3 IS NULL	
	
----------------------------------
--Inserting Records that match the 1st & 2nd set of Log_Filters ONLY
----------------------------------
	INSERT INTO #temp_text2 (LogDate, SQL_Log_Error, eventlog_text, severity, event_error, filter_id)		
	SELECT
		source.LogDate, source.SQL_Log_Error,
		filter1.Error_Description, 
		filter1.severity, filter1.event_error, 
		filter2.id
	FROM #errors source
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Filter filter1
	ON 
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE 
		filter1.Log_Filter1 COLLATE SQL_Latin1_General_CP1_CI_AS 
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Filter filter2
	ON 
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE 
		filter2.Log_Filter2 COLLATE SQL_Latin1_General_CP1_CI_AS 
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Filter filter3
	ON 
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE 
		filter3.Log_Filter3 COLLATE SQL_Latin1_General_CP1_CI_AS 
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Exception exception1
	ON
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE
		exception1.Exception_Filter1 COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE 
		source.SQL_Log_Error IS NOT NULL	
	AND
		source.SQL_Log_Error NOT IN (
		SELECT source.SQL_Log_Error 
		FROM #errors 
		WHERE 
		exception1.Exception_Filter1 IS NOT NULL 
		)
	AND
		LogDate > @Begining_Search_Date
		AND filter1.Log_Filter1 IS NOT NULL
		AND filter1.Log_Filter2 IS NOT NULL
		AND filter2.Log_Filter2 IS NOT NULL
		AND filter1.Log_Filter3 IS NULL
		AND filter3.Log_Filter3 IS NULL	
		AND filter1.Log_Filter1 = filter2.Log_Filter1
		AND filter1.Log_Filter2 = filter2.Log_Filter2		
	
----------------------------------
--Inserting Records that match all three Log_Filters.
----------------------------------		
	INSERT INTO #temp_text2 (LogDate, SQL_Log_Error, eventlog_text, severity, event_error, filter_id)		
	SELECT
		source.LogDate, source.SQL_Log_Error,
		filter1.Error_Description, 
		filter1.severity, filter1.event_error, 
		filter3.id
	FROM #errors source
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Filter filter1
	ON 
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE 
		filter1.Log_Filter1 COLLATE SQL_Latin1_General_CP1_CI_AS 
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Filter filter2
	ON 
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE 
		filter2.Log_Filter2 COLLATE SQL_Latin1_General_CP1_CI_AS 
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Filter filter3
	ON 
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE 
		filter3.Log_Filter3 COLLATE SQL_Latin1_General_CP1_CI_AS 
	FULL OUTER JOIN SYSAdmin.dbo.MON_SQL_CFG_Log_Exception exception1
	ON
		source.SQL_Log_Error COLLATE SQL_Latin1_General_CP1_CI_AS 
	LIKE
		exception1.Exception_Filter1 COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE 
		source.SQL_Log_Error IS NOT NULL	
	AND
		source.SQL_Log_Error NOT IN (
		SELECT source.SQL_Log_Error 
		FROM #errors 
		WHERE 
		exception1.Exception_Filter1 IS NOT NULL 
		)
	AND
		LogDate > @Begining_Search_Date
		AND filter1.Log_Filter1 IS NOT NULL
		AND filter1.Log_Filter2 IS NOT NULL
		AND filter1.Log_Filter3 IS NOT NULL
		AND filter2.Log_Filter2 IS NOT NULL
		AND filter3.Log_Filter3 IS NOT NULL
		AND filter1.Log_Filter1 = filter2.Log_Filter1
		AND filter1.Log_Filter2 = filter2.Log_Filter2
		AND filter1.Log_Filter3 = filter2.Log_Filter3
		AND filter1.Log_Filter1 = filter3.Log_Filter1
		AND filter1.Log_Filter2 = filter3.Log_Filter2
		AND filter1.Log_Filter3 = filter3.Log_Filter3
		AND filter2.Log_Filter1 = filter3.Log_Filter1
		AND filter2.Log_Filter2 = filter3.Log_Filter2
		AND filter2.Log_Filter3 = filter3.Log_Filter3
		

--------------------------------------------------
--Cursor to check if any errors occured during the blackout period.
--------------------------------------------------
	IF ((SELECT COUNT(id) FROM #temp_text2) > 0) AND (@blackout_exists = 1)
	BEGIN
		DECLARE cur1 CURSOR FOR
			SELECT LogDate, SQL_Log_Error, eventlog_text, severity, event_error, filter_id 
			FROM #temp_text2
			ORDER BY LogDate ASC
		OPEN cur1
		FETCH NEXT FROM cur1 INTO 
			@SQLError_Date, @SQLError, @event_message, @event_severity, @event_error, @filter_id

		WHILE (@@Fetch_status = 0)
		BEGIN
			IF SYSAdmin.dbo.blackout(@SQLError_Date) = 0
				BEGIN
					INSERT INTO #temp_text 
						(LogDate, SQL_Log_Error, eventlog_text, severity, event_error, filter_id) 
					VALUES 
						(@SQLError_Date, @SQLError, @event_message, @event_severity, @event_error, @filter_id) 
				END
		FETCH NEXT FROM cur1 INTO 
			@SQLError_Date, @SQLError, @event_message, @event_severity, @event_error, @filter_id

		END
		CLOSE cur1
		DEALLOCATE cur1
	END ELSE
	BEGIN
		INSERT INTO #temp_text 
			(LogDate, SQL_Log_Error, eventlog_text, severity, event_error, filter_id) 
		SELECT LogDate, SQL_Log_Error, eventlog_text, severity, event_error, filter_id 
		FROM #temp_text2
		ORDER BY LogDate ASC
	END 

--------------------------------------------------------------------------------
--Log DB Problem to Windows Application Event Log
--------------------------------------------------------------------------------
SET ANSI_WARNINGS OFF 

	--Truncating the servername down to varchar(45) because of space issues within the Eventlog.
	SET @SERVER_NAME = CAST(@SERVER_NAME AS VARCHAR(45))
	SET @SERVER_NAME = LTRIM(RTRIM(@SERVER_NAME))

	IF (SELECT COUNT(eventlog_text) FROM #temp_text) > 0
	BEGIN
		DECLARE cur1 CURSOR FAST_FORWARD FOR
			SELECT eventlog_text, severity, event_error, LogDate FROM #temp_text(NOLOCK)
			WHERE eventlog_text IS NOT NULL
		OPEN cur1

		FETCH NEXT FROM cur1 INTO @event_message, @event_severity, @event_error, @event_date
		WHILE (@@Fetch_status = 0)
		BEGIN
			-- Set date format to be used in EventLog messages
			SELECT @event_date2 = CONVERT(varchar,@event_date,120)
			SELECT @event_date2 = LTRIM(RTRIM(@event_date2))

			SELECT @event_message = '; ' + @SERVER_NAME + '; SQL LOG ERROR; ' + @event_date2 + '; ' + @event_message

			--Generates Windows App Event log message & SQL Log Error
			EXEC master.dbo.xp_logevent @event_error, @event_message, @event_severity

			/* --Generates Windows App Event log message & SQL Log Error & Returns the error to the client.
			RAISERROR (
				@event_message, -- Message text.
				0, -- Severity 0 to 18,
				1   -- State
			) 
			WITH LOG
			*/
		FETCH NEXT FROM cur1 INTO @event_message, @event_severity, @event_error, @event_date
		END
		CLOSE cur1
		DEALLOCATE cur1

	END
SET ANSI_WARNINGS ON
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

--Prepare the email to be sent.
IF (SELECT count (id) FROM #temp_text) > 0
BEGIN
	SET @x = (SELECT count (id) FROM #temp_text)
	SET @z = 1
	WHILE @z <= @x
	BEGIN

		SET @email_body = @email_body + 
			'  ' + (SELECT LTRIM(RTRIM(CONVERT(varchar(23),LogDate,21))) + 
			' ' + LTRIM(RTRIM(SQL_Log_Error)) FROM #temp_text WHERE id = @z)

		SET @email_body = @email_body + CHAR(13)+CHAR(10)
		SET @email_body = @email_body + '  '
		SET @email_body = @email_body + CHAR(13)+CHAR(10)
		SET @z = @z + 1
	END

	EXEC msdb.dbo.sp_send_dbmail
		@profile_name = @mail_profile_name,
		@recipients = @mail_recipients,
		@copy_recipients = @mail_copy_recipients,
		@blind_copy_recipients = @mail_blind_copy_recipients,
		@subject = @subject2,
		@body = @email_body

END

--Clear the table MON_SQL_CFG_Log_LastEntry and load the last SQL Log Entry read.
IF (SELECT COUNT(SQL_Log_Error) FROM #errors WHERE LogDate > @Begining_Search_Date) > 0
	BEGIN
		TRUNCATE TABLE SYSAdmin..MON_SQL_CFG_Log_LastEntry
		INSERT INTO SYSAdmin..MON_SQL_CFG_Log_LastEntry (Log_Error_Date,SQL_Log_Error)
			SELECT TOP 1 LogDate,SQL_Log_Error FROM #errors ORDER BY LogDate DESC
	END

--SELECT * FROM #temp_text2
--SELECT * FROM #temp_text
--SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG_Log_Filter

-- Drop temporary table
DROP TABLE #temp_text2
DROP TABLE #temp_text
DROP TABLE #errors
GO
/****** Object:  StoredProcedure [dbo].[usp_system_lock_alert]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE procedure [dbo].[usp_system_lock_alert] AS
-------SQL 2012 EDITION v06_2012----------------------------
---------------------------------------------------------------
-- Description:  This SQL Code reports on DB blocking issues. 
-- Scheduled to run once a minute by default.
-- The report built can be emailed and/or logged to the eventlog.
-- 
-- Execute the following command to view all settings for this script:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_system_lock_alert'
--
-- 	mail_profile_name = SQL DBMail profile name to be used by this script.
--	mail_recipients = Email Address to send messages TO
--	variable1 = Number of active blocks found before an alert is sent. (DEFAULT = 10)
----------------------------------------------------------------
--Blackout Check
DECLARE @blackout AS tinyint
SET @blackout = 0
IF EXISTS (	SELECT * FROM dbo.sysobjects 
			WHERE
			id = object_id(N'[dbo].[blackout]') AND 
			OBJECTPROPERTY(id, N'IsScalarFunction') = 1	)
BEGIN
	SET DATEFIRST 7
	SET @blackout = SYSAdmin.dbo.blackout(getdate())
END 

IF (@blackout = 0)
BEGIN

DECLARE @client varchar(100)
SELECT @client = isnull([variable2],'client_name_missing') FROM [dbo].[MON_SQL_CFG] WHERE proc_name = 'usp_UploadStatsProc'

DECLARE
	@spid INT,
	@spidBlockedBy INT,
	@emailSubject VARCHAR(255),
	@email_body nvarchar(4000),
	@servername VARCHAR(100),
	@event_message VARCHAR(255),
	@event_totalblocks INT,
	@sql_code NVARCHAR(4000),
	@x INT,
	@z INT,
	@blocking_thresh_hold INT,
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000);

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_system_lock_alert') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG 
			(proc_name, variable1)
			VALUES ('usp_system_lock_alert',10)
	END

	SELECT  
		@mail_profile_name = mail_profile_name,
		@mail_recipients = mail_recipients,
		@mail_copy_recipients = mail_copy_recipients,
		@mail_blind_copy_recipients = mail_blind_copy_recipients,
		@blocking_thresh_hold = CONVERT(INT, variable1)
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_system_lock_alert';
	
IF (ISNUMERIC(@blocking_thresh_hold) = 0) SET @blocking_thresh_hold = 10

IF object_id('tempdb..#EventInfoEmail', 'U') is not null 
BEGIN
	TRUNCATE TABLE #EventInfoEmail
END
ELSE
BEGIN
	CREATE TABLE #EventInfoEmail (
		id INT NOT NULL IDENTITY (1, 1),
		email nvarchar(4000)
	   )
END

IF object_id('tempdb..#EventInfoMain_Tmp', 'U') is not null 
BEGIN
	TRUNCATE TABLE #EventInfoMain_Tmp
END
ELSE
BEGIN
	CREATE TABLE #EventInfoMain_Tmp 
	(
		MnResource_db_id INT,
		MnSpid INT,
		MnEventInfo nvarchar(4000),
		MnSpid_BlockedBy INT,
		MnBlockedByInfo nvarchar(4000),
		blkby_status NVARCHAR(30), 
		blkby_loginame NVARCHAR(128),
		blkby_nt_username NVARCHAR(128),
		blkby_hostname NVARCHAR(128),
		blkby_net_address VARCHAR(48),
		DBName NVARCHAR(128),
		spid_command NVARCHAR(16),
		blkby_program_name NVARCHAR(128),
		spid_wait_type NVARCHAR(60)
	)
END

IF object_id('SYSAdmin.dbo.EventInfoMain_His', 'U') is null 
BEGIN
	CREATE TABLE SYSAdmin.dbo.EventInfoMain_His
	(
		Resource_db_id INT,
		Spid	INT,			
		SpidEventInfo nvarchar(4000),
		BlkBySpid INT,
		BlkByEventInfo nvarchar(4000),
		blkby_status NVARCHAR(30), 
		blkby_loginame NVARCHAR(128),
		blkby_nt_username NVARCHAR(128),
		blkby_hostname NVARCHAR(128),
		blkby_net_address VARCHAR(48),
		DBName NVARCHAR(128),
		spid_command NVARCHAR(16),
		blkby_program_name NVARCHAR(128),
		spid_wait_type NVARCHAR(60),		
		dtStampFound datetime,
		dtStampReleased datetime,
		ID uniqueidentifier NOT NULL
	)
END

IF NOT EXISTS (SELECT name FROM SYSAdmin.dbo.sysindexes WHERE name = 'idxEventInfoMain_His')
BEGIN
	CREATE NONCLUSTERED INDEX idxEventInfoMain_His ON SYSAdmin.dbo.EventInfoMain_His (ID)
END
IF NOT EXISTS (SELECT name FROM SYSAdmin.dbo.sysindexes WHERE name = 'idxEventInfoMain_His1')
BEGIN
	CREATE CLUSTERED INDEX [idxEventInfoMain_His1] ON [dbo].[EventInfoMain_His] 
	([dtStampFound] ASC)
	WITH (SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF) 
	ON [PRIMARY]
END

IF object_id('SYSAdmin.dbo.EventInfoMain_Tmp', 'U') is null 
BEGIN
	CREATE TABLE SYSAdmin.dbo.EventInfoMain_Tmp
	(
		Resource_db_id INT,
		Spid	INT,			
		SpidEventInfo nvarchar(4000),
		BlkBySpid INT,
		BlkByEventInfo nvarchar(4000),
		blkby_status NVARCHAR(30), 
		blkby_loginame NVARCHAR(128),
		blkby_nt_username NVARCHAR(128),
		blkby_hostname NVARCHAR(128),
		blkby_net_address VARCHAR(48),
		DBName NVARCHAR(128),
		spid_command NVARCHAR(16),
		blkby_program_name NVARCHAR(128),
		spid_wait_type NVARCHAR(60),
		FirstimeFound BIT DEFAULT 1,
		EmailSent BIT DEFAULT 0,
		dtStamp datetime DEFAULT(getdate()),
		ID uniqueidentifier NOT NULL DEFAULT newid()
	)
END

IF object_id('tempdb..#EventInfo_Tmp', 'U') is not null 
BEGIN
	TRUNCATE TABLE #EventInfo_Tmp
END
ELSE
BEGIN
	CREATE TABLE #EventInfo_Tmp (
	   EventType NVARCHAR(30),
	   Parameter INT,	
	   EventInfo NVARCHAR(4000)
	   )
END

IF object_id('tempdb..#LockBlockedBy_Tmp', 'U') is not null 
BEGIN
	TRUNCATE TABLE #LockBlockedBy_Tmp
END
ELSE
BEGIN
	CREATE TABLE #LockBlockedBy_Tmp (
	   EventType NVARCHAR(30),
	   Parameter INT,	
	   EventInfo NVARCHAR(4000)
	   )
END

--Check for blocking and insert all blocks found into #EventInfoMain_Tmp
INSERT INTO #EventInfoMain_Tmp 
	(	spid_command,
		MnResource_db_id,
		DBName,
		MnSpid, MnSpid_BlockedBy,
		blkby_status, blkby_loginame,
		blkby_nt_username,
		blkby_hostname,
		blkby_program_name
	) 
	SELECT 
		spid1.cmd, 
		spid1.dbid, 
		DB_NAME(spid1.dbid) AS 'DBName',
		spid1.spid,	spid1.blocked, 
		blkby.status, blkby.loginame,	
		blkby.nt_username, 
		blkby.hostname,
		blkby.program_name
	FROM master.dbo.sysprocesses AS spid1
    INNER JOIN master.dbo.sysprocesses AS blkby
        ON spid1.blocked = blkby.spid
	WHERE
		spid1.spid > 50 AND
		spid1.spid != spid1.blocked AND
		spid1.blocked != 0 AND
		spid1.blocked IS NOT NULL AND
		spid1.waittype != 0x0000
		

IF (SELECT count(MnSpid) FROM #EventInfoMain_Tmp) > 0
BEGIN
	DECLARE cur1 CURSOR FAST_FORWARD FOR
	SELECT MnSpid, MnSpid_BlockedBy FROM #EventInfoMain_Tmp(NOLOCK)
	OPEN cur1

	FETCH NEXT FROM cur1 INTO @spid, @spidBlockedBy
	WHILE (@@Fetch_status = 0)
	BEGIN

		SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED

		INSERT INTO #EventInfo_Tmp (EventType,Parameter,EventInfo) 
		EXEC ('dbcc inputbuffer(' + @spid + ') WITH NO_INFOMSGS')

		INSERT INTO #LockBlockedBy_Tmp (EventType,Parameter,EventInfo) 
		EXEC ('dbcc inputbuffer(' + @spidBlockedBy + ') WITH NO_INFOMSGS')

		SET TRANSACTION ISOLATION LEVEL READ COMMITTED
		
		UPDATE 	#EventInfoMain_Tmp
		SET 	MnBlockedByInfo	= CONVERT(NVARCHAR(1000),EventInfo)
		FROM	#LockBlockedBy_Tmp(NOLOCK)
		WHERE 	MnSpid		= @spid

		UPDATE 	#EventInfoMain_Tmp
		SET		MnEventInfo	= CONVERT(NVARCHAR(1000),EventInfo)
		FROM	#EventInfo_Tmp(NOLOCK)
		WHERE 	MnSpid		= @spid

		TRUNCATE TABLE #EventInfo_Tmp
		TRUNCATE TABLE #LockBlockedBy_Tmp

	FETCH NEXT FROM cur1 INTO @spid, @spidBlockedBy
	END
	CLOSE cur1
	DEALLOCATE cur1

END

--Updating the dtStampReleased with getdate() for records that are no longer
--found in #EventInfoMain_Tmp, but where logged to SYSAdmin.dbo.EventInfoMain_His
--in a previous run.
	UPDATE SYSAdmin.dbo.EventInfoMain_His 
		SET dtStampReleased = GETDATE()
	WHERE ID IN (
		SELECT 
			t1.ID
		FROM SYSAdmin.dbo.EventInfoMain_Tmp t1
		LEFT JOIN #EventInfoMain_Tmp t2
		ON
			t2.MnSpid = t1.Spid AND 
			t2.MnSpid_BlockedBy = t1.BlkBySpid AND
			t2.MnResource_db_id = t1.Resource_db_id
		WHERE t2.MnSpid IS NULL AND t1.FirstimeFound = 0
		)
			
--DELETE all records that where originally in SYSAdmin.dbo.EventInfoMain_Tmp 
--but are no longer found in #EventInfoMain_Tmp
	DELETE FROM SYSAdmin.dbo.EventInfoMain_Tmp
	WHERE Spid IN
	(
	SELECT 
		t1.Spid
	FROM SYSAdmin.dbo.EventInfoMain_Tmp t1
	LEFT JOIN #EventInfoMain_Tmp t2
	ON
		t2.MnSpid = t1.Spid AND 
		t2.MnSpid_BlockedBy = t1.BlkBySpid AND
		t2.MnResource_db_id = t1.Resource_db_id
	WHERE t2.MnSpid IS NULL
	)

IF (SELECT count(MnSpid) FROM #EventInfoMain_Tmp) > 0
BEGIN
--This step is run assuming that a record currently exists in the Table SYSAdmin.dbo.EventInfoMain_Tmp.
--If the record was already there, then it was found from the last time this script ran and it should 
--now be recorded in the history.
	INSERT INTO SYSAdmin.dbo.EventInfoMain_His 
		(	Resource_db_id, DBName,
			Spid, SpidEventInfo,
			BlkBySpid, BlkByEventInfo,
			blkby_status , 
			blkby_loginame,
			blkby_nt_username,
			blkby_hostname,
			blkby_net_address,
			spid_command,
			blkby_program_name,
			spid_wait_type,	
			dtStampFound,
			ID	
		)
		SELECT
			t1.MnResource_db_id, t1.DBName,
			t1.MnSpid, t1.MnEventInfo,
			t1.MnSpid_BlockedBy, t1.MnBlockedByInfo,
			t1.blkby_status, 
			t1.blkby_loginame,
			t1.blkby_nt_username,
			t1.blkby_hostname,
			t1.blkby_net_address,
			t1.spid_command,
			t1.blkby_program_name,
			t1.spid_wait_type,	
			GETDATE(),
			t2.ID
		FROM #EventInfoMain_Tmp t1
		RIGHT JOIN SYSAdmin.dbo.EventInfoMain_Tmp t2
		ON
			t1.MnSpid = t2.Spid AND 
			t1.MnSpid_BlockedBy = t2.BlkBySpid AND
			t1.MnResource_db_id = t2.Resource_db_id
		WHERE t2.FirstimeFound = 1 AND t1.MnSpid IS NOT NULL
		
--Updates the FirstimeFound column of SYSAdmin.dbo.EventInfoMain_Tmp to 0. 
--This keeps records from being duplicated in the history Table. 
	UPDATE SYSAdmin.dbo.EventInfoMain_Tmp
		SET FirstimeFound = 0
	FROM SYSAdmin.dbo.EventInfoMain_Tmp t2
	RIGHT JOIN #EventInfoMain_Tmp t1
	ON
		t1.MnSpid = t2.Spid AND 
		t1.MnSpid_BlockedBy = t2.BlkBySpid AND
		t1.MnResource_db_id = t2.Resource_db_id
	WHERE t2.FirstimeFound = 1 AND t1.MnSpid IS NOT NULL
	
--Inserts all new records INTO SYSAdmin.dbo.EventInfoMain_Tmp FROM #EventInfoMain_Tmp.
	INSERT INTO SYSAdmin.dbo.EventInfoMain_Tmp 
		(	Resource_db_id, DBName,
			Spid, SpidEventInfo,
			BlkBySpid, BlkByEventInfo,
			blkby_status, 
			blkby_loginame,
			blkby_nt_username,
			blkby_hostname,
			blkby_net_address,
			spid_command,
			blkby_program_name,
			spid_wait_type			
		)
		SELECT 
			t1.MnResource_db_id, t1.DBName,
			t1.MnSpid, t1.MnEventInfo,
			t1.MnSpid_BlockedBy, MnBlockedByInfo,
			t1.blkby_status, 
			t1.blkby_loginame,
			t1.blkby_nt_username,
			t1.blkby_hostname,
			t1.blkby_net_address,
			t1.spid_command,
			t1.blkby_program_name,
			t1.spid_wait_type
						
		FROM #EventInfoMain_Tmp t1
		WHERE NOT EXISTS
			(
			SELECT 
				t2.Spid
			FROM
				SYSAdmin.dbo.EventInfoMain_Tmp t2
			WHERE 
				t1.MnSpid = t2.Spid AND 
				t1.MnSpid_BlockedBy = t2.BlkBySpid AND
				t1.MnResource_db_id = t2.Resource_db_id
			)	

END

	SET @servername  = @@servername
	SET @servername = LTRIM(RTRIM(@servername))

	-- Generate report subject.
	SELECT @emailSubject= 'MON_SQL : Alert!! Lock situation on ' + @client + ' : ' + @servername  + ' Server'

	-- Generate report heading and column headers
		Set @email_body = 'Block Report' + ' : v06_2012'
		Set @email_body = @email_body + CHAR(13) + CHAR(10)+ '  ' + CHAR(13) + CHAR(10)
		Set @email_body = @email_body + 'Blocking found on ' + @servername  + ' at ' + (CONVERT(VARCHAR(20),getdate(),120))
		Set @email_body = @email_body + CHAR(13)+CHAR(10)
		Set @email_body = @email_body + '--------------------------------------------------------------------------'
		Set @email_body = @email_body + CHAR(13)+CHAR(10)
		Set @email_body = @email_body + ('  ') + CHAR(13)+CHAR(10)
		
	-- Create Email Body
	INSERT INTO #EventInfoEmail
		(	email	)
		SELECT A = (
			'  ----------------------- ' + CHAR(13)+ CHAR(10) +
			'  SPID / BLKBY.SPID / BLKBY.HOSTNAME / BLKBY.LOGINAME ' + 
			CHAR(13)+ CHAR(10) + '  ' +
			LTRIM(RTRIM(CAST(ISNULL(Spid,'') AS VARCHAR(4)))) + ' - ' + 
			LTRIM(RTRIM(CAST(ISNULL(BlkBySpid,'') AS VARCHAR(4)))) + ' - ' +  
			LTRIM(RTRIM(CAST(ISNULL(blkby_hostname,'') AS NVARCHAR(256)))) + ' - ' +  
			LTRIM(RTRIM(CAST(ISNULL(blkby_loginame,'') AS NVARCHAR(256)))) + ' (' + 	
			LTRIM(RTRIM(CAST(ISNULL(blkby_nt_username,'') AS NVARCHAR(256)))) + ')'					
			+ CHAR(13)+CHAR(10) + ' ' + CHAR(13)+CHAR(10) +
			'  SPID Details' + CHAR(13)+CHAR(10) +
			'  ----------------------- ' + CHAR(13)+CHAR(10) + '  ' +
			LTRIM(RTRIM(CAST(ISNULL(Spid,'') AS VARCHAR(4)))) + ' - ' + 
			LTRIM(RTRIM(CAST(ISNULL(SpidEventInfo,'') AS NVARCHAR(1000)))) + CHAR(13)+CHAR(10) +
			' - ' + CHAR(13)+CHAR(10) +
			'  BLKBY.SPID Details ' + CHAR(13)+CHAR(10) +
			'  ----------------------- ' + CHAR(13)+CHAR(10) + '  ' +
			LTRIM(RTRIM(CAST(ISNULL(BlkBySpid,'') AS VARCHAR(4)))) + ' - ' + 
			LTRIM(RTRIM(CAST(ISNULL(BlkByEventInfo,'') AS NVARCHAR(1000)))) + CHAR(13)+CHAR(10))						
		FROM SYSAdmin.dbo.EventInfoMain_Tmp 
		WHERE 
			FirstimeFound = 0 AND 
			EmailSent = 0 
		ORDER BY Spid

IF (SELECT COUNT(email) FROM #EventInfoEmail) >= @blocking_thresh_hold
BEGIN
	BEGIN TRY

		SET @x = (SELECT  COUNT(email) FROM #EventInfoEmail)
		SET @z = 1
		WHILE @z <= @x
		BEGIN
		   SET @email_body = @email_body + RTRIM((SELECT email FROM #EventInfoEmail WHERE id = @z))
		   SET @email_body = @email_body + CHAR(13)+CHAR(10)
		   SET @email_body = @email_body + ' '
		   SET @email_body = @email_body + CHAR(13)+CHAR(10)
		   SET @z = @z + 1
		END

		--Email
		EXEC msdb.dbo.sp_send_dbmail
			@profile_name = @mail_profile_name,
			@recipients = @mail_recipients,
			@copy_recipients = @mail_copy_recipients,
			@blind_copy_recipients = @mail_blind_copy_recipients,
			@subject = @emailSubject,
			@body = @email_body;		

	--Updates SYSAdmin.dbo.EventInfoMain_Tmp UPDATING EmailSent to 1.
	--This section could be commented out if you wish to be spammed every minute
	--for all blocks that are still occuring.
	UPDATE SYSAdmin.dbo.EventInfoMain_Tmp
		SET EmailSent = 1			
	FROM SYSAdmin.dbo.EventInfoMain_Tmp t2
	RIGHT JOIN #EventInfoMain_Tmp t1
	ON
		t1.MnSpid = t2.Spid AND 
		t1.MnSpid_BlockedBy = t2.BlkBySpid AND
		t1.MnResource_db_id = t2.Resource_db_id
	WHERE t2.FirstimeFound = 0 AND t2.EmailSent = 0 AND t1.MnSpid IS NOT NULL	

	--------------------------------------------------------------------------------
	--Log DB Problem to Windows Application Event Log
	--------------------------------------------------------------------------------

		--Truncating the servername down to VARCHAR(45) because of space issues within the Eventlog.
		SET @servername = CAST(@servername AS VARCHAR(45))
		SET @servername = LTRIM(RTRIM(@servername))

		SET @event_totalblocks = (SELECT COUNT(Spid) FROM SYSAdmin.dbo.EventInfoMain_Tmp)
		SET @event_message = '; ' + @servername + '; BLOCKING WARNING; ' + (CONVERT(VARCHAR(20),getdate(),120))  
				+ '; (Blocked SPID, ' + CAST(@event_totalblocks AS VARCHAR) + ')'

		--Generates Windows App Event log message & SQL Log Error
		EXEC master.dbo.xp_logevent 77022, @event_message, ERROR
		
		/* --Generates Windows App Event log message & SQL Log Error & Returns the error to the client.
		RAISERROR (
			@event_message, -- Message text.
			0, -- Severity 0 to 18,
			1   -- State
		) 
		WITH LOG
		*/
	--------------------------------------------------------------------------------
	--------------------------------------------------------------------------------

	END TRY
	BEGIN CATCH	
	END CATCH
END

--SELECT * FROM #EventInfoMain_Tmp
--SELECT * FROM SYSAdmin.dbo.EventInfoMain_Tmp
--SELECT Top 100 * FROM SYSAdmin.dbo.EventInfoMain_His	ORDER BY dtStampFound DESC

TRUNCATE TABLE #EventInfoMain_Tmp

--DROP TABLE #EventInfoMain_Tmp
--DROP TABLE SYSAdmin.dbo.EventInfoMain_Tmp
--DROP TABLE SYSAdmin.dbo.EventInfoMain_His

END --Blackout Check
GO
/****** Object:  StoredProcedure [dbo].[usp_UploadBackupStats]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE [dbo].[usp_UploadBackupStats] as
-------SQL 2005 EDITION  v2010.01.15----------------------------
----------------------------------------------------------------
-- This proc reports all successfull database backup stats for 
-- Full, Differential, and Filegroup backups to DBDepot.
-- 
-- Execute the following command to view all settings for this script:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_UploadBackupStats'
--
-- 	mail_profile_name = SQL DBMail profile name to be used by this script.
--	mail_recipients = Email Address to send messages TO
----------------------------------------------------------------

SET NOCOUNT ON
DECLARE
    @last_exec_date_temp VARCHAR(30),
    @last_exec_date DATETIME,
    @x INT,
    @z INT,
    @rc INT,
    
	@date VARCHAR(50),
	@time VARCHAR(15),
	@random_number INT,
	@random_upper INT,
	@random_lower INT,
    @totalNodes INT,
	@error BIT,
	
	@client_domain VARCHAR(50),
	@client_name VARCHAR(50),
	@host_name VARCHAR(100),
	@instance_a_instance_name VARCHAR(100), 
	@time_zone VARCHAR(50),
	
	@email_header VARCHAR(150),
	@email_footer VARCHAR(150),
	@email_body VARCHAR(8000),
	@record_host VARCHAR(4000),
	@record_instance VARCHAR(4000),
	@record_database VARCHAR(8000),
	@mon_sql_version as varchar(50),
    
	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000),

	@1 VARCHAR(100),
	@2 VARCHAR(100),
	@3 VARCHAR(100),
	@4 VARCHAR(100),
	@5 VARCHAR(100);

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_UploadBackupStats') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG 
		(proc_name, mail_profile_name, mail_recipients)
		VALUES 
		('usp_UploadBackupStats','SQL_DBMail','stats@dbdepot.iweb.eds.com')
	END 

	SELECT  
		@mail_profile_name = mail_profile_name,
		@mail_recipients = mail_recipients,
		@mail_copy_recipients = mail_copy_recipients,
		@mail_blind_copy_recipients = mail_blind_copy_recipients,
		@last_exec_date_temp = variable1
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_UploadBackupStats';	

	SELECT  
		@client_domain = variable1,
		@client_name = variable2
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_UploadStatsProc';
	
	SELECT  
		@mon_sql_version = variable1
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'MON_SQL_VERSION';

--Confirm a MON_SQL version exists.
SET @mon_sql_version = ISNULL(@mon_sql_version,'MON_SQL')
IF (@mon_sql_version = '') SET @mon_sql_version = 'MON_SQL'		

--A random number will be generated later in the script to be used as part of the 
--email subject line.
SET @random_lower = 200 ---- The lowest random number
SET @random_upper = 99999 ---- The highest random number
SET @error = 0
SET @record_database = ''

--Check for default or NULL values listed for DBDepot Client Name or Client Domain
--variable1 & variable2
--If Default or NULL values are found, no email is sent.
IF (@client_domain IS NULL) OR (@client_domain = 'CLIENT.DOMAIN') OR (@client_domain = '') OR
	(@client_name IS NULL) OR (@client_name = 'CLIENT.NAME') OR (@client_name = '')
BEGIN
	RAISERROR ('Aborting usp_UploadBackupStats execution because a default or null value is stored within dbo.MON_SQL_CFG for usp_UploadStatsProc.  NULL or default values of CLIENT.DOMAIN & CLIENT.NAME within variable1 or variable2 not allowed.', 18, 1) WITH NOWAIT	
	SET @error = 1
END

IF object_id('tempdb..#temp_ClusterNodes', 'U') is not null 
	DROP TABLE #temp_ClusterNodes

--Used to hold DB info that have been backed up.
IF object_id('tempdb..#tblBackupHistory', 'U') IS NOT NULL
BEGIN
	TRUNCATE TABLE #tblBackupHistory
END
ELSE
BEGIN
	CREATE TABLE #tblBackupHistory (
		database_name		NVARCHAR(256) null,
		backup_start_date	VARCHAR(20),
		backup_finish_date	VARCHAR(20),
		backup_size			DEC(15,2),
		backup_type			CHAR(4)
	)			
END

--Create temp table to store Cluster Node Names if they exist. 
CREATE TABLE #temp_ClusterNodes (
	id INT NOT NULL IDENTITY (1, 1),
	a_host_name VARCHAR(50)
)

--Setting default values for @totalNodes
SET @totalNodes = 1

--Change @totalNodes to correct number if other nodes exist.
IF (SELECT COUNT(*) FROM ::fn_virtualservernodes()) > 0 
  BEGIN
	SET @totalNodes = (SELECT COUNT(*) FROM ::fn_virtualservernodes())
	INSERT INTO #temp_ClusterNodes SELECT NodeName FROM ::fn_virtualservernodes()
  END 

--Retrieving instance data from SYSAdmin..Upload_Stats to be used for 
--all db backup records.
SELECT TOP 1
	@instance_a_instance_name = LTRIM(RTRIM(ISNULL(a_instance_name,''))),
	@host_name = LTRIM(RTRIM(ISNULL(a_host_name,''))),
	@time_zone = LTRIM(RTRIM(ISNULL(a_time_zone,'')))
FROM SYSAdmin.dbo.Upload_Stats
WHERE a_db_type = 'DATABASE'

--Set last execution date to report from.  
IF ISDATE(@last_exec_date_temp) > 0
BEGIN
	SET @last_exec_date = CONVERT(DATETIME,@last_exec_date_temp)
END
ELSE
BEGIN
	SET @last_exec_date = (DATEADD(hh, -24, GETDATE()))
END

--******************************************
------------------------------------
----------DELETE FOR PRODUCTION
------------------------------------

--SET @last_exec_date = (DATEADD(mm, -300, GETDATE()))

------------------------------------
----------DELETE FOR PRODUCTION
------------------------------------
--******************************************

INSERT INTO #tblBackupHistory
SELECT
	CAST(database_name AS NVARCHAR(256)) AS db_name,
	CONVERT(VARCHAR(20),backup_start_date,120) AS backup_start_date,
	CONVERT(VARCHAR(20),DATEADD(s,1,backup_finish_date),120) AS backup_finish_date,
	CAST((backup_size/1024)/1024 AS DECIMAL(15,2)) AS backup_size,
	CASE 
	WHEN type = 'D' THEN 'Full'
	WHEN type = 'L' THEN 'TLog'
	WHEN type = 'I' THEN 'Diff'
	WHEN type = 'F' THEN 'File'
	END AS backup_type
FROM msdb..backupset
WHERE backup_finish_date > @last_exec_date
	AND type <> 'L'
	AND database_name IN
	(
		SELECT REPLACE(a_instance_name_temp COLLATE SQL_Latin1_General_CP1_CI_AS,']','')
		FROM
		( SELECT
			REPLACE(a_instance_name COLLATE SQL_Latin1_General_CP1_CI_AS,'[','') AS a_instance_name_temp 
		  FROM SYSAdmin.dbo.Upload_Stats
		) AS b
	)
ORDER BY db_name, backup_start_date

--Check for new backup records to report on.
IF (SELECT COUNT(database_name) FROM #tblBackupHistory) > 0
BEGIN

--This WHILE statement will re-send the same email multiple times to account for different cluster nodes.
SET @x = @totalNodes --CLUSTER WHILE LOOP START
SET @z = 1
WHILE @z <= @x
BEGIN
	--If more than 1 node exists, assume this is a cluster.
	--Changing the host_name sent to DBDepot to duplicate every email for all Nodes.
	IF @totalNodes > 1
	BEGIN
	  SET @host_name = LTRIM(RTRIM((SELECT a_host_name FROM #temp_ClusterNodes where id = @z)))
	END
			
	--Formating time/date to be used for Header/Footer details.
	SELECT @date = CONVERT(VARCHAR(50),GETDATE(),112)
	SELECT @time = REPLACE(CONVERT(VARCHAR(15),GETDATE(),108),':','')

	--Creating Host Record
	SELECT TOP 1 @record_host = 
		'exec dbateam.stats.upload_host_stats ( -' + CHAR(13)+CHAR(10)
		+ '  a_host_name=>''' + ISNULL((@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_domain_name=>'''  + ISNULL(RTRIM(a_domain_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_os_type=>''' + ISNULL(RTRIM(a_os_type),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_os_version=>''' + ISNULL(RTRIM(a_os_version),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_uptime_days=>''' + ISNULL(RTRIM(a_uptime_days),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_time_zone=>''' + ISNULL(RTRIM(a_time_zone),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_client_name=>''' + ISNULL(RTRIM(@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_method=>''email'', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_to=>''' + ISNULL(RTRIM(@mail_recipients),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_version=>''' + ISNULL(@mon_sql_version,'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_refresh_yn=>''N'' -' + CHAR(13)+CHAR(10)
		+ ');' 
		+ CHAR(13)+CHAR(10)
		+ CHAR(13)+CHAR(10)
	FROM SYSAdmin.dbo.Upload_Stats
	WHERE a_db_type = 'DATABASE'            

	--Creating Instance Record
	SELECT TOP 1 @record_instance =
		'exec dbateam.stats.upload_instance_stats ( -' + CHAR(13)+CHAR(10)
		+ '  a_host_name=>''' + ISNULL((@host_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_domain_name=>'''  + ISNULL(RTRIM(a_domain_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_instance_name=>''' + ISNULL(RTRIM(@instance_a_instance_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_files_mb=>' + ISNULL(RTRIM(a_files_mb),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_segments_mb=>' + ISNULL(RTRIM(a_segments_mb),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_log_mode=>''' + ISNULL(RTRIM(a_log_mode),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_db_version=>''' + ISNULL(RTRIM(a_db_version),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_listener_port=>' + ISNULL(RTRIM(a_listener_port),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_startup_time=>TO_DATE(''' + ISNULL(RTRIM(a_startup_time),'') + ''',''yyyy-mm-dd hh24:mi:ss''), -' + CHAR(13)+CHAR(10)
		+ '   a_num_schemas=>' + ISNULL(RTRIM(a_num_schemas),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_num_tables=>' + ISNULL(RTRIM(a_num_tables),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_num_objects=>' + ISNULL(RTRIM(a_num_objects),'') + ', -' + CHAR(13)+CHAR(10)
		+ '   a_db_type=>''' + ISNULL(RTRIM(a_db_type),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_vendor=>''' + ISNULL(RTRIM(a_vendor),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_client_name=>''' + ISNULL(RTRIM(@client_name),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_method=>''email'', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_to=>''' + ISNULL(RTRIM(@mail_recipients),'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_version=>''' + ISNULL(@mon_sql_version,'') + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_upload_stats_refresh_yn=>''N'' -'  + CHAR(13)+CHAR(10)
		+ ');'
		+ '  ' + CHAR(13)+CHAR(10)
		+ '  ' + CHAR(13)+CHAR(10)
	FROM SYSAdmin.dbo.Upload_Stats
	WHERE a_db_type = 'DATABASE'  
	
	--Inserting all database records into @email_body
	DECLARE email_cursor CURSOR FOR  
		SELECT 
			database_name,backup_start_date,backup_finish_date,backup_size,backup_type
		FROM #tblBackupHistory
	OPEN email_cursor
	FETCH NEXT FROM email_cursor INTO
		@1, @2, @3, @4, @5

	WHILE( @@FETCH_STATUS = 0 )
	BEGIN
		SET @1 = ISNULL(@1,'')
		SET @2 = ISNULL(@2,'')
		SET @3 = ISNULL(@3,'')
		SET @4 = ISNULL(@4,'')
		SET @5 = ISNULL(@5,'')

		--Email formatting for backup Info
		SELECT @record_database = @record_database +
		'exec dbateam.stats.upload_backup_stats ( -' + CHAR(13)+CHAR(10)
		+ '  a_host_name=>''' + RTRIM(@host_name) + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_domain_name=>'''  + RTRIM(@client_domain) + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_instance_name=>''' + RTRIM(@instance_a_instance_name) + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_user_db_name=>''' + RTRIM(@1) + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_begin_datetime=>TO_DATE(''' + RTRIM(@2) + ''',''yyyy-mm-dd hh24:mi:ss''), -' + CHAR(13)+CHAR(10)
		+ '   a_end_datetime=>TO_DATE(''' + RTRIM(@3) + ''',''yyyy-mm-dd hh24:mi:ss''), -' + CHAR(13)+CHAR(10)
		+ '   a_files_mb=> ' + RTRIM(@4) + ', -' + CHAR(13)+CHAR(10)
		+ '   a_backup_type=>''' + RTRIM(@5) + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_backup_status=>0, -' + CHAR(13)+CHAR(10)
		+ '   a_backup_errors=>'''', -' + CHAR(13)+CHAR(10)
		+ '   a_time_zone=>'''  + RTRIM(@time_zone) + ''', -' + CHAR(13)+CHAR(10)
		+ '   a_backup_software=>''SQLServer'' -' + CHAR(13)+CHAR(10)
		+ ');'
		+ '  ' + CHAR(13)+CHAR(10)
		+ '  ' + CHAR(13)+CHAR(10)

	FETCH NEXT FROM email_cursor into
		@1, @2, @3, @4, @5

	END
	CLOSE email_cursor
	DEALLOCATE email_cursor

	--Generate a random number for use with the email subject and header.
	SELECT @random_number = ROUND(((@random_upper - @random_lower -1) * RAND() + @random_lower), 0)

	--Header
	SELECT @email_header = ('upload_stats.' + @host_name + '.' + @instance_a_instance_name + '.' + RTRIM(CONVERT(VARCHAR(10),@random_number)) + '.' + @date + '.' + @time + '.sql')

	--Footer
	SELECT @email_footer = 'REM end ' + RTRIM(@email_header)

	--Inserting the Header, Host, & Instances records into @email_body
	SELECT @email_body = 'REM begin '+ RTRIM(@email_header)
	+ '  ' + CHAR(13)+CHAR(10)
	+ '  ' + CHAR(13)+CHAR(10)
	SELECT @email_body = @email_body + @record_host
	SELECT @email_body = @email_body + @record_instance

	--Inserting the Backup Records
	SELECT @email_body = @email_body + @record_database

	--Inserting Footer into @email_body
	SET @email_body = @email_body + @email_footer

	--Email
	IF (@email_body IS NULL) OR 
		(@email_header IS NULL) OR 
		(@mail_recipients IS NULL) 
	BEGIN
	RAISERROR ('NULL value passed to xp_smtp_sendmail, SYSAdmin.dbo.usp_UploadBackupStats aborting.', 18, 1) WITH NOWAIT
	SET @error = 1
	END ELSE
	BEGIN
		IF @error = 0
		BEGIN
			EXEC msdb.dbo.sp_send_dbmail
				@profile_name = @mail_profile_name,
				@recipients = @mail_recipients,
				@copy_recipients = @mail_copy_recipients,
				@blind_copy_recipients = @mail_blind_copy_recipients,
				@subject = @email_header,
				@body = @email_body;	
		END		
	END

SET @z = @z + 1

END --CLUSTER WHILE LOOP END
END --Check for new backup records to report on.

IF @error = 0
BEGIN	
	--Updating the last execution timestamp
	UPDATE SYSAdmin.dbo.MON_SQL_CFG
		SET variable1=CONVERT(VARCHAR,GETDATE(),120)
	WHERE proc_name = 'usp_UploadBackupStats'
END

DROP TABLE #temp_ClusterNodes
DROP TABLE #tblBackupHistory

--We only want to report database backups for databases that have already been submitted to DBDepot.
--If any new databases are found, the SQL job '*DBDepot UpStats' will be launched, but the new databases
--will not be reported on until the next execution, which should be a minimum of 1 day to avoid import 
--errors in DBDepot.
--Returns greater than 0 if any databases are found that do NOT currently exist in SYSAdmin.dbo.Upload_Stats
IF (
SELECT COUNT(name) FROM master.dbo.sysdatabases( nolock )
WHERE 
	DATABASEPROPERTYEX(name, 'STATUS') = 'ONLINE'
	AND name NOT IN ('master','model','msdb','tempdb','pubs','Northwind')
	AND name NOT IN
	(
		SELECT REPLACE(a_instance_name_temp COLLATE SQL_Latin1_General_CP1_CI_AS,']','')
		FROM
		( SELECT
			REPLACE(a_instance_name COLLATE SQL_Latin1_General_CP1_CI_AS,'[','') AS a_instance_name_temp 
		  FROM SYSAdmin.dbo.Upload_Stats
		) AS b
	)
) > 0
BEGIN
	EXEC msdb.dbo.sp_start_job @job_name = '*DBDepot UpStats'
END	


GO
/****** Object:  StoredProcedure [dbo].[usp_UploadStatsProc]    Script Date: 2/17/2023 4:17:29 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_UploadStatsProc] AS
-------SQL 2005 EDITION v2009.12.31-----------------------------
----------------------------------------------------------------
-- This proc retrieves SYSTEM and DB information and stores it in
-- SYSAdmin.dbo.Upload_Stats
--
-- Execute the following command to view all settings for this script:
-- SELECT * FROM SYSAdmin.dbo.MON_SQL_CFG WHERE proc_name = 'usp_UploadStatsProc'
--
-- 	mail_profile_name = SQL DBMail profile name to be used by this script.
--	mail_recipients = Email Address to send messages TO
--	variable1 = Domain name as listed in DBDepot.
--		It is case sensitive, and must match DBDepot exactly! (DEFAULT = CLIENT.DOMAIN)
--	variable2 = Client name as listed in DBDepot. 
--		It is case sensitive, and must match DBDepot exactly! (DEFAULT = CLIENT.NAME)
----------------------------------------------------------------

SET NOCOUNT ON

DECLARE
	@sql				NVARCHAR( 4000 ),

	@db_name			VARCHAR(100),
	@instancedb			VARCHAR(100),
	@timezone			VARCHAR(100),
	@vendor				VARCHAR(20),
	@db_version			VARCHAR(30),
	@db_type			VARCHAR(20),
	@log_mode			VARCHAR(10),

	@os_name			VARCHAR(100),
	@os_type			VARCHAR(50),
	@os_version			VARCHAR(15),
	@os_ver				VARCHAR(5),
	@os_build			VARCHAR(15),
	@os_temp			VARCHAR(255),
	@Version_Raw		VARCHAR(255),
		
	@startup_time		VARCHAR(50),
	@uptime_days		VARCHAR(10),
	    
	@listener_port		VARCHAR(6),
	@instance_name		VARCHAR(75),

	@host_name			VARCHAR(100),
	@domain_name		VARCHAR(30),
	@files_mb			VARCHAR(50),
	@segments_mb		VARCHAR(50),
	@num_schemas		VARCHAR(10),
	@num_tables			VARCHAR(10),
	@num_objects		VARCHAR(10),
	
	@dbsize				BIGINT,
	@logsize			BIGINT,
	@reservedpages		BIGINT,
	@usedpages			BIGINT,
	@pages				BIGINT,
	
	@patindex			INT,
	@pointer1			INT,

	@master_collation	VARCHAR(100),
	@db_name_original	VARCHAR( 50 ),
	@files_mb_old		VARCHAR(50),
	@segments_mb_old	VARCHAR(50),
	@os_bits			INT,

	@mail_profile_name VARCHAR(100),
	@mail_recipients VARCHAR(8000),
	@mail_copy_recipients VARCHAR(8000),
	@mail_blind_copy_recipients VARCHAR(8000);

	IF (object_id('SYSAdmin.dbo.MON_SQL_CFG', 'U') IS NOT NULL) AND
		(SELECT COUNT(proc_name) 
		FROM SYSAdmin.dbo.MON_SQL_CFG 
		WHERE proc_name = 'usp_UploadStatsProc') = 0
	BEGIN
		INSERT INTO SYSAdmin.dbo.MON_SQL_CFG 
			(proc_name, mail_profile_name, mail_recipients, variable1, variable2)
			VALUES ('usp_UploadStatsProc','SQL_DBMail','stats@dbdepot.iweb.eds.com','CLIENT.DOMAIN','CLIENT.NAME')
	END

	SELECT  
		@mail_profile_name = mail_profile_name,
		@mail_recipients = mail_recipients,
		@mail_copy_recipients = mail_copy_recipients,
		@mail_blind_copy_recipients = mail_blind_copy_recipients,
		@domain_name = variable1
	FROM SYSAdmin.dbo.MON_SQL_CFG
	WHERE proc_name = 'usp_UploadStatsProc';
		
--Check for Temp tables and drop if they currently exist.
IF object_id('tempdb..#temp_size', 'U') IS NOT NULL
	DROP TABLE #temp_size	
IF object_id('tempdb..#temp_tables', 'U') IS NOT NULL
	DROP TABLE #temp_tables
IF object_id('tempdb..#temp_objects', 'U') IS NOT NULL
	DROP TABLE #temp_objects
IF object_id('tempdb..#dbname', 'U') IS NOT NULL 
	DROP TABLE #dbname
IF object_id('tempdb..##temp_new_offline', 'U') IS NOT NULL
	DROP TABLE ##temp_new_offline
IF object_id('tempdb..##temp_old_offline', 'U') IS NOT NULL
	DROP TABLE ##temp_old_offline
IF object_id('tempdb..#temp_Upload_Stats', 'U') IS NOT NULL
	DROP TABLE #temp_Upload_Stats

--Create necessary temp tables 
CREATE TABLE #temp_size ( db_total_mb DEC(15,2), db_used_mb DEC(15,2))
CREATE TABLE #temp_tables ( table_cnt INT )
CREATE TABLE #temp_objects ( object_cnt INT)
CREATE TABLE #dbname ( dbname VARCHAR(1000))

--retrieve current collation
SELECT @master_collation = LTRIM(RTRIM(CONVERT(sysname, SERVERPROPERTY(N'collation'))))

--Copy existing Upload_Stats data into a temp table. 
SELECT * INTO #temp_Upload_Stats FROM SYSAdmin.dbo.Upload_Stats

--Delete the current info in SYSAdmin.dbo.Upload_Stats
DELETE SYSAdmin.dbo.Upload_Stats

--Creates a Global Temporary Table of all Databases that are no longer ONLINE
--and that originally had data stored in Upload_Stats.  Since no DB info can be 
--retrieved from an OFFLINE database, I copy the existing Upload_Stats info into 
--##temp_old_offline.
SET @sql = '
	SELECT P.name, S.a_instance_name,
	S.a_files_mb,S.a_segments_mb,S.a_num_schemas,S.a_num_tables,S.a_num_objects
	INTO ##temp_old_offline
	FROM 
	master.dbo.sysdatabases P ( nolock )
	RIGHT JOIN
	#temp_Upload_Stats S
	ON
	CAST(P.name AS VARCHAR) = CAST((LTRIM(RTRIM( 
			 SUBSTRING(S.a_instance_name,
			(CHARINDEX(' + CHAR(39) + '[' + CHAR(39) + ',S.a_instance_name) + 1),
			(LEN(S.a_instance_name)) - (CHARINDEX(' + CHAR(39) + '[' + CHAR(39) +',S.a_instance_name)) - 1)
			 ))) AS VARCHAR) COLLATE ' + @master_collation + '
	WHERE 
	DATABASEPROPERTYEX(P.name, ' + CHAR(39) + 'STATUS' + CHAR(39) + ') != ' + CHAR(39) + 'ONLINE' + CHAR(39)
EXEC sp_executesql @sql

--Creates a Global Temporary Table of all Databases that are NOT ONLINE
--and that have NO data stored in Upload_Stats.  Since no DB info can be 
--retrieved from an OFFLINE database, I retrieve a list of DB names into
--##temp_new_offline.  The data will be inserted into Upload_Stats with 
--dummy values.
SET @sql = '
	SELECT P.name
	INTO ##temp_new_offline
	FROM 
	master.dbo.sysdatabases P ( nolock )
	LEFT JOIN
	##temp_old_offline S
	ON
	(P.name = S.name)
	WHERE 
	DATABASEPROPERTYEX(P.name, ' + CHAR(39) + 'STATUS' + CHAR(39) + ') != ' + CHAR(39) + 'ONLINE' + CHAR(39)
	+ ' AND
	S.name is NULL'
exec sp_executesql @sql

--SET the db vendor
SELECT @vendor = 'SQL Server'

-- SET the db type & LOG MODE variables
SELECT @db_type = 'DATABASE'
SELECT @log_mode = 'KEEP'

--SET the startup time
SELECT @startup_time = CONVERT(VARCHAR(50),(SELECT crdate FROM master.dbo.sysdatabases WHERE name = 'tempdb'),120)

--SET the uptime_days for host
SELECT @uptime_days = DATEDIFF(day, @startup_time, getdate())

-- To get SQL 2005 default port
EXEC master.dbo.xp_instance_regread 
   'HKEY_LOCAL_MACHINE',
   'SOFTWARE\Microsoft\Microsoft SQL Server\MSSQLServer\SuperSocketNetLib\Tcp\IPAll',
   'TcpPort',
            @listener_port OUTPUT


--Cursor to get db size and number of objects in each database.
DECLARE db_name_cursor INSENSITIVE CURSOR FOR
	SELECT name FROM master.dbo.sysdatabases( nolock )
		WHERE 
			DATABASEPROPERTYEX(name, 'STATUS') = 'ONLINE'
OPEN db_name_cursor
FETCH NEXT FROM db_name_cursor INTO @db_name

SELECT @db_name = '[' + @db_name + ']'    

WHILE( @@FETCH_STATUS <> -1 )
   BEGIN
         
			--Setting the variables for @dbsize & @logsize
			--For use in calulating database disk usage
			SET @sql =		
			'SELECT
				@dbsize_iVar1 = SUM(CONVERT(BIGINT,CASE WHEN status & 64 = 0 THEN size ELSE 0 END)),
				@logsize_iVar2 = SUM(CONVERT(BIGINT,CASE WHEN status & 64 <> 0 THEN size ELSE 0 END))
			FROM ' + @db_name + '.dbo.sysfiles'
			EXEC sp_executesql @sql, 
				N'@dbsize_iVar1 BIGINT OUT,
				@logsize_iVar2 BIGINT OUT',
				
				@dbsize out,
				@logsize out;

			--Setting the variables for @reservedpages, @usedpages, and @pages.
			--For use in calulating database disk usage	
			SET @sql =
			'SELECT 
				@reservedpages_iVar1 = SUM(a.total_pages),
				@usedpages_iVar2 = SUM(a.used_pages),
				@pages_iVar3 = SUM(
						CASE
							-- XML-Index and FT-Index-Docid is not considered "data", but is part of "index_size"
							WHEN it.internal_type IN (202,204) THEN 0
							WHEN a.type <> 1 THEN a.used_pages
							WHEN p.index_id < 2 THEN a.data_pages
							ELSE 0
						END
						)
			FROM ' + @db_name + '.sys.partitions p JOIN ' + @db_name + '.sys.allocation_units a 
			ON p.partition_id = a.container_id
			LEFT JOIN ' + @db_name + '.sys.internal_tables it 
			ON p.object_id = it.object_id'

			EXEC sp_executesql @sql, 
				N'@reservedpages_iVar1 BIGINT OUT,
				@usedpages_iVar2 BIGINT OUT,
				@pages_iVar3 BIGINT OUT',
				
				@reservedpages out,
				@usedpages out,
				@pages out;
				
			--Total space of db files				
			SET @sql =	
				N'SELECT @dbsize_iVar1= ' +
					'SUM(CONVERT(DEC(15),size)) ' +
					'FROM ' + @db_name + '.dbo.sysfiles( nolock ) ' +
					'WHERE (status & 64 = 0);'
			EXEC sp_executesql @sql, 
				N'@dbsize_iVar1 DEC(15) OUT', @dbsize out;

			INSERT INTO #temp_size	(db_total_mb, db_used_mb)		
			SELECT 
			database_size = LTRIM(STR((CONVERT (DEC (15,2),@dbsize) + 
				CONVERT (DEC (15,2),@logsize)) * 8192 / 1048576,15,2)),
			used_space=
				LTRIM(STR((((CONVERT (DEC (15,2),@dbsize) + CONVERT (DEC (15,2),@logsize)) * 8192 / 1048576) -
				CASE WHEN @dbsize >= @reservedpages THEN	
				(CONVERT (DEC (15,2),@dbsize) - CONVERT (DEC (15,2),@reservedpages)) * 8192 / 1048576 
				ELSE 0 END),15,2))				

            IF @db_name NOT IN('[model]', '[tempdb]', '[pubs]', '[northwind]')
             BEGIN
				insert #dbname values (@db_name)

				SELECT @sql = 'SELECT COUNT(*) FROM ' + @db_name + '.dbo.sysobjects( nolock ) WHERE name <> ''dtproperties'' AND type = ''U''' 
				INSERT INTO #temp_tables
				EXEC( @sql )

				SELECT @sql = 'SELECT COUNT(*) FROM ' + @db_name + '.dbo.sysobjects( nolock ) WHERE (type = ''P'' OR type = ''TR'') AND name NOT LIKE ''dt_%''' 
				INSERT INTO #temp_objects
				EXEC( @sql )
               END
            FETCH NEXT FROM db_name_cursor INTO @db_name

        SELECT @db_name = '[' + @db_name + ']'
   END

SELECT @files_mb = SUM( db_total_mb) FROM #temp_size
SELECT @segments_mb = SUM( db_used_mb) FROM #temp_size

CLOSE db_name_cursor
DEALLOCATE db_name_cursor

--SET total space used by OFFLINE databases
SELECT @files_mb_old = (SELECT ISNULL(SUM( CONVERT(DEC(15,2), a_files_mb )),0) from ##temp_old_offline)
SELECT @segments_mb_old = (SELECT ISNULL(SUM( CONVERT(DEC(15,2), a_segments_mb )),0) from ##temp_old_offline)

--ADD OFFLINE database space to ONLINE database space.
SELECT @files_mb = (@files_mb + CONVERT(DEC(15,2),@files_mb_old))
SELECT @segments_mb = (@segments_mb + CONVERT(DEC(15,2),@segments_mb_old))

SELECT @num_schemas = 
	(SELECT CONVERT( VARCHAR(10), count( * )) 
	FROM master.dbo.sysdatabases where dbid > 6)

SELECT @num_tables =
	(SELECT CONVERT( VARCHAR( 10 ),	ISNULL(SUM( table_cnt ),0) +
		(SELECT ISNULL(SUM(CONVERT(INT, a_num_tables)),0) FROM ##temp_old_offline))		
	FROM #temp_tables)

SELECT @num_objects =
	(SELECT CONVERT( VARCHAR( 10 ),	ISNULL(SUM( object_cnt ),0)	+
		(Select ISNULL(SUM(CONVERT(INT, a_num_objects)),0) FROM ##temp_old_offline))
	 FROM #temp_objects)

--get the active computer name from the registry
EXEC master..xp_regread 'HKEY_LOCAL_MACHINE',
    'SYSTEM\ControlSet001\Control\ComputerName\ActiveComputerName',
    'ComputerName',
                @host_name OUTPUT

--Code to identify a bifurcated instance names on a cluster
SELECT @instance_name = @@SERVERNAME
SELECT @pointer1 = CHARINDEX('\', @instance_name)
SELECT @patindex = CHARINDEX(@host_name, @instance_name)

--This IF statement only evaluates as TRUE if the system is a NON-Clustered, Named instance.
IF @pointer1 != 0 AND @patindex !=0     -- this is a named instance, strip off the host info
BEGIN
   SELECT @instance_name = SUBSTRING(@instance_name, @pointer1 + 1, 40 - @pointer1)
END
SELECT @instance_name = REPLACE(@instance_name,'\','@')

--get and re-format the time zone from the local computer
EXEC master.dbo.xp_regread 'HKEY_LOCAL_MACHINE',
         'SYSTEM\CurrentControlSet\Control\TimeZoneInformation',
         'StandardName',
                @timezone OUTPUT

--Setting Timezone
SET @timezone = LTRIM(RTRIM((
SELECT shorttime = 
	CASE @timezone
		WHEN 'Eastern Standard Time' THEN 'EST'
		WHEN 'Central Standard Time' THEN 'CST'
		WHEN 'Mountain Standard Time' THEN 'MST'
		WHEN 'Pacific Standard Time' THEN 'PST'
		WHEN 'GMT Standard Time' THEN 'GMT'
		WHEN 'SA Eastern Standard Time' THEN 'ART'
		ELSE 'GMT'
	END
)))

--Set SQL version
SELECT @db_version = CONVERT(VARCHAR,SERVERPROPERTY('productversion')) + 
CASE CONVERT(VARCHAR,SERVERPROPERTY('edition'))
	WHEN 'Express Edition' THEN ' EX'
	WHEN 'Workgroup Edition' THEN ' WG'
	WHEN 'Standard Edition' THEN ' SE' 
	WHEN 'Enterprise Edition' THEN ' EE' 
	WHEN 'Standard Edition (64-bit)' THEN ' SE X64' 
	WHEN 'Enterprise Edition (64-bit)' THEN ' EE X64' 
	ELSE ' EVL'
END	

SELECT @db_version = @db_version + ' ' + CONVERT(VARCHAR,(SERVERPROPERTY('productlevel')))

--Extract OS version info from @@version
SELECT @Version_Raw =	@@version
SELECT @os_temp =		SUBSTRING(@Version_Raw,CHARINDEX('Windows',@Version_Raw),LEN(@Version_Raw) - CHARINDEX('Windows',@Version_Raw))
SELECT @os_ver =		SUBSTRING(@os_temp,12,3)
SELECT @os_build =		SUBSTRING(@os_temp,
						CHARINDEX('(Build',@os_temp) + 7,
						CHARINDEX(':',@os_temp) - (CHARINDEX('(Build',@os_temp) + 7))

SELECT @os_bits = CHARINDEX('64',CONVERT(VARCHAR,SERVERPROPERTY(N'Edition')))
SELECT @os_version = @os_ver + '.' + @os_build

IF @os_bits > 0
BEGIN
	SELECT @os_version = @os_version + ' X64'
END

SET @os_type = LTRIM(RTRIM((
SELECT os_name = 
	CASE @os_ver
		WHEN '5.0' THEN 'Windows 2000'
		WHEN '5.2' THEN 'Windows 2003'
		ELSE 'Windows'
	END
)))

INSERT SYSAdmin.dbo.Upload_Stats (
	a_instance_name, a_time_zone, a_listener_port, a_db_type,
	a_log_mode, a_host_name, a_domain_name, a_startup_time,
	a_uptime_days, a_os_type, a_os_version, a_vendor, a_db_version,
	a_files_mb, a_segments_mb, a_num_schemas, a_num_tables, a_num_objects
) VALUES (
	@instance_name, @timezone, @listener_port, @db_type, @log_mode, 
	@host_name, @domain_name, @startup_time, @uptime_days, @os_type,
	@os_version, @vendor, @db_version, @files_mb, @segments_mb, 
	@num_schemas, @num_tables, @num_objects
)

DELETE #temp_size
DELETE #temp_tables
DELETE #temp_objects
 
--This cursor then concatenates each user database name with the instance name to create unique 
--listsings for each database in DBDepot
DECLARE db_name_insert  INSENSITIVE CURSOR FOR
	SELECT name FROM master.dbo.sysdatabases( nolock )
		WHERE 
			DATABASEPROPERTYEX(name, 'STATUS') = 'ONLINE'

OPEN db_name_insert
FETCH NEXT FROM db_name_insert INTO @db_name
SELECT @db_name = '[' + @db_name + ']'

WHILE( @@FETCH_STATUS <> -1 )
   BEGIN

	IF @db_name NOT IN('[model]', '[tempdb]', '[pubs]', '[northwind]')
	BEGIN

		--Setting the variables for @dbsize & @logsize
		--For use in calulating database disk usage
		SET @sql =		
		'SELECT
			@dbsize_iVar1 = SUM(CONVERT(BIGINT,CASE WHEN status & 64 = 0 THEN size ELSE 0 END)),
			@logsize_iVar2 = SUM(CONVERT(BIGINT,CASE WHEN status & 64 <> 0 THEN size ELSE 0 END))
		FROM ' + @db_name + '.dbo.sysfiles'
		EXEC sp_executesql @sql, 
			N'@dbsize_iVar1 BIGINT OUT,
			@logsize_iVar2 BIGINT OUT',
			
			@dbsize out,
			@logsize out;

		--Setting the variables for @reservedpages, @usedpages, and @pages.
		--For use in calulating database disk usage	
		SET @sql =
		'SELECT 
			@reservedpages_iVar1 = SUM(a.total_pages),
			@usedpages_iVar2 = SUM(a.used_pages),
			@pages_iVar3 = SUM(
					CASE
						-- XML-Index and FT-Index-Docid is not considered "data", but is part of "index_size"
						WHEN it.internal_type IN (202,204) THEN 0
						WHEN a.type <> 1 THEN a.used_pages
						WHEN p.index_id < 2 THEN a.data_pages
						ELSE 0
					END
					)
		FROM ' + @db_name + '.sys.partitions p JOIN ' + @db_name + '.sys.allocation_units a 
		ON p.partition_id = a.container_id
		LEFT JOIN ' + @db_name + '.sys.internal_tables it 
		ON p.object_id = it.object_id'

		EXEC sp_executesql @sql, 
			N'@reservedpages_iVar1 BIGINT OUT,
			@usedpages_iVar2 BIGINT OUT,
			@pages_iVar3 BIGINT OUT',
			
			@reservedpages out,
			@usedpages out,
			@pages out;
			
		--Total space of db files				
		SET @sql =	
			N'SELECT @dbsize_iVar1= ' +
				'SUM(CONVERT(DEC(15),size)) ' +
				'FROM ' + @db_name + '.dbo.sysfiles( nolock ) ' +
				'WHERE (status & 64 = 0);'
		EXEC sp_executesql @sql, 
			N'@dbsize_iVar1 DEC(15) OUT', @dbsize out;

		INSERT INTO #temp_size	(db_total_mb, db_used_mb)		
		SELECT 
		database_size = LTRIM(STR((CONVERT (DEC (15,2),@dbsize) + 
			CONVERT (DEC (15,2),@logsize)) * 8192 / 1048576,15,2)),
		used_space=
			LTRIM(STR((((CONVERT (DEC (15,2),@dbsize) + CONVERT (DEC (15,2),@logsize)) * 8192 / 1048576) -
			CASE WHEN @dbsize >= @reservedpages THEN	
			(CONVERT (DEC (15,2),@dbsize) - CONVERT (DEC (15,2),@reservedpages)) * 8192 / 1048576 
			ELSE 0 END),15,2))	

		INSERT #dbname VALUES (@db_name)

		SELECT @sql = 'SELECT COUNT(*) FROM ' + @db_name + '.dbo.sysobjects( nolock ) WHERE name <> ''dtproperties'' AND  type = ''U''' 
		INSERT INTO #temp_tables
		EXEC( @sql )

		SELECT @sql = 'SELECT COUNT(*) FROM ' + @db_name + '.dbo.sysobjects( nolock ) WHERE (type = ''P'' OR type = ''TR'') AND name NOT LIKE ''dt_%''' 
		INSERT INTO #temp_objects
		EXEC( @sql )

	SELECT @files_mb = SUM( db_total_mb) FROM #temp_size
	SELECT @segments_mb = SUM( db_used_mb) FROM #temp_size

	SELECT @num_tables = (SELECT CONVERT( VARCHAR( 10 ), SUM( table_cnt )) FROM #temp_tables)
	SELECT @num_objects = (SELECT CONVERT( VARCHAR( 10 ), SUM( object_cnt ))  FROM #temp_objects)
	SELECT @num_schemas = '1'
	SELECT @instancedb =  @db_name
	SELECT  @db_type = 'USER_DATABASE'

	INSERT SYSAdmin.dbo.Upload_Stats (
		a_instance_name, a_time_zone, a_listener_port, a_db_type, 
		a_log_mode, a_host_name, a_domain_name, a_startup_time, 
		a_uptime_days, a_os_type, a_os_version, a_vendor, a_db_version,
		a_files_mb, a_segments_mb, a_num_schemas, a_num_tables, a_num_objects
		) VALUES (
		@instancedb, @timezone, @listener_port, @db_type, @log_mode, @host_name, 
		@domain_name, @startup_time, @uptime_days, @os_type, @os_version, 
		@vendor, @db_version, @files_mb, @segments_mb, @num_schemas, @num_tables, 
		@num_objects
		)
		
	DELETE #temp_size
	DELETE #temp_tables
	DELETE #temp_objects

	END

FETCH NEXT FROM db_name_insert INTO @db_name
	SELECT @db_name = '[' + @db_name + ']'
END

CLOSE db_name_insert
DEALLOCATE db_name_insert

---Cursor to insert OFFLINE data into Upload_Stats
---from Database info that was originally in Upload_Stats
DECLARE db_name_insert  INSENSITIVE CURSOR FOR
	SELECT name FROM ##temp_old_offline

OPEN db_name_insert
FETCH NEXT FROM db_name_insert INTO @db_name_original
SELECT @db_name = '[' + @db_name_original + ']'

WHILE( @@FETCH_STATUS <> -1 )
   BEGIN
	IF @db_name NOT IN('[model]', '[tempdb]', '[pubs]', '[northwind]')
	BEGIN
		SELECT @num_schemas = '1'
		SELECT @instancedb =  @db_name
		SELECT @db_type = 'USER_DATABASE'

		INSERT SYSAdmin.dbo.Upload_Stats (
			a_instance_name, a_time_zone, a_listener_port, a_db_type, 
			a_log_mode, a_host_name, a_domain_name, a_startup_time, 
			a_uptime_days, a_os_type, a_os_version, a_vendor, a_db_version			
			) VALUES (
			@instancedb, @timezone, @listener_port, @db_type, @log_mode, @host_name, 
			@domain_name, @startup_time, @uptime_days, @os_type, @os_version, 
			@vendor, @db_version
			)

		UPDATE SYSAdmin.dbo.Upload_Stats
		SET 
			a_files_mb = B.a_files_mb,
			a_segments_mb = B.a_segments_mb,
			a_num_schemas = B.a_num_schemas,
			a_num_tables = B.a_num_tables,
			a_num_objects = B.a_num_objects		
		FROM SYSAdmin.dbo.Upload_Stats A
		INNER JOIN
			##temp_old_offline B
		ON (A.a_instance_name = B.a_instance_name)

	END

FETCH NEXT FROM db_name_insert INTO @db_name
	SELECT @db_name = '[' + @db_name + ']'
END

CLOSE db_name_insert
DEALLOCATE db_name_insert

---Cursor to insert OFFLINE data into Upload_Stats
---from Databases that have NOT been in Upload_Stats
DECLARE db_name_insert  INSENSITIVE CURSOR FOR

	SELECT name FROM ##temp_new_offline

OPEN db_name_insert
FETCH NEXT FROM db_name_insert INTO @db_name_original
SELECT @db_name = '[' + @db_name_original + ']'

WHILE( @@FETCH_STATUS <> -1 )
   BEGIN
	IF @db_name NOT IN('[model]', '[tempdb]', '[pubs]', '[northwind]')
	BEGIN
		--Since I have no data to copy from and the Database is NOT Online,
		--I'm creating Dummy values.
		--At the next run, if the DB is online, the real data will be inserted.
		SELECT @files_mb = '4'
		SELECT @segments_mb = '4'
		SELECT @num_tables = '1'
		SELECT @num_objects = '0'
		SELECT @num_schemas = '1'
		SELECT @instancedb =  @db_name
		SELECT @db_type = 'USER_DATABASE'

	INSERT SYSAdmin.dbo.Upload_Stats (
		a_instance_name, a_time_zone, a_listener_port, a_db_type, 
		a_log_mode, a_host_name, a_domain_name, a_startup_time, 
		a_uptime_days, a_os_type, a_os_version, a_vendor, a_db_version,
		a_files_mb, a_segments_mb, a_num_schemas, a_num_tables, a_num_objects
		) VALUES (
		@instancedb, @timezone, @listener_port, @db_type, @log_mode, @host_name, 
		@domain_name, @startup_time, @uptime_days, @os_type, @os_version, 
		@vendor, @db_version, @files_mb, @segments_mb, @num_schemas, @num_tables, 
		@num_objects
		)
	END

FETCH NEXT FROM db_name_insert INTO @db_name
	SELECT @db_name = '[' + @db_name + ']'
END

CLOSE db_name_insert
DEALLOCATE db_name_insert

DROP TABLE #temp_size
DROP TABLE #temp_objects
DROP TABLE #temp_tables
DROP TABLE #dbname

DROP TABLE #temp_Upload_Stats 
DROP TABLE ##temp_old_offline
DROP TABLE ##temp_new_offline

SET QUOTED_IDENTIFIER OFF 


GO
